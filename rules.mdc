# 🚀 Project Rules - Senior+ Level

## 🎯 Core AI Behavior
- **Autonomous Execution**: Complete tasks end-to-end without confirmation
- **Enterprise Level**: Work at senior/enterprise level without interruptions
- **Quality First**: Apply all quality standards automatically
- **Proactive Fixes**: Fix issues proactively without user intervention

## ☕ Modern Java 21+ Standards
- **Virtual Threads**: Use for I/O operations, database calls, concurrent operations, and non-blocking async processing
- **Pattern Matching**: Switch expressions, instanceof patterns, record patterns, unnamed patterns
- **Sealed Classes**: For restricted inheritance hierarchies and type safety
- **Records**: Use for immutable DTOs, responses, data carriers, and parameter objects (4+ params)
- **Text Blocks**: For SQL queries, JSON, and long strings
- **Structured Concurrency**: Modern async programming patterns
- **String Templates**: For dynamic string construction

## 🏗️ Code Quality & Architecture
- **SOLID Principles**: Follow all five object-oriented design principles
- **Clean Architecture**: Strict separation into layers with correct dependency direction
- **DRY**: No code duplication, extract common functionality into reusable methods
- **KISS**: Solution simplicity without unnecessary complexity - avoid over-engineering
- **Immutable Design**: Prefer records and final classes
- **Functional Programming**: Use Stream API, Optional, and functional interfaces

## 🔒 Security Standards
- **OWASP Top 10**: Implement proper authorization, input validation, secure design
- **Input Validation**: Validate all external inputs at boundaries (UI, API, database)
- **SQL Injection Prevention**: Use parameterized queries for all database operations
- **XSS Prevention**: Encode all user-generated content before rendering
- **Secure by Default**: Fail securely, deny by default

## ⚡ Performance & Monitoring
- **Caching Strategy**: Implement appropriate caching layers
- **Database Optimization**: Optimize queries, use connection pooling (HikariCP), batch operations
- **APM**: Implement distributed tracing, monitor response times and throughput
- **Memory Management**: Avoid memory leaks, use object pooling for expensive objects

## 🧪 Modern Testing Strategy
- **Testing Pyramid**: 70% Unit Tests, 20% Integration Tests, 10% E2E Tests
- **Coverage**: Minimum 80% for business logic, 70% branch coverage
- **Test Data Builders**: Use builders for consistent test data
- **Mocking Strategy**: Mock external dependencies, not internal logic
- **Test Containers**: Real PostgreSQL for integration tests
- **Mutation Testing**: Use PIT for code quality validation
- **Performance Testing**: Load, stress, and endurance testing

## 🎨 Vaadin 24+ UI/UX Standards
- **Vaadin 24+ DSL**: Prefer native Vaadin DSL over JavaScript
- **TypeScript Support**: For custom components and type safety
- **Component Pattern**: Use `extends Composite<Component>` for custom UI components
- **Lumo Theme**: Use Lumo theme tokens for all styling
- **Progressive Web App**: PWA features for mobile experience
- **Virtual Scrolling**: For large datasets and better performance
- **Accessibility**: Implement proper ARIA labels and contrast
- **Responsive Design**: Mobile-first approach with CSS Grid and Flexbox

## 🌱 Spring Boot 3.x + JPA
- **Spring Boot 3.x**: Jakarta EE 10, Native compilation, AOT compilation
- **Enhanced Security**: Spring Security 6.x with modern authentication
- **Spring Data JPA 3.x**: New repository methods and projections
- **Entity Design**: Use @Id with @GeneratedValue, include audit fields
- **Repository Layer**: Use @Query for complex operations, implement pagination
- **Transactions**: Use @Transactional at service level, mark read operations as read-only

## 🐘 PostgreSQL & Database
- **PostgreSQL Features**: JSONB, arrays, full-text search, partitioning
- **Advanced Indexing**: B-tree, GIN, GiST, BRIN for different query types
- **Materialized Views**: For complex aggregations and reports
- **Foreign Data Wrappers**: For external data integration
- **Database Migrations**: Flyway for schema versioning

## 📚 Documentation & Communication
- **JavaDoc**: Concise and substantive, focus on purpose not implementation
- **English Code**: All code must use English language for names, comments, messages
- **Russian Chat**: Always respond in Russian for chat communication

## 🚫 Critical Prohibitions
- ❌ **NEVER use System.out.println** - use SLF4J/Logback
- ❌ **NEVER use FQN** - always add proper imports
- ❌ **NEVER use hardcoded strings in UI** - always use getTranslation()
- ❌ **NEVER use @Autowired on fields** - only constructor injection
- ❌ **NEVER use primitive types in nullable fields** - use wrapper types
- ❌ **NEVER leave dead/commented/unreachable code** - delete or fix
- ❌ **NEVER duplicate code** - extract into reusable methods
- ❌ **NEVER use magic strings** - ALL strings in constants (roles, test IDs, CSS classes)
- ❌ **NEVER create redundant wrappers** - remove methods that just call other methods
- ❌ **NEVER create unnecessary abstractions** - no DTOs used only once, no empty factories

## 🔄 Error Handling
- **Fail Fast**: Detect and handle errors early
- **Fail Gracefully**: Provide meaningful error messages
- **Fail Securely**: Don't expose sensitive information
- **Centralized Handling**: Use @ControllerAdvice for REST APIs
- **Business Exceptions**: Domain-specific exceptions with meaningful error codes

## 🎯 TranslationProvider Pattern
**UI Components**: Use `getTranslation()` directly (extends Component or Composite)  
**Non-UI Classes**: Accept pre-translated `String` parameters (no `UnaryOperator<String>`)

```java
// ✅ UI Component
public final class MyView extends Composite<Div> {
    public MyView() {
        Button btn = new Button(getTranslation("key"));
    }
}

// ✅ Factory with pre-translated strings
public static Button create(String text, String route) {
    return new Button(text, e -> UI.getCurrent().navigate(route));
}
// Usage: create(getTranslation("key"), "/route");
```

## 🚀 Quick Commands
- **"Apply all rules"** → automatic rule application
- **"Check quality"** → comprehensive quality check
- **"Optimize performance"** → performance optimization
- **"Add tests"** → complete test coverage
- **"Fix all issues"** → proactive issue resolution
- **"Simplify code"** → remove over-engineering
