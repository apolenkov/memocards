---
name: Deploy to VPS

# This workflow deploys Docker images that are already built by main.yml
# It does NOT build images itself - it waits for and reuses the image from main.yml
# This avoids duplicate Docker builds and saves ~15 minutes per deployment

on:
  # Manual trigger
  workflow_dispatch:
    inputs:
      environment:
        description: "Deployment environment"
        required: true
        default: "production"
        type: choice
        options:
          - production
      image_tag:
        description: "Docker image tag to deploy (leave empty for git SHA)"
        required: false
        default: ""
        type: string

  # Automatic trigger on tag creation (releases)
  push:
    tags:
      - 'v*.*.*'

# Prevent concurrent production deployments (wait for completion)
concurrency:
  group: production-deployment
  cancel-in-progress: false

env:
  # VPS Configuration (from GitHub Variables - REQUIRED!)
  # Set in: Settings ‚Üí Secrets and variables ‚Üí Actions ‚Üí Variables
  VPS_IP: ${{ vars.VPS_IP }}
  VPS_USER: ${{ vars.VPS_USER }}
  APP_DOMAIN: ${{ vars.APP_DOMAIN }}
  APP_PORT: "8080"

jobs:
  validate-config:
    name: Validate Configuration
    runs-on: ubuntu-latest
    timeout-minutes: 1

    steps:
      - name: Check required GitHub Variables
        run: |
          echo "üîç Validating GitHub Variables..."

          if [ -z "${{ vars.VPS_IP }}" ]; then
            echo "‚ùå ERROR: VPS_IP variable is not set!"
            echo "üìã Please set it in: Settings ‚Üí Secrets and variables ‚Üí Actions ‚Üí Variables"
            echo "   Name: VPS_IP"
            echo "   Value: YOUR_VPS_IP_ADDRESS"
            exit 1
          fi

          if [ -z "${{ vars.VPS_USER }}" ]; then
            echo "‚ùå ERROR: VPS_USER variable is not set!"
            echo "üìã Please set it in: Settings ‚Üí Secrets and variables ‚Üí Actions ‚Üí Variables"
            echo "   Name: VPS_USER"
            echo "   Value: root (or your user)"
            exit 1
          fi

          if [ -z "${{ vars.APP_DOMAIN }}" ]; then
            echo "‚ùå ERROR: APP_DOMAIN variable is not set!"
            echo "üìã Please set it in: Settings ‚Üí Secrets and variables ‚Üí Actions ‚Üí Variables"
            echo "   Name: APP_DOMAIN"
            echo "   Value: YOUR_DOMAIN"
            exit 1
          fi

          echo "‚úÖ All required variables are set:"
          echo "   VPS_IP: ${{ vars.VPS_IP }}"
          echo "   VPS_USER: ${{ vars.VPS_USER }}"
          echo "   APP_DOMAIN: ${{ vars.APP_DOMAIN }}"

  ansible-lint:
    name: Ansible Quality Checks
    needs: validate-config
    uses: ./.github/workflows/ansible-lint.yml
    secrets: inherit

  wait-for-image:
    needs: ansible-lint
    name: Wait for Docker Image from main.yml
    runs-on: ubuntu-latest
    timeout-minutes: 30 # Time to wait for Docker image to be built
    permissions:
      contents: read # For repository access
      packages: read # For docker manifest inspect
    outputs:
      image_tag: ${{ steps.get_tag.outputs.tag }}
      full_image: ${{ steps.get_tag.outputs.full_image }}

    steps:
      - name: Determine image tag
        id: get_tag
        env:
          INPUT_TAG: ${{ inputs.image_tag }}
        run: |
          # Security: Use env var to prevent script injection
          if [ -n "$INPUT_TAG" ]; then
            TAG="$INPUT_TAG"
            
            # Validate tag format (semantic versioning with optional 'v' prefix)
            if [[ ! "$TAG" =~ ^v?[0-9]+\.[0-9]+\.[0-9]+(-[a-zA-Z0-9.-]+)?$ ]]; then
              echo "‚ùå ERROR: Invalid tag format: '$TAG'"
              echo "Expected: v1.0.0 or 1.0.0 or 1.0.0-beta"
              exit 1
            fi
            
            # Normalize: strip 'v' prefix if present (Jib creates tags without 'v')
            # Example: v1.0.0 ‚Üí 1.0.0
            TAG="${TAG#v}"
            
            echo "üìã Using manual tag: $TAG (validated and normalized from input)"
          else
            TAG="${GITHUB_SHA:0:7}"
            echo "üìã Using git SHA tag: $TAG"
          fi
          
          # Validate tag format
          if [[ ! "$TAG" =~ ^[a-zA-Z0-9._-]+$ ]]; then
            echo "‚ùå ERROR: Invalid tag format: '$TAG'"
            echo "Expected: alphanumeric with dots, dashes, underscores"
            exit 1
          fi
          
          echo "tag=$TAG" >> $GITHUB_OUTPUT
          echo "full_image=ghcr.io/${{ github.repository_owner }}/memocards:$TAG" >> $GITHUB_OUTPUT

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Wait for Docker image
        run: |
          IMAGE="ghcr.io/${{ github.repository_owner }}/memocards:${{ steps.get_tag.outputs.tag }}"
          MAX_ATTEMPTS=50  # 50 attempts * 30s = 25 minutes
          
          echo "‚è≥ Waiting for image: $IMAGE"
          
          for i in $(seq 1 $MAX_ATTEMPTS); do
            if docker manifest inspect "$IMAGE" > /dev/null 2>&1; then
              echo "‚úÖ Image found after $((i * 30))s (attempt $i/$MAX_ATTEMPTS)"
              echo "üì¶ Ready to deploy: $IMAGE"
              exit 0
            fi
            
            if [ $i -lt $MAX_ATTEMPTS ]; then
              echo "‚è≥ Attempt $i/$MAX_ATTEMPTS: Image not ready yet, waiting 30s..."
              sleep 30
            fi
          done
          
          echo "‚ùå Timeout after $((MAX_ATTEMPTS * 30))s!"
          echo "   Check main.yml workflow: https://github.com/${{ github.repository }}/actions/workflows/main.yml"
          exit 1

  deploy:
    name: Deploy to VPS with Ansible
    needs: wait-for-image
    runs-on: ubuntu-latest
    timeout-minutes: 15 # Ansible deployment time
    
    # GitHub Environment for production deployment
    # Provides: deployment history, required reviewers, protection rules
    environment:
      name: production
      url: https://${{ vars.APP_DOMAIN }}
    
    permissions:
      contents: read # For checkout

    steps:
      - name: Checkout code
        uses: actions/checkout@v5
        with:
          persist-credentials: false

      - name: Deployment configuration
        id: deploy_tag
        run: |
          # Use image from wait-for-image job
          echo "tag=${{ needs.wait-for-image.outputs.image_tag }}" >> $GITHUB_OUTPUT
          echo "full_image=${{ needs.wait-for-image.outputs.full_image }}" >> $GITHUB_OUTPUT

          echo "## üöÄ Deployment Configuration" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Image:** \`${{ needs.wait-for-image.outputs.full_image }}\`" >> $GITHUB_STEP_SUMMARY
          echo "**Environment:** \`${{ inputs.environment || 'production' }}\`" >> $GITHUB_STEP_SUMMARY
          echo "**Source:** Built by main.yml workflow" >> $GITHUB_STEP_SUMMARY

      - name: Set up Python
        uses: actions/setup-python@v6
        with:
          python-version: "3.11"

      - name: Install Ansible and dependencies
        run: |
          python -m pip install --upgrade pip
          pip install ansible

      - name: Cache Ansible collections
        uses: actions/cache@v4
        with:
          path: ~/.ansible/collections
          key: ${{ runner.os }}-ansible-collections-${{ hashFiles('ansible/requirements.yml') }}
          restore-keys: |
            ${{ runner.os }}-ansible-collections-

      - name: Install Ansible collections
        run: |
          cd ansible
          ansible-galaxy collection install -r requirements.yml

      - name: Setup SSH Agent
        uses: webfactory/ssh-agent@v0.9.1
        with:
          ssh-private-key: ${{ secrets.VPS_SSH_KEY }}

      - name: Add VPS to known hosts
        run: |
          mkdir -p ~/.ssh
          # Security: Use pre-verified SSH host key instead of ssh-keyscan (MITM vulnerable)
          # Generate with: ssh-keyscan -H YOUR_VPS_IP
          # Store in GitHub Secrets as VPS_SSH_HOST_KEY
          if [ -n "${{ secrets.VPS_SSH_HOST_KEY }}" ]; then
            echo "${{ secrets.VPS_SSH_HOST_KEY }}" >> ~/.ssh/known_hosts
          else
            echo "::warning::VPS_SSH_HOST_KEY not set. Falling back to ssh-keyscan (not recommended for production)"
            ssh-keyscan -H ${{ env.VPS_IP }} >> ~/.ssh/known_hosts
          fi

      - name: Create Ansible Vault password file
        run: |
          echo "${{ secrets.ANSIBLE_VAULT_PASSWORD }}" > .vault_pass
          chmod 600 .vault_pass

      - name: Test Ansible connectivity
        working-directory: ./ansible
        run: |
          ansible -i inventory/hosts.yml vps -m ping --vault-password-file ../.vault_pass

      - name: Deploy application with Ansible
        working-directory: ./ansible
        env:
          DEPLOY_IMAGE_TAG: ${{ steps.deploy_tag.outputs.tag }}
        run: |
          echo "üöÄ Deploying image: ${{ steps.deploy_tag.outputs.full_image }}"
          ansible-playbook \
            -i inventory/hosts.yml \
            playbooks/deploy.yml \
            --vault-password-file ../.vault_pass \
            --extra-vars "app_image=${{ steps.deploy_tag.outputs.full_image }}" \
            -v

      - name: Verify deployment
        run: |
          echo "‚è≥ Waiting for application to be ready..."
          sleep 30

          # Check if application is responding
          HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" https://${{ env.APP_DOMAIN }}/actuator/health || echo "000")

          if [ "$HTTP_STATUS" = "200" ]; then
            echo "‚úÖ Deployment successful! Application is healthy."
          else
            echo "‚ö†Ô∏è Warning: Application returned HTTP $HTTP_STATUS"
            echo "This might be normal if the application is still starting up."
          fi

      - name: Clean up sensitive files
        if: always()
        run: |
          # Security: Shred vault password file to prevent recovery
          if [ -f .vault_pass ]; then
            shred -u .vault_pass 2>/dev/null || rm -f .vault_pass
          fi

      - name: Deployment summary
        run: |
          echo "‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó"
          echo "‚ïë      üöÄ Deployment Completed!                             ‚ïë"
          echo "‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù"
          echo ""
          echo "üì¶ Image: ${{ steps.deploy_tag.outputs.full_image }}"
          echo "üè∑Ô∏è  Tag: ${{ steps.deploy_tag.outputs.tag }}"
          echo "üè∑Ô∏è  Commit: ${{ github.sha }}"
          echo "üåê URL: https://${{ env.APP_DOMAIN }}"
          echo "üíö Health: https://${{ env.APP_DOMAIN }}/actuator/health"
          echo ""
          echo "üìã Next steps:"
          echo "  - Verify application: curl -I https://${{ env.APP_DOMAIN }}"
          echo "  - Check logs: ssh ${{ env.VPS_USER }}@${{ env.VPS_IP }} 'docker logs -f memocards-app-prod'"
          echo ""
          echo "## üéâ Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "‚úÖ **Status:** Completed" >> $GITHUB_STEP_SUMMARY
          echo "üì¶ **Image:** \`${{ steps.deploy_tag.outputs.full_image }}\`" >> $GITHUB_STEP_SUMMARY
          echo "üåê **URL:** [${{ env.APP_DOMAIN }}](https://${{ env.APP_DOMAIN }})" >> $GITHUB_STEP_SUMMARY
          echo "üíö **Health:** [/actuator/health](https://${{ env.APP_DOMAIN }}/actuator/health)" >> $GITHUB_STEP_SUMMARY
