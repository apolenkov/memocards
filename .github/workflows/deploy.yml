name: Deploy to VPS

# This workflow deploys Docker images that are already built by main.yml
# It does NOT build images itself - it waits for and reuses the image from main.yml
# This avoids duplicate Docker builds and saves ~15 minutes per deployment

on:
  # Manual trigger
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'production'
        type: choice
        options:
          - production
      image_tag:
        description: 'Docker image tag to deploy (leave empty for git SHA)'
        required: false
        default: ''
        type: string
  
  # Automatic trigger on push to master
  push:
    branches:
      - master
    paths-ignore:
      - '**.md'
      - 'docs/**'
      - '.gitignore'

# Prevent concurrent production deployments (wait for completion)
concurrency:
  group: production-deployment
  cancel-in-progress: false

jobs:
  wait-for-image:
    name: Wait for Docker Image from main.yml
    runs-on: ubuntu-latest
    outputs:
      image_tag: ${{ steps.get_tag.outputs.tag }}
      full_image: ${{ steps.get_tag.outputs.full_image }}
    
    steps:
      - name: Determine image tag
        id: get_tag
        run: |
          # Use manual tag if provided, otherwise git SHA (same as main.yml)
          if [ -n "${{ inputs.image_tag }}" ]; then
            TAG="${{ inputs.image_tag }}"
            echo "ðŸ“‹ Using manual tag: $TAG"
          else
            TAG="${GITHUB_SHA:0:7}"
            echo "ðŸ“‹ Using git SHA tag: $TAG"
          fi
          echo "tag=$TAG" >> $GITHUB_OUTPUT
          echo "full_image=ghcr.io/${{ github.repository_owner }}/memocards:$TAG" >> $GITHUB_OUTPUT
      
      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Wait for Docker image to be available
        run: |
          IMAGE="ghcr.io/${{ github.repository_owner }}/memocards:${{ steps.get_tag.outputs.tag }}"
          echo "â³ Waiting for image: $IMAGE"
          echo "This image should be built by main.yml workflow..."
          
          # Wait up to 25 minutes (50 attempts * 30 seconds)
          for i in {1..50}; do
            if docker manifest inspect "$IMAGE" > /dev/null 2>&1; then
              echo "âœ… Image found! Ready to deploy."
              exit 0
            fi
            echo "â³ Attempt $i/50: Image not ready yet, waiting 30 seconds..."
            sleep 30
          done
          
          echo "âŒ ERROR: Image not found after 25 minutes!"
          echo "Please check if main.yml workflow completed successfully."
          exit 1

  deploy:
    name: Deploy to VPS with Ansible
    needs: wait-for-image
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Deployment configuration
        id: deploy_tag
        run: |
          # Use image from wait-for-image job
          echo "tag=${{ needs.wait-for-image.outputs.image_tag }}" >> $GITHUB_OUTPUT
          echo "full_image=${{ needs.wait-for-image.outputs.full_image }}" >> $GITHUB_OUTPUT
          
          echo "## ðŸš€ Deployment Configuration" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Image:** \`${{ needs.wait-for-image.outputs.full_image }}\`" >> $GITHUB_STEP_SUMMARY
          echo "**Environment:** \`${{ inputs.environment || 'production' }}\`" >> $GITHUB_STEP_SUMMARY
          echo "**Source:** Built by main.yml workflow" >> $GITHUB_STEP_SUMMARY
      
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
      
      - name: Install Ansible and dependencies
        run: |
          python -m pip install --upgrade pip
          pip install ansible
          ansible-galaxy collection install community.docker
      
      - name: Create Ansible Vault password file
        run: |
          echo "${{ secrets.ANSIBLE_VAULT_PASSWORD }}" > .vault_pass
          chmod 600 .vault_pass
      
      - name: Create SSH key file (if configured)
        continue-on-error: true
        run: |
          if [ -n "${{ secrets.VPS_SSH_KEY }}" ]; then
            mkdir -p ~/.ssh
            echo "${{ secrets.VPS_SSH_KEY }}" > ~/.ssh/id_rsa
            chmod 600 ~/.ssh/id_rsa
          fi
      
      - name: Test Ansible connectivity
        working-directory: ./ansible
        run: |
          ansible -i inventory/hosts.yml vps -m ping --vault-password-file ../.vault_pass
      
      - name: Deploy application with Ansible
        working-directory: ./ansible
        env:
          DEPLOY_IMAGE_TAG: ${{ steps.deploy_tag.outputs.tag }}
        run: |
          echo "ðŸš€ Deploying image: ${{ steps.deploy_tag.outputs.full_image }}"
          ansible-playbook \
            -i inventory/hosts.yml \
            playbooks/deploy.yml \
            --vault-password-file ../.vault_pass \
            --extra-vars "app_image=${{ steps.deploy_tag.outputs.full_image }}" \
            -v
      
      - name: Verify deployment
        run: |
          echo "â³ Waiting for application to be ready..."
          sleep 30
          
          # Check if application is responding
          HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" https://memocards.duckdns.org/actuator/health || echo "000")
          
          if [ "$HTTP_STATUS" = "200" ]; then
            echo "âœ… Deployment successful! Application is healthy."
          else
            echo "âš ï¸ Warning: Application returned HTTP $HTTP_STATUS"
            echo "This might be normal if the application is still starting up."
          fi
      
      - name: Clean up
        if: always()
        run: |
          rm -f .vault_pass
          rm -f ~/.ssh/id_rsa
      
      - name: Deployment summary
        run: |
          echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
          echo "â•‘      ðŸš€ Deployment Completed!                             â•‘"
          echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo ""
          echo "ðŸ“¦ Image: ${{ steps.deploy_tag.outputs.full_image }}"
          echo "ðŸ·ï¸  Tag: ${{ steps.deploy_tag.outputs.tag }}"
          echo "ðŸ·ï¸  Commit: ${{ github.sha }}"
          echo "ðŸŒ URL: https://memocards.duckdns.org"
          echo "ðŸ’š Health: https://memocards.duckdns.org/actuator/health"
          echo ""
          echo "ðŸ“‹ Next steps:"
          echo "  - Verify application: curl -I https://memocards.duckdns.org"
          echo "  - Check logs: ssh root@185.239.48.254 'docker logs -f memocards-app-prod'"
          echo ""
          echo "## ðŸŽ‰ Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "âœ… **Status:** Completed" >> $GITHUB_STEP_SUMMARY
          echo "ðŸ“¦ **Image:** \`${{ steps.deploy_tag.outputs.full_image }}\`" >> $GITHUB_STEP_SUMMARY
          echo "ðŸŒ **URL:** [memocards.duckdns.org](https://memocards.duckdns.org)" >> $GITHUB_STEP_SUMMARY
          echo "ðŸ’š **Health:** [/actuator/health](https://memocards.duckdns.org/actuator/health)" >> $GITHUB_STEP_SUMMARY

