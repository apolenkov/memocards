Index: src/main/java/org/apolenkov/application/views/core/error/ErrorNavigationButtons.java
===================================================================
diff --git a/src/main/java/org/apolenkov/application/views/core/error/ErrorNavigationButtons.java b/src/main/java/org/apolenkov/application/views/core/error/ErrorNavigationButtons.java
deleted file mode 100644
--- a/src/main/java/org/apolenkov/application/views/core/error/ErrorNavigationButtons.java	(revision 132c2c29773f5f4949b3855c362e338d983d3cd4)
+++ /dev/null	(revision 132c2c29773f5f4949b3855c362e338d983d3cd4)
@@ -1,66 +0,0 @@
-package org.apolenkov.application.views.core.error;
-
-import com.vaadin.flow.component.Composite;
-import com.vaadin.flow.component.button.Button;
-import com.vaadin.flow.component.button.ButtonVariant;
-import com.vaadin.flow.component.orderedlayout.FlexComponent;
-import com.vaadin.flow.component.orderedlayout.HorizontalLayout;
-import org.apolenkov.application.views.core.constants.CoreConstants;
-import org.apolenkov.application.views.shared.utils.ButtonHelper;
-import org.apolenkov.application.views.shared.utils.NavigationHelper;
-
-/**
- * Component responsible for creating and managing navigation buttons in error views.
- * Provides buttons for going home and trying again with proper styling and click handlers.
- */
-public final class ErrorNavigationButtons extends Composite<HorizontalLayout> {
-
-    private final String fromRoute;
-
-    /**
-     * Creates a new ErrorNavigationButtons component.
-     *
-     * @param fromRouteParam the route to navigate back to when "try again" is clicked
-     */
-    public ErrorNavigationButtons(final String fromRouteParam) {
-        this.fromRoute = fromRouteParam;
-    }
-
-    @Override
-    protected HorizontalLayout initContent() {
-        HorizontalLayout layout = new HorizontalLayout();
-        layout.setSpacing(true);
-        layout.setAlignItems(FlexComponent.Alignment.CENTER);
-        layout.setJustifyContentMode(FlexComponent.JustifyContentMode.CENTER);
-
-        Button goHomeButton = createGoHomeButton();
-        Button tryAgainButton = createTryAgainButton();
-
-        layout.add(goHomeButton, tryAgainButton);
-        return layout;
-    }
-
-    /**
-     * Creates the go home button with navigation functionality.
-     *
-     * @return configured go home button
-     */
-    private Button createGoHomeButton() {
-        return ButtonHelper.createButton(
-                getTranslation(CoreConstants.ERROR_GO_HOME_KEY),
-                e -> NavigationHelper.navigateToHome(),
-                ButtonVariant.LUMO_PRIMARY);
-    }
-
-    /**
-     * Creates the try again button with navigation functionality.
-     *
-     * @return configured try again button
-     */
-    private Button createTryAgainButton() {
-        return ButtonHelper.createButton(
-                getTranslation(CoreConstants.ERROR_TRY_AGAIN_KEY),
-                e -> NavigationHelper.navigateTo(fromRoute),
-                ButtonVariant.LUMO_TERTIARY);
-    }
-}
Index: src/main/java/org/apolenkov/application/views/core/error/ErrorParameterExtractor.java
===================================================================
diff --git a/src/main/java/org/apolenkov/application/views/core/error/ErrorParameterExtractor.java b/src/main/java/org/apolenkov/application/views/core/error/ErrorParameterExtractor.java
deleted file mode 100644
--- a/src/main/java/org/apolenkov/application/views/core/error/ErrorParameterExtractor.java	(revision 132c2c29773f5f4949b3855c362e338d983d3cd4)
+++ /dev/null	(revision 132c2c29773f5f4949b3855c362e338d983d3cd4)
@@ -1,70 +0,0 @@
-package org.apolenkov.application.views.core.error;
-
-import com.vaadin.flow.router.BeforeEnterEvent;
-import com.vaadin.flow.router.Location;
-import com.vaadin.flow.router.QueryParameters;
-import java.util.List;
-import org.apolenkov.application.views.core.constants.CoreConstants;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-/**
- * Utility class for extracting error parameters from routing events.
- * Handles the extraction and logging of error-related query parameters.
- */
-public final class ErrorParameterExtractor {
-
-    private static final Logger LOGGER = LoggerFactory.getLogger(ErrorParameterExtractor.class);
-
-    /**
-     * Private constructor to prevent instantiation.
-     */
-    private ErrorParameterExtractor() {
-        throw new UnsupportedOperationException("Utility class");
-    }
-
-    /**
-     * Extracts error parameters from the before enter event and populates the state.
-     *
-     * @param event the before enter event containing query parameters
-     * @param state the error view state to populate
-     */
-    public static void extractParameters(final BeforeEnterEvent event, final ErrorViewState state) {
-        Location location = event.getLocation();
-        QueryParameters queryParams = location.getQueryParameters();
-
-        String fromRoute = extractParameter(queryParams, CoreConstants.FROM_PARAM);
-        String errorType = extractParameter(queryParams, CoreConstants.ERROR_PARAM);
-        String errorMessage = extractParameter(queryParams, CoreConstants.MESSAGE_PARAM);
-        String errorId = extractParameter(queryParams, CoreConstants.ID_PARAM);
-
-        state.updateState(fromRoute, errorType, errorMessage, errorId);
-
-        logExtractedParameters(state);
-    }
-
-    /**
-     * Extracts a single parameter value from query parameters.
-     *
-     * @param queryParams the query parameters
-     * @param paramName the parameter name to extract
-     * @return the parameter value or empty string if not found
-     */
-    private static String extractParameter(final QueryParameters queryParams, final String paramName) {
-        return queryParams.getParameters().getOrDefault(paramName, List.of("")).getFirst();
-    }
-
-    /**
-     * Logs the extracted error parameters for debugging purposes.
-     *
-     * @param state the error view state containing the parameters
-     */
-    private static void logExtractedParameters(final ErrorViewState state) {
-        LOGGER.info(
-                "Extracted parameters: fromRoute={}, errorType={}, errorMessage={}, errorId={}",
-                state.getFromRoute(),
-                state.getErrorType(),
-                state.getErrorMessage(),
-                state.getErrorId());
-    }
-}
Index: src/main/java/org/apolenkov/application/views/core/error/ErrorViewLayout.java
===================================================================
diff --git a/src/main/java/org/apolenkov/application/views/core/error/ErrorViewLayout.java b/src/main/java/org/apolenkov/application/views/core/error/ErrorViewLayout.java
deleted file mode 100644
--- a/src/main/java/org/apolenkov/application/views/core/error/ErrorViewLayout.java	(revision 132c2c29773f5f4949b3855c362e338d983d3cd4)
+++ /dev/null	(revision 132c2c29773f5f4949b3855c362e338d983d3cd4)
@@ -1,60 +0,0 @@
-package org.apolenkov.application.views.core.error;
-
-import com.vaadin.flow.component.Component;
-import com.vaadin.flow.component.Composite;
-import com.vaadin.flow.component.html.H2;
-import com.vaadin.flow.component.html.Span;
-import com.vaadin.flow.component.orderedlayout.FlexComponent;
-import com.vaadin.flow.component.orderedlayout.VerticalLayout;
-import org.apolenkov.application.views.core.constants.CoreConstants;
-
-/**
- * Component responsible for creating and managing the main error display layout.
- * Handles the error title, description, and container setup.
- */
-public final class ErrorViewLayout extends Composite<VerticalLayout> {
-
-    private final H2 title;
-    private final Span description;
-
-    /**
-     * Creates a new ErrorViewLayout component.
-     */
-    public ErrorViewLayout() {
-        // Create and configure title
-        this.title = new H2();
-        title.addClassName(CoreConstants.ERROR_VIEW_TITLE_CLASS);
-
-        // Create and configure description
-        this.description = new Span();
-        description.addClassName(CoreConstants.ERROR_VIEW_DESCRIPTION_CLASS);
-    }
-
-    @Override
-    protected VerticalLayout initContent() {
-        VerticalLayout errorContainer = new VerticalLayout();
-        errorContainer.addClassName(CoreConstants.ERROR_CONTAINER_CLASS);
-        errorContainer.addClassName(CoreConstants.SURFACE_PANEL_CLASS);
-        errorContainer.setSpacing(true);
-        errorContainer.setAlignItems(FlexComponent.Alignment.CENTER);
-        errorContainer.add(title, description);
-        return errorContainer;
-    }
-
-    /**
-     * Updates the error display with error information.
-     */
-    public void updateWithGenericError() {
-        title.setText(getTranslation(CoreConstants.ERROR_500_KEY));
-        description.setText(getTranslation(CoreConstants.ERROR_500_DESCRIPTION_KEY));
-    }
-
-    /**
-     * Adds a component to the error container.
-     *
-     * @param component the component to add
-     */
-    public void addComponent(final Component component) {
-        getContent().add(component);
-    }
-}
Index: src/main/java/org/apolenkov/application/views/core/error/ErrorViewState.java
===================================================================
diff --git a/src/main/java/org/apolenkov/application/views/core/error/ErrorViewState.java b/src/main/java/org/apolenkov/application/views/core/error/ErrorViewState.java
deleted file mode 100644
--- a/src/main/java/org/apolenkov/application/views/core/error/ErrorViewState.java	(revision 132c2c29773f5f4949b3855c362e338d983d3cd4)
+++ /dev/null	(revision 132c2c29773f5f4949b3855c362e338d983d3cd4)
@@ -1,95 +0,0 @@
-package org.apolenkov.application.views.core.error;
-
-/**
- * State management for ErrorView component.
- * Encapsulates all error-related data and provides methods for state validation.
- */
-public final class ErrorViewState {
-
-    private String fromRoute;
-    private String errorType;
-    private String errorMessage;
-    private String errorId;
-
-    /**
-     * Creates a new ErrorViewState with empty values.
-     */
-    public ErrorViewState() {
-        this.fromRoute = "";
-        this.errorType = "";
-        this.errorMessage = "";
-        this.errorId = "";
-    }
-
-    /**
-     * Gets the route that caused the error.
-     *
-     * @return the route
-     */
-    public String getFromRoute() {
-        return fromRoute;
-    }
-
-    /**
-     * Gets the error type.
-     *
-     * @return the error type
-     */
-    public String getErrorType() {
-        return errorType;
-    }
-
-    /**
-     * Gets the error message.
-     *
-     * @return the error message
-     */
-    public String getErrorMessage() {
-        return errorMessage;
-    }
-
-    /**
-     * Gets the error ID.
-     *
-     * @return the error ID
-     */
-    public String getErrorId() {
-        return errorId;
-    }
-
-    /**
-     * Checks if the state contains valid error parameters.
-     * Valid parameters require at least fromRoute and errorType to be non-empty.
-     *
-     * @return true if the state has valid error parameters
-     */
-    public boolean hasValidErrorParameters() {
-        return !fromRoute.isEmpty() && !errorType.isEmpty();
-    }
-
-    /**
-     * Updates all state values at once.
-     *
-     * @param fromRouteValue the route
-     * @param errorTypeValue the error type
-     * @param errorMessageValue the error message
-     * @param errorIdValue the error ID
-     */
-    public void updateState(
-            final String fromRouteValue,
-            final String errorTypeValue,
-            final String errorMessageValue,
-            final String errorIdValue) {
-        this.fromRoute = fromRouteValue != null ? fromRouteValue : "";
-        this.errorType = errorTypeValue != null ? errorTypeValue : "";
-        this.errorMessage = errorMessageValue != null ? errorMessageValue : "";
-        this.errorId = errorIdValue != null ? errorIdValue : "";
-    }
-
-    @Override
-    public String toString() {
-        return String.format(
-                "ErrorViewState{fromRoute='%s', errorType='%s', errorMessage='%s', errorId='%s'}",
-                fromRoute, errorType, errorMessage, errorId);
-    }
-}
Index: src/main/java/org/apolenkov/application/views/deck/business/DeckViewState.java
===================================================================
diff --git a/src/main/java/org/apolenkov/application/views/deck/business/DeckViewState.java b/src/main/java/org/apolenkov/application/views/deck/business/DeckViewState.java
deleted file mode 100644
--- a/src/main/java/org/apolenkov/application/views/deck/business/DeckViewState.java	(revision 132c2c29773f5f4949b3855c362e338d983d3cd4)
+++ /dev/null	(revision 132c2c29773f5f4949b3855c362e338d983d3cd4)
@@ -1,181 +0,0 @@
-package org.apolenkov.application.views.deck.business;
-
-import com.vaadin.flow.component.Composite;
-import com.vaadin.flow.component.html.H2;
-import com.vaadin.flow.component.orderedlayout.FlexComponent;
-import com.vaadin.flow.component.orderedlayout.VerticalLayout;
-import java.util.List;
-import java.util.Optional;
-import org.apolenkov.application.config.constants.RouteConstants;
-import org.apolenkov.application.domain.usecase.DeckUseCase;
-import org.apolenkov.application.domain.usecase.FlashcardUseCase;
-import org.apolenkov.application.model.Deck;
-import org.apolenkov.application.model.Flashcard;
-import org.apolenkov.application.views.core.exception.EntityNotFoundException;
-import org.apolenkov.application.views.deck.components.detail.DeckViewLayout;
-import org.apolenkov.application.views.deck.constants.DeckConstants;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-/**
- * State management component for DeckView.
- * Handles loading states, data updates, and deck information management.
- *
- * <p>Features:
- * <ul>
- *   <li>Loading state management</li>
- *   <li>Deck data loading and validation</li>
- *   <li>Flashcard data management</li>
- *   <li>Deck information updates</li>
- * </ul>
- */
-public final class DeckViewState extends Composite<VerticalLayout> {
-
-    private static final Logger LOGGER = LoggerFactory.getLogger(DeckViewState.class);
-
-    // Dependencies
-    private final transient DeckUseCase deckUseCase;
-    private final transient FlashcardUseCase flashcardUseCase;
-
-    // State
-    private transient Deck currentDeck;
-    private transient DeckViewLayout deckViewLayout;
-
-    /**
-     * Creates a new DeckViewState with required dependencies.
-     *
-     * @param deckUseCaseParam use case for deck operations
-     * @param flashcardUseCaseParam use case for flashcard operations
-     */
-    public DeckViewState(final DeckUseCase deckUseCaseParam, final FlashcardUseCase flashcardUseCaseParam) {
-        this.deckUseCase = deckUseCaseParam;
-        this.flashcardUseCase = flashcardUseCaseParam;
-    }
-
-    /**
-     * Sets the deck view layout for state management.
-     *
-     * @param deckViewLayoutParam the deck view layout
-     */
-    public void setDeckViewLayout(final DeckViewLayout deckViewLayoutParam) {
-        this.deckViewLayout = deckViewLayoutParam;
-    }
-
-    /**
-     * Shows loading state while deck is being loaded.
-     */
-    public void showLoadingState() {
-        getContent().removeAll();
-
-        VerticalLayout loadingContainer = createLoadingContainer();
-        VerticalLayout loadingSection = createLoadingSection();
-
-        loadingContainer.add(loadingSection);
-        getContent().add(loadingContainer);
-    }
-
-    /**
-     * Creates the loading container layout.
-     *
-     * @return the configured loading container
-     */
-    private VerticalLayout createLoadingContainer() {
-        VerticalLayout loadingContainer = new VerticalLayout();
-        loadingContainer.setSpacing(true);
-        loadingContainer.setWidthFull();
-        loadingContainer.addClassName(DeckConstants.CONTAINER_MD_CLASS);
-        loadingContainer.setAlignItems(FlexComponent.Alignment.CENTER);
-        return loadingContainer;
-    }
-
-    /**
-     * Creates the loading section with title.
-     *
-     * @return the configured loading section
-     */
-    private VerticalLayout createLoadingSection() {
-        VerticalLayout loadingSection = new VerticalLayout();
-        loadingSection.setSpacing(true);
-        loadingSection.setPadding(true);
-        loadingSection.setWidthFull();
-        loadingSection.addClassName(DeckConstants.DECK_VIEW_SECTION_CLASS);
-        loadingSection.addClassName(DeckConstants.SURFACE_PANEL_CLASS);
-        loadingSection.addClassName(DeckConstants.CONTAINER_MD_CLASS);
-
-        H2 loadingTitle = new H2(getTranslation(DeckConstants.DECK_LOADING_STATE));
-        loadingTitle.addClassName(DeckConstants.DECK_VIEW_TITLE_CLASS);
-
-        loadingSection.add(loadingTitle);
-        return loadingSection;
-    }
-
-    /**
-     * Loads a deck by ID and initializes the state.
-     *
-     * @param deckId the ID of the deck to load
-     * @throws EntityNotFoundException if deck is not found
-     */
-    public void loadDeck(final long deckId) {
-        Optional<Deck> deckOpt = deckUseCase.getDeckById(deckId);
-        if (deckOpt.isPresent()) {
-            setCurrentDeck(deckOpt.get());
-            LOGGER.info("Deck loaded successfully: {}", currentDeck.getTitle());
-        } else {
-            LOGGER.warn("Deck not found with ID: {}", deckId);
-            // Just throw the exception - it will be caught by EntityNotFoundErrorHandler
-            throw new EntityNotFoundException(
-                    String.valueOf(deckId), RouteConstants.DECKS_ROUTE, getTranslation(DeckConstants.DECK_NOT_FOUND));
-        }
-    }
-
-    /**
-     * Updates the display of deck information (title, stats, description).
-     */
-    public void updateDeckInfo() {
-        if (currentDeck != null && deckViewLayout != null) {
-            if (deckViewLayout.getDeckHeader() != null) {
-                deckViewLayout.getDeckHeader().setDeckTitle(currentDeck.getTitle());
-                deckViewLayout
-                        .getDeckHeader()
-                        .setDeckStats(getTranslation(
-                                DeckConstants.DECK_COUNT, flashcardUseCase.countByDeckId(currentDeck.getId())));
-            }
-            if (deckViewLayout.getDeckInfo() != null) {
-                String description = Optional.ofNullable(currentDeck.getDescription())
-                        .filter(desc -> !desc.trim().isEmpty())
-                        .orElse(getTranslation(DeckConstants.DECK_DESCRIPTION_EMPTY));
-                deckViewLayout.getDeckInfo().setDescription(description);
-            }
-        }
-    }
-
-    /**
-     * Loads flashcards for the current deck and updates the grid.
-     */
-    public void loadFlashcards() {
-        if (currentDeck != null && deckViewLayout != null && deckViewLayout.getDeckGrid() != null) {
-            List<Flashcard> flashcards = flashcardUseCase.getFlashcardsByDeckId(currentDeck.getId());
-            deckViewLayout.getDeckGrid().setCurrentDeckId(currentDeck.getId());
-            deckViewLayout.getDeckGrid().setFlashcards(flashcards);
-            LOGGER.info("Loaded {} flashcards for deck: {}", flashcards.size(), currentDeck.getTitle());
-        }
-    }
-
-    /**
-     * Gets the current deck.
-     *
-     * @return the current deck, or null if not loaded
-     */
-    public Deck getCurrentDeck() {
-        return currentDeck;
-    }
-
-    /**
-     * Sets the current deck.
-     *
-     * @param deck the deck to set as current
-     */
-    public void setCurrentDeck(final Deck deck) {
-        this.currentDeck = deck;
-    }
-}
Index: src/main/java/org/apolenkov/application/views/practice/business/PracticePresenter.java
===================================================================
diff --git a/src/main/java/org/apolenkov/application/views/practice/business/PracticePresenter.java b/src/main/java/org/apolenkov/application/views/practice/business/PracticePresenter.java
deleted file mode 100644
--- a/src/main/java/org/apolenkov/application/views/practice/business/PracticePresenter.java	(revision 132c2c29773f5f4949b3855c362e338d983d3cd4)
+++ /dev/null	(revision 132c2c29773f5f4949b3855c362e338d983d3cd4)
@@ -1,182 +0,0 @@
-package org.apolenkov.application.views.practice.business;
-
-import java.util.List;
-import java.util.Optional;
-import org.apolenkov.application.model.Deck;
-import org.apolenkov.application.model.Flashcard;
-import org.apolenkov.application.model.PracticeDirection;
-import org.springframework.stereotype.Component;
-
-/**
- * Presenter for managing flashcard practice sessions.
- * Coordinates between session service and session manager.
- */
-@Component
-public final class PracticePresenter {
-
-    // Dependencies
-    private final PracticeSessionService sessionService;
-    private final PracticeSessionManager sessionManager;
-
-    /**
-     * Creates a new PracticePresenter with required dependencies.
-     *
-     * @param sessionServiceValue service for session preparation and configuration
-     * @param sessionManagerValue manager for active session operations
-     * @throws IllegalArgumentException if any parameter is null
-     */
-    public PracticePresenter(
-            final PracticeSessionService sessionServiceValue, final PracticeSessionManager sessionManagerValue) {
-
-        if (sessionServiceValue == null) {
-            throw new IllegalArgumentException("PracticeSessionService cannot be null");
-        }
-        if (sessionManagerValue == null) {
-            throw new IllegalArgumentException("PracticeSessionManager cannot be null");
-        }
-
-        this.sessionService = sessionServiceValue;
-        this.sessionManager = sessionManagerValue;
-    }
-
-    /**
-     * Loads a deck by its ID.
-     *
-     * @param deckId the ID of the deck to load (must be positive)
-     * @return an Optional containing the deck if found, empty otherwise, never null
-     * @throws IllegalArgumentException if deckId is not positive
-     */
-    public Optional<Deck> loadDeck(final long deckId) {
-        return sessionService.loadDeck(deckId);
-    }
-
-    /**
-     * Gets cards that are not yet marked as known in a deck.
-     *
-     * @param deckId the ID of the deck to check (must be positive)
-     * @return a list of flashcards not yet known by the user, never null (maybe empty)
-     * @throws IllegalArgumentException if deckId is not positive
-     */
-    public List<Flashcard> getNotKnownCards(final long deckId) {
-        return sessionService.getNotKnownCards(deckId);
-    }
-
-    /**
-     * Determines the default number of cards for a practice session.
-     *
-     * @param deckId the ID of the deck to calculate count for (must be positive)
-     * @return the number of cards to include in the practice session (1 to configured default)
-     * @throws IllegalArgumentException if deckId is not positive
-     */
-    public int resolveDefaultCount(final long deckId) {
-        return sessionService.resolveDefaultCount(deckId);
-    }
-
-    /**
-     * Determines if practice sessions should use random card order.
-     *
-     * @return true if random ordering is enabled, false for sequential ordering
-     */
-    public boolean isRandom() {
-        return sessionService.isRandom();
-    }
-
-    /**
-     * Gets the default practice direction for sessions.
-     *
-     * @return the default practice direction, never null
-     */
-    public PracticeDirection defaultDirection() {
-        return sessionService.defaultDirection();
-    }
-
-    /**
-     * Starts a new practice session.
-     *
-     * @param deckId the ID of the deck to practice
-     * @param count the number of cards to include in the session
-     * @param random whether to randomize the card order
-     * @return a new Session instance ready for practice
-     */
-    public PracticeSession startSession(final long deckId, final int count, final boolean random) {
-        return sessionService.startSession(deckId, count, random);
-    }
-
-    /**
-     * Checks if a practice session is complete.
-     *
-     * @param session the session to check
-     * @return true if the session is complete, false otherwise
-     */
-    public boolean isComplete(final PracticeSession session) {
-        return sessionManager.isComplete(session);
-    }
-
-    /**
-     * Retrieves the current card in the practice session.
-     *
-     * @param session the session to get the current card from
-     * @return the current flashcard, or null if session is complete
-     */
-    public Flashcard currentCard(final PracticeSession session) {
-        return sessionManager.currentCard(session);
-    }
-
-    /**
-     * Starts a new question in the practice session.
-     *
-     * @param session the session to start the question for
-     */
-    public void startQuestion(final PracticeSession session) {
-        sessionManager.startQuestion(session);
-    }
-
-    /**
-     * Reveals the answer for the current card.
-     *
-     * @param session the session containing the current card
-     * @return updated session with answer revealed
-     */
-    public PracticeSession reveal(final PracticeSession session) {
-        return sessionManager.reveal(session);
-    }
-
-    /**
-     * Marks the current card as known and advances to the next card.
-     *
-     * @param session the session to update
-     * @return updated session with card marked as known
-     */
-    public PracticeSession markKnow(final PracticeSession session) {
-        return sessionManager.markKnow(session);
-    }
-
-    /**
-     * Marks the current card as difficult and advances to the next card.
-     *
-     * @param session the session to update
-     * @return updated session with card marked as hard
-     */
-    public PracticeSession markHard(final PracticeSession session) {
-        return sessionManager.markHard(session);
-    }
-
-    /**
-     * Calculates current progress information for a practice session.
-     *
-     * @param session the session to calculate progress for
-     * @return a Progress record with current session metrics
-     */
-    public PracticeSessionManager.Progress progress(final PracticeSession session) {
-        return sessionManager.progress(session);
-    }
-
-    /**
-     * Records and persists a completed practice session.
-     *
-     * @param session the completed session to record
-     */
-    public void recordAndPersist(final PracticeSession session) {
-        sessionManager.recordAndPersist(session, sessionService);
-    }
-}
Index: src/main/java/org/apolenkov/application/views/practice/controllers/PracticeCompletionFlow.java
===================================================================
diff --git a/src/main/java/org/apolenkov/application/views/practice/controllers/PracticeCompletionFlow.java b/src/main/java/org/apolenkov/application/views/practice/controllers/PracticeCompletionFlow.java
deleted file mode 100644
--- a/src/main/java/org/apolenkov/application/views/practice/controllers/PracticeCompletionFlow.java	(revision 132c2c29773f5f4949b3855c362e338d983d3cd4)
+++ /dev/null	(revision 132c2c29773f5f4949b3855c362e338d983d3cd4)
@@ -1,192 +0,0 @@
-package org.apolenkov.application.views.practice.controllers;
-
-import java.time.Instant;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.List;
-import java.util.Optional;
-import java.util.function.Consumer;
-import java.util.stream.Collectors;
-import org.apolenkov.application.domain.usecase.FlashcardUseCase;
-import org.apolenkov.application.model.Deck;
-import org.apolenkov.application.model.Flashcard;
-import org.apolenkov.application.views.practice.business.PracticePresenter;
-import org.apolenkov.application.views.practice.business.PracticeSession;
-import org.apolenkov.application.views.practice.components.PracticeActions;
-import org.apolenkov.application.views.practice.components.PracticeCard;
-import org.apolenkov.application.views.practice.constants.PracticeConstants;
-import org.apolenkov.application.views.shared.utils.NavigationHelper;
-
-/**
- * Controller for managing practice completion flow.
- * Handles session completion, statistics display, and repeat practice.
- */
-public final class PracticeCompletionFlow {
-
-    private final PracticePresenter presenter;
-    private final FlashcardUseCase flashcardUseCase;
-    private final PracticeCard practiceCard;
-    private final PracticeActions practiceActions;
-
-    /**
-     * Creates a new PracticeCompletionFlow controller.
-     *
-     * @param practicePresenter presenter for business logic
-     * @param flashcardService use case for flashcard operations
-     * @param card component for card display
-     * @param actions component for actions
-     */
-    public PracticeCompletionFlow(
-            final PracticePresenter practicePresenter,
-            final FlashcardUseCase flashcardService,
-            final PracticeCard card,
-            final PracticeActions actions) {
-        this.presenter = practicePresenter;
-        this.flashcardUseCase = flashcardService;
-        this.practiceCard = card;
-        this.practiceActions = actions;
-    }
-
-    /**
-     * Handles practice session completion.
-     *
-     * @param session the completed session
-     * @param deck the current deck
-     * @param onRepeatCallback callback to handle repeat with new session
-     */
-    public void showPracticeComplete(
-            final PracticeSession session, final Deck deck, final Consumer<PracticeSession> onRepeatCallback) {
-        presenter.recordAndPersist(session);
-        createCompletionDisplay(session, deck);
-        createCompletionButtons(deck, onRepeatCallback);
-    }
-
-    /**
-     * Creates the completion display with session statistics.
-     *
-     * @param session the completed session
-     * @param deck the current deck
-     */
-    public void createCompletionDisplay(final PracticeSession session, final Deck deck) {
-        SessionMetrics metrics = calculateSessionMetrics(session);
-
-        practiceCard.displayCompletion(
-                deck.getTitle(),
-                session.getCorrectCount(),
-                metrics.totalCards(),
-                session.getHardCount(),
-                metrics.sessionMinutes(),
-                metrics.avgSeconds());
-    }
-
-    /**
-     * Creates completion action buttons.
-     *
-     * @param deck the current deck
-     * @param onRepeatCallback callback to handle repeat with new session
-     */
-    public void createCompletionButtons(final Deck deck, final Consumer<PracticeSession> onRepeatCallback) {
-        // Check if there are failed cards to practice
-        List<Flashcard> failedCards = getFailedCards(deck);
-
-        Runnable repeatHandler = failedCards.isEmpty()
-                ? null
-                : () -> handleRepeatPractice(deck).ifPresent(newSession -> {
-                    if (onRepeatCallback != null) {
-                        onRepeatCallback.accept(newSession);
-                    }
-                });
-
-        practiceActions.showCompletionButtons(
-                repeatHandler, () -> NavigationHelper.navigateToDeck(deck.getId()), NavigationHelper::navigateToDecks);
-    }
-
-    /**
-     * Handles repeat practice for failed cards.
-     *
-     * @param deck the current deck
-     * @return Optional containing new session for failed cards, empty if no failed cards
-     */
-    public Optional<PracticeSession> handleRepeatPractice(final Deck deck) {
-        List<Flashcard> failed = getFailedCards(deck);
-        practiceActions.resetToPracticeButtons();
-
-        if (failed.isEmpty()) {
-            return Optional.empty(); // No failed cards to practice
-        }
-
-        return Optional.of(startFailedCardsPractice(failed, deck));
-    }
-
-    /**
-     * Gets list of failed cards that are still not known.
-     *
-     * @param deck the current deck
-     * @return list of failed cards
-     */
-    public List<Flashcard> getFailedCards(final Deck deck) {
-        return flashcardUseCase.getFlashcardsByDeckId(deck.getId()).stream()
-                .filter(fc -> isCardFailed(fc, deck))
-                .toList();
-    }
-
-    /**
-     * Starts practice session with failed cards.
-     *
-     * @param failedCards list of failed cards to practice
-     * @param deck        the current deck
-     * @return new practice session with failed cards
-     */
-    public PracticeSession startFailedCardsPractice(final List<Flashcard> failedCards, final Deck deck) {
-        List<Flashcard> cards = new ArrayList<>(failedCards);
-        Collections.shuffle(cards);
-        return PracticeSession.create(deck.getId(), cards, Instant.now());
-    }
-
-    /**
-     * Calculates session metrics including duration and timing statistics.
-     *
-     * @param session the current session
-     * @return session metrics with calculated values
-     */
-    private SessionMetrics calculateSessionMetrics(final PracticeSession session) {
-        int totalCards = (session.getCards() != null) ? session.getCards().size() : session.getTotalViewed();
-
-        long sessionDurationSec =
-                Instant.now().getEpochSecond() - session.getSessionStart().getEpochSecond();
-        long sessionMinutes = Math.clamp(
-                sessionDurationSec / 60, PracticeConstants.MIN_SESSION_MINUTES, PracticeConstants.MAX_SESSION_MINUTES);
-
-        double denom = Math.clamp(
-                session.getTotalViewed(), PracticeConstants.MIN_TOTAL_VIEWED, PracticeConstants.MAX_TOTAL_VIEWED);
-        long avgSeconds = Math.clamp(
-                Math.round((session.getTotalAnswerDelayMs() / denom) / 1000.0),
-                PracticeConstants.MIN_AVERAGE_SECONDS,
-                Long.MAX_VALUE);
-
-        return new SessionMetrics(totalCards, sessionMinutes, avgSeconds);
-    }
-
-    /**
-     * Record for session metrics calculations.
-     *
-     * @param totalCards total number of cards
-     * @param sessionMinutes session duration in minutes
-     * @param avgSeconds average answer time in seconds
-     */
-    private record SessionMetrics(int totalCards, long sessionMinutes, long avgSeconds) {}
-
-    /**
-     * Checks if a card is not yet known by the user.
-     *
-     * @param flashcard the card to check
-     * @param deck the current deck
-     * @return true if the card is not known
-     */
-    private boolean isCardFailed(final Flashcard flashcard, final Deck deck) {
-        return presenter.getNotKnownCards(deck.getId()).stream()
-                .map(Flashcard::getId)
-                .collect(Collectors.toSet())
-                .contains(flashcard.getId());
-    }
-}
Index: src/main/java/org/apolenkov/application/views/practice/controllers/PracticeSessionFlow.java
===================================================================
diff --git a/src/main/java/org/apolenkov/application/views/practice/controllers/PracticeSessionFlow.java b/src/main/java/org/apolenkov/application/views/practice/controllers/PracticeSessionFlow.java
deleted file mode 100644
--- a/src/main/java/org/apolenkov/application/views/practice/controllers/PracticeSessionFlow.java	(revision 132c2c29773f5f4949b3855c362e338d983d3cd4)
+++ /dev/null	(revision 132c2c29773f5f4949b3855c362e338d983d3cd4)
@@ -1,194 +0,0 @@
-package org.apolenkov.application.views.practice.controllers;
-
-import java.util.List;
-import java.util.Optional;
-import org.apolenkov.application.model.Deck;
-import org.apolenkov.application.model.Flashcard;
-import org.apolenkov.application.model.PracticeDirection;
-import org.apolenkov.application.views.practice.business.PracticePresenter;
-import org.apolenkov.application.views.practice.business.PracticeSession;
-import org.apolenkov.application.views.practice.components.PracticeActions;
-import org.apolenkov.application.views.practice.components.PracticeCard;
-import org.apolenkov.application.views.practice.components.PracticeProgress;
-import org.apolenkov.application.views.practice.constants.PracticeConstants;
-
-/**
- * Controller for managing practice session flow.
- * Handles session start, card progression, and user interactions.
- */
-public final class PracticeSessionFlow {
-
-    private final PracticePresenter presenter;
-    private final PracticeCard practiceCard;
-    private final PracticeProgress practiceProgress;
-    private final PracticeActions practiceActions;
-
-    /**
-     * Creates a new PracticeSessionFlow controller.
-     *
-     * @param practicePresenter presenter for business logic
-     * @param card component for card display
-     * @param progress component for progress display
-     * @param actions component for actions
-     */
-    public PracticeSessionFlow(
-            final PracticePresenter practicePresenter,
-            final PracticeCard card,
-            final PracticeProgress progress,
-            final PracticeActions actions) {
-        this.presenter = practicePresenter;
-        this.practiceCard = card;
-        this.practiceProgress = progress;
-        this.practiceActions = actions;
-    }
-
-    /**
-     * Starts default practice session with configured settings.
-     *
-     * @param deck the current deck
-     * @param sessionDirection the practice direction
-     * @return Optional containing the created session, empty if no cards available
-     */
-    public Optional<PracticeSession> startDefaultPractice(final Deck deck, final PracticeDirection sessionDirection) {
-        List<Flashcard> notKnownCards = presenter.getNotKnownCards(deck.getId());
-        if (notKnownCards.isEmpty()) {
-            return Optional.empty();
-        }
-
-        int defaultCount = presenter.resolveDefaultCount(deck.getId());
-        boolean random = presenter.isRandom();
-        return startPractice(deck, defaultCount, random, sessionDirection);
-    }
-
-    /**
-     * Starts practice session with specified parameters.
-     *
-     * @param deck the current deck
-     * @param count number of cards to practice
-     * @param random whether to randomize card order
-     * @param sessionDirection the practice direction
-     * @return Optional containing the created session, empty if no cards available
-     */
-    public Optional<PracticeSession> startPractice(
-            final Deck deck, final int count, final boolean random, final PracticeDirection sessionDirection) {
-        List<Flashcard> filtered = presenter.getNotKnownCards(deck.getId());
-        if (filtered.isEmpty()) {
-            return Optional.empty();
-        }
-
-        PracticeSession session = presenter.startSession(deck.getId(), count, random);
-        showCurrentCard(session, sessionDirection);
-        return Optional.of(session);
-    }
-
-    /**
-     * Shows the current card in question state.
-     *
-     * @param session the current session
-     * @param sessionDirection the practice direction
-     */
-    public void showCurrentCard(final PracticeSession session, final PracticeDirection sessionDirection) {
-        if (session == null || presenter.isComplete(session)) {
-            return;
-        }
-
-        updateProgress(session);
-        Flashcard currentCard = presenter.currentCard(session);
-        presenter.startQuestion(session);
-
-        practiceCard.displayQuestionCard(currentCard, sessionDirection);
-        practiceActions.showQuestionState();
-    }
-
-    /**
-     * Shows the answer for the current card.
-     *
-     * @param session the current session
-     * @param sessionDirection the practice direction
-     * @return updated session
-     */
-    public PracticeSession showAnswer(final PracticeSession session, final PracticeDirection sessionDirection) {
-        if (session == null || presenter.isComplete(session)) {
-            return session;
-        }
-
-        Flashcard currentCard = presenter.currentCard(session);
-        PracticeSession updatedSession = presenter.reveal(session);
-
-        practiceCard.displayAnswerCard(currentCard, sessionDirection);
-        practiceActions.showAnswerState();
-        return updatedSession;
-    }
-
-    /**
-     * Marks the current card with the specified label.
-     *
-     * @param session the current session
-     * @param label the label to apply (know or hard)
-     * @param sessionDirection the practice direction
-     * @return updated session
-     */
-    public PracticeSession markLabeled(
-            final PracticeSession session, final String label, final PracticeDirection sessionDirection) {
-        if (isInvalidSession(session)) {
-            return session;
-        }
-
-        PracticeSession updatedSession = processCardLabel(session, label);
-        updateProgress(updatedSession);
-        practiceActions.hideActionButtons();
-        nextCard(updatedSession, sessionDirection);
-        return updatedSession;
-    }
-
-    /**
-     * Moves to the next card or completes the session.
-     *
-     * @param session the current session
-     * @param sessionDirection the practice direction
-     */
-    public void nextCard(final PracticeSession session, final PracticeDirection sessionDirection) {
-        if (presenter.isComplete(session)) {
-            return; // Completion handled by caller
-        }
-        showCurrentCard(session, sessionDirection);
-    }
-
-    /**
-     * Checks if the session is invalid for marking.
-     *
-     * @param session the current session
-     * @return true if invalid for marking
-     */
-    private boolean isInvalidSession(final PracticeSession session) {
-        return session == null || !session.isShowingAnswer();
-    }
-
-    /**
-     * Processes the card label through the presenter.
-     *
-     * @param session the current session
-     * @param label the label to process
-     * @return updated session
-     */
-    private PracticeSession processCardLabel(final PracticeSession session, final String label) {
-        if (PracticeConstants.KNOW_LABEL.equals(label)) {
-            return presenter.markKnow(session);
-        } else {
-            return presenter.markHard(session);
-        }
-    }
-
-    /**
-     * Updates the progress display.
-     *
-     * @param session the current session
-     */
-    private void updateProgress(final PracticeSession session) {
-        if (session == null || session.getCards() == null || session.getCards().isEmpty()) {
-            return;
-        }
-        var progress = presenter.progress(session);
-        practiceProgress.updateProgress(progress);
-    }
-}
Index: src/test/java/org/apolenkov/application/views/presenter/practice/PracticePresenterTest.java
===================================================================
diff --git a/src/test/java/org/apolenkov/application/views/presenter/practice/PracticePresenterTest.java b/src/test/java/org/apolenkov/application/views/presenter/practice/PracticePresenterTest.java
deleted file mode 100644
--- a/src/test/java/org/apolenkov/application/views/presenter/practice/PracticePresenterTest.java	(revision 132c2c29773f5f4949b3855c362e338d983d3cd4)
+++ /dev/null	(revision 132c2c29773f5f4949b3855c362e338d983d3cd4)
@@ -1,97 +0,0 @@
-package org.apolenkov.application.views.presenter.practice;
-
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.mockito.Mockito.when;
-
-import java.util.List;
-import java.util.Optional;
-import org.apolenkov.application.model.Deck;
-import org.apolenkov.application.model.Flashcard;
-import org.apolenkov.application.views.practice.business.PracticePresenter;
-import org.apolenkov.application.views.practice.business.PracticeSessionManager;
-import org.apolenkov.application.views.practice.business.PracticeSessionService;
-import org.junit.jupiter.api.BeforeEach;
-import org.junit.jupiter.api.DisplayName;
-import org.junit.jupiter.api.Test;
-import org.junit.jupiter.api.extension.ExtendWith;
-import org.mockito.Mock;
-import org.mockito.junit.jupiter.MockitoExtension;
-
-@ExtendWith(MockitoExtension.class)
-@DisplayName("PracticePresenter Core Tests")
-class PracticePresenterTest {
-
-    @Mock
-    private PracticeSessionService practiceSessionService;
-
-    @Mock
-    private PracticeSessionManager practiceSessionManager;
-
-    private PracticePresenter practicePresenter;
-
-    private Deck testDeck;
-    private List<Flashcard> testFlashcards;
-
-    @BeforeEach
-    @SuppressWarnings("unused")
-    void setUp() {
-        practicePresenter = new PracticePresenter(practiceSessionService, practiceSessionManager);
-
-        testDeck = new Deck(1L, 1L, "Test Deck", "Test Description");
-
-        testFlashcards = List.of(
-                new Flashcard(1L, 1L, "Front 1", "Back 1", "Example 1"),
-                new Flashcard(2L, 1L, "Front 2", "Back 2", "Example 2"));
-    }
-
-    @Test
-    @DisplayName("Should load deck by ID")
-    void shouldLoadDeckById() {
-        when(practiceSessionService.loadDeck(1L)).thenReturn(Optional.of(testDeck));
-
-        Optional<Deck> result = practicePresenter.loadDeck(1L);
-
-        assertThat(result).contains(testDeck);
-    }
-
-    @Test
-    @DisplayName("Should return empty for non-existent deck")
-    void shouldReturnEmptyForNonExistentDeck() {
-        when(practiceSessionService.loadDeck(999L)).thenReturn(Optional.empty());
-
-        Optional<Deck> result = practicePresenter.loadDeck(999L);
-
-        assertThat(result).isEmpty();
-    }
-
-    @Test
-    @DisplayName("Should get not known cards")
-    void shouldGetNotKnownCards() {
-        when(practiceSessionService.getNotKnownCards(1L)).thenReturn(testFlashcards);
-
-        List<Flashcard> result = practicePresenter.getNotKnownCards(1L);
-
-        assertThat(result).hasSize(2).isEqualTo(testFlashcards);
-    }
-
-    @Test
-    @DisplayName("Should filter out known cards")
-    void shouldFilterOutKnownCards() {
-        List<Flashcard> filteredCards = List.of(testFlashcards.get(1));
-        when(practiceSessionService.getNotKnownCards(1L)).thenReturn(filteredCards);
-
-        List<Flashcard> result = practicePresenter.getNotKnownCards(1L);
-
-        assertThat(result).hasSize(1).contains(testFlashcards.get(1));
-    }
-
-    @Test
-    @DisplayName("Should handle empty deck")
-    void shouldHandleEmptyDeck() {
-        when(practiceSessionService.getNotKnownCards(1L)).thenReturn(List.of());
-
-        List<Flashcard> result = practicePresenter.getNotKnownCards(1L);
-
-        assertThat(result).isEmpty();
-    }
-}
Index: src/main/java/org/apolenkov/application/domain/port/UserRepository.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/org/apolenkov/application/domain/port/UserRepository.java b/src/main/java/org/apolenkov/application/domain/port/UserRepository.java
--- a/src/main/java/org/apolenkov/application/domain/port/UserRepository.java	(revision 132c2c29773f5f4949b3855c362e338d983d3cd4)
+++ b/src/main/java/org/apolenkov/application/domain/port/UserRepository.java	(date 1760197282189)
@@ -1,5 +1,6 @@
 package org.apolenkov.application.domain.port;

+import java.util.Collection;
 import java.util.List;
 import java.util.Optional;
 import org.apolenkov.application.model.User;
@@ -43,6 +44,15 @@
      */
     User save(User user);

+    /**
+     * Saves multiple users in batch operation.
+     * More efficient than calling save() multiple times.
+     *
+     * @param users collection of users to save
+     * @return list of saved users with generated IDs
+     */
+    List<User> saveAll(Collection<User> users);
+
     /**
      * Deletes user by identifier.
      *
Index: src/main/java/org/apolenkov/application/views/core/navigation/TopMenuAuthService.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/org/apolenkov/application/views/core/navigation/TopMenuAuthService.java b/src/main/java/org/apolenkov/application/views/core/navigation/TopMenuAuthService.java
--- a/src/main/java/org/apolenkov/application/views/core/navigation/TopMenuAuthService.java	(revision 132c2c29773f5f4949b3855c362e338d983d3cd4)
+++ b/src/main/java/org/apolenkov/application/views/core/navigation/TopMenuAuthService.java	(date 1760129814196)
@@ -24,6 +24,7 @@
 public class TopMenuAuthService {

     private static final Logger LOGGER = LoggerFactory.getLogger(TopMenuAuthService.class);
+    private static final Logger AUDIT_LOGGER = LoggerFactory.getLogger("org.apolenkov.application.audit");

     private final UserUseCase userUseCase;

@@ -113,6 +114,11 @@
      * Performs the actual logout operation.
      */
     public void performLogout() {
+        Authentication auth = getCurrentAuthentication();
+        String username = auth != null ? auth.getName() : "unknown";
+
+        LOGGER.debug("Processing logout request for user: {}", username);
+
         try {
             VaadinServletRequest request = VaadinServletRequest.getCurrent();
             if (request == null) {
@@ -122,10 +128,15 @@
             }

             new SecurityContextLogoutHandler().logout(request.getHttpServletRequest(), null, null);
+
+            AUDIT_LOGGER.info("User logged out successfully: {}", username);
+            LOGGER.info("Logout successful for user: {}", username);
         } catch (AuthenticationException e) {
+            AUDIT_LOGGER.warn("Logout failed for user: {} - Authentication error: {}", username, e.getMessage());
             LOGGER.warn("Authentication error during logout: {}", e.getMessage());
             NavigationHelper.navigateToError(RouteConstants.HOME_ROUTE);
         } catch (Exception e) {
+            AUDIT_LOGGER.error("Logout failed for user: {} - Unexpected error", username, e);
             LOGGER.error("Unexpected error during logout", e);
             NavigationHelper.navigateToError(RouteConstants.HOME_ROUTE);
         }
Index: src/main/java/org/apolenkov/application/domain/port/DeckRepository.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/org/apolenkov/application/domain/port/DeckRepository.java b/src/main/java/org/apolenkov/application/domain/port/DeckRepository.java
--- a/src/main/java/org/apolenkov/application/domain/port/DeckRepository.java	(revision 132c2c29773f5f4949b3855c362e338d983d3cd4)
+++ b/src/main/java/org/apolenkov/application/domain/port/DeckRepository.java	(date 1760197281935)
@@ -1,5 +1,6 @@
 package org.apolenkov.application.domain.port;

+import java.util.Collection;
 import java.util.List;
 import java.util.Optional;
 import org.apolenkov.application.model.Deck;
@@ -43,6 +44,15 @@
      */
     Deck save(Deck deck);

+    /**
+     * Saves multiple decks in batch operation.
+     * More efficient than calling save() multiple times.
+     *
+     * @param decks collection of decks to save
+     * @return list of saved decks with generated IDs
+     */
+    List<Deck> saveAll(Collection<Deck> decks);
+
     /**
      * Deletes deck from repository by ID.
      *
Index: src/main/java/org/apolenkov/application/domain/usecase/FlashcardUseCase.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/org/apolenkov/application/domain/usecase/FlashcardUseCase.java b/src/main/java/org/apolenkov/application/domain/usecase/FlashcardUseCase.java
--- a/src/main/java/org/apolenkov/application/domain/usecase/FlashcardUseCase.java	(revision 132c2c29773f5f4949b3855c362e338d983d3cd4)
+++ b/src/main/java/org/apolenkov/application/domain/usecase/FlashcardUseCase.java	(date 1760194949873)
@@ -1,6 +1,8 @@
 package org.apolenkov.application.domain.usecase;

+import java.util.Collection;
 import java.util.List;
+import java.util.Map;
 import org.apolenkov.application.model.Flashcard;

 /**
@@ -36,4 +38,12 @@
      * @return total number of flashcards in specified deck
      */
     long countByDeckId(long deckId);
+
+    /**
+     * Returns flashcard counts for multiple decks in single operation.
+     *
+     * @param deckIds collection of deck IDs to count flashcards for
+     * @return map of deck ID to flashcard count (decks with zero flashcards may be absent)
+     */
+    Map<Long, Long> countByDeckIds(Collection<Long> deckIds);
 }
Index: src/main/java/org/apolenkov/application/domain/port/NewsRepository.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/org/apolenkov/application/domain/port/NewsRepository.java b/src/main/java/org/apolenkov/application/domain/port/NewsRepository.java
--- a/src/main/java/org/apolenkov/application/domain/port/NewsRepository.java	(revision 132c2c29773f5f4949b3855c362e338d983d3cd4)
+++ b/src/main/java/org/apolenkov/application/domain/port/NewsRepository.java	(date 1760197282081)
@@ -1,5 +1,6 @@
 package org.apolenkov.application.domain.port;

+import java.util.Collection;
 import java.util.List;
 import java.util.Optional;
 import org.apolenkov.application.model.News;
@@ -34,6 +35,14 @@
      */
     void save(News item);

+    /**
+     * Saves multiple news items in batch operation.
+     * More efficient than calling save() multiple times.
+     *
+     * @param items collection of news items to save
+     */
+    void saveAll(Collection<News> items);
+
     /**
      * Deletes news item by identifier.
      *
Index: src/main/java/org/apolenkov/application/views/practice/business/PracticeSessionService.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/org/apolenkov/application/views/practice/business/PracticeSessionService.java b/src/main/java/org/apolenkov/application/views/practice/business/PracticeSessionService.java
--- a/src/main/java/org/apolenkov/application/views/practice/business/PracticeSessionService.java	(revision 132c2c29773f5f4949b3855c362e338d983d3cd4)
+++ b/src/main/java/org/apolenkov/application/views/practice/business/PracticeSessionService.java	(date 1760127466657)
@@ -177,8 +177,15 @@
             final Duration sessionDuration,
             final long totalAnswerDelayMs,
             final List<Long> knownCardIdsDelta) {
-        SessionStatsDto sessionData = SessionStatsDto.of(
-                deckId, totalViewed, correct, hard, sessionDuration.toMillis(), totalAnswerDelayMs, knownCardIdsDelta);
+        SessionStatsDto sessionData = SessionStatsDto.builder()
+                .deckId(deckId)
+                .viewed(totalViewed)
+                .correct(correct)
+                .hard(hard)
+                .sessionDurationMs(sessionDuration.toMillis())
+                .totalAnswerDelayMs(totalAnswerDelayMs)
+                .knownCardIdsDelta(knownCardIdsDelta)
+                .build();
         statsService.recordSession(sessionData);
     }

@@ -195,4 +202,63 @@
         List<Flashcard> cards = prepareSession(deckId, count, random);
         return PracticeSession.create(deckId, cards, Instant.now());
     }
+
+    /**
+     * Calculates session completion metrics.
+     *
+     * @param session the completed session
+     * @return completion metrics record
+     */
+    public SessionCompletionMetrics calculateCompletionMetrics(final PracticeSession session) {
+        int totalCards = (session.getCards() != null) ? session.getCards().size() : session.getTotalViewed();
+        long sessionDurationSec =
+                Instant.now().getEpochSecond() - session.getSessionStart().getEpochSecond();
+        long sessionMinutes = Math.clamp(sessionDurationSec / 60, 1L, Integer.MAX_VALUE);
+
+        double denom = Math.clamp(session.getTotalViewed(), 1.0, Double.MAX_VALUE);
+        long avgSeconds =
+                Math.clamp(Math.round((session.getTotalAnswerDelayMs() / denom) / 1000.0), 1L, Long.MAX_VALUE);
+
+        return new SessionCompletionMetrics(totalCards, sessionMinutes, avgSeconds);
+    }
+
+    /**
+     * Gets list of failed cards that are still not known.
+     *
+     * @param deckId the deck ID
+     * @param failedCardIds list of failed card IDs from session
+     * @return list of failed flashcards
+     */
+    public List<Flashcard> getFailedCards(final long deckId, final List<Long> failedCardIds) {
+        if (failedCardIds == null || failedCardIds.isEmpty()) {
+            return List.of();
+        }
+
+        List<Flashcard> notKnownCards = getNotKnownCards(deckId);
+        return notKnownCards.stream()
+                .filter(fc -> failedCardIds.contains(fc.getId()))
+                .toList();
+    }
+
+    /**
+     * Starts a new practice session with failed cards.
+     *
+     * @param deckId the deck ID
+     * @param failedCards list of failed cards to practice
+     * @return new practice session
+     */
+    public PracticeSession startRepeatSession(final long deckId, final List<Flashcard> failedCards) {
+        List<Flashcard> cards = new ArrayList<>(failedCards);
+        Collections.shuffle(cards);
+        return PracticeSession.create(deckId, cards, Instant.now());
+    }
+
+    /**
+     * Session completion metrics record.
+     *
+     * @param totalCards total number of cards in session
+     * @param sessionMinutes session duration in minutes
+     * @param avgSeconds average answer time in seconds
+     */
+    public record SessionCompletionMetrics(int totalCards, long sessionMinutes, long avgSeconds) {}
 }
Index: src/main/java/org/apolenkov/application/domain/dto/SessionStatsDto.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/org/apolenkov/application/domain/dto/SessionStatsDto.java b/src/main/java/org/apolenkov/application/domain/dto/SessionStatsDto.java
--- a/src/main/java/org/apolenkov/application/domain/dto/SessionStatsDto.java	(revision 132c2c29773f5f4949b3855c362e338d983d3cd4)
+++ b/src/main/java/org/apolenkov/application/domain/dto/SessionStatsDto.java	(date 1760127004111)
@@ -50,26 +50,117 @@
     }

     /**
-     * Creates SessionStatsDto with required statistics.
+     * Creates a new builder for SessionStatsDto.
      *
-     * @param deckId deck identifier
-     * @param viewed number of cards viewed
-     * @param correct number of correct answers
-     * @param hard number of cards marked as hard
-     * @param sessionDurationMs session duration in milliseconds
-     * @param totalAnswerDelayMs total answer delay in milliseconds
-     * @param knownCardIdsDelta collection of card IDs whose knowledge status changed
-     * @return new SessionStatsDto instance
-     */
-    public static SessionStatsDto of(
-            final long deckId,
-            final int viewed,
-            final int correct,
-            final int hard,
-            final long sessionDurationMs,
-            final long totalAnswerDelayMs,
-            final Collection<Long> knownCardIdsDelta) {
-        return new SessionStatsDto(
-                deckId, viewed, correct, hard, sessionDurationMs, totalAnswerDelayMs, knownCardIdsDelta);
+     * @return new Builder instance
+     */
+    public static Builder builder() {
+        return new Builder();
+    }
+
+    /**
+     * Builder for SessionStatsDto with fluent API.
+     * Provides readable, self-documenting construction for 7 parameters.
+     */
+    public static final class Builder {
+        private long deckId;
+        private int viewed;
+        private int correct;
+        private int hard;
+        private long sessionDurationMs;
+        private long totalAnswerDelayMs;
+        private Collection<Long> knownCardIdsDelta;
+
+        private Builder() {
+            // Private constructor - use builder() factory method
+        }
+
+        /**
+         * Sets the deck ID.
+         *
+         * @param deckIdValue deck identifier
+         * @return this builder instance
+         */
+        public Builder deckId(final long deckIdValue) {
+            this.deckId = deckIdValue;
+            return this;
+        }
+
+        /**
+         * Sets the viewed count.
+         *
+         * @param viewedValue number of cards viewed
+         * @return this builder instance
+         */
+        public Builder viewed(final int viewedValue) {
+            this.viewed = viewedValue;
+            return this;
+        }
+
+        /**
+         * Sets the correct count.
+         *
+         * @param correctValue number of correct answers
+         * @return this builder instance
+         */
+        public Builder correct(final int correctValue) {
+            this.correct = correctValue;
+            return this;
+        }
+
+        /**
+         * Sets the hard count.
+         *
+         * @param hardValue number of cards marked as hard
+         * @return this builder instance
+         */
+        public Builder hard(final int hardValue) {
+            this.hard = hardValue;
+            return this;
+        }
+
+        /**
+         * Sets the session duration.
+         *
+         * @param sessionDurationMsValue session duration in milliseconds
+         * @return this builder instance
+         */
+        public Builder sessionDurationMs(final long sessionDurationMsValue) {
+            this.sessionDurationMs = sessionDurationMsValue;
+            return this;
+        }
+
+        /**
+         * Sets the total answer delay.
+         *
+         * @param totalAnswerDelayMsValue total answer delay in milliseconds
+         * @return this builder instance
+         */
+        public Builder totalAnswerDelayMs(final long totalAnswerDelayMsValue) {
+            this.totalAnswerDelayMs = totalAnswerDelayMsValue;
+            return this;
+        }
+
+        /**
+         * Sets the known card IDs delta.
+         *
+         * @param knownCardIdsDeltaValue collection of card IDs whose knowledge status changed
+         * @return this builder instance
+         */
+        public Builder knownCardIdsDelta(final Collection<Long> knownCardIdsDeltaValue) {
+            this.knownCardIdsDelta = knownCardIdsDeltaValue;
+            return this;
+        }
+
+        /**
+         * Builds SessionStatsDto with validation.
+         *
+         * @return new SessionStatsDto instance
+         * @throws IllegalArgumentException if any parameter violates constraints
+         */
+        public SessionStatsDto build() {
+            return new SessionStatsDto(
+                    deckId, viewed, correct, hard, sessionDurationMs, totalAnswerDelayMs, knownCardIdsDelta);
+        }
     }
 }
Index: src/main/resources/banner.txt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/resources/banner.txt b/src/main/resources/banner.txt
--- a/src/main/resources/banner.txt	(revision 132c2c29773f5f4949b3855c362e338d983d3cd4)
+++ b/src/main/resources/banner.txt	(date 1760122135415)
@@ -4,3 +4,4 @@
  |  _| | | (_| \__ \ | | | (_| (_| | | | (_| \__ \
  |_|   |_|\__,_|___/_| |_|\___\__,_|_|  \__,_|___/

+ :: Spring Boot ${spring-boot.version} :: Java ${java.version} :: Vaadin 24 ::
Index: src/main/java/org/apolenkov/application/views/deck/components/dialogs/DeckFlashcardDeleteDialog.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/org/apolenkov/application/views/deck/components/dialogs/DeckFlashcardDeleteDialog.java b/src/main/java/org/apolenkov/application/views/deck/components/dialogs/DeckFlashcardDeleteDialog.java
--- a/src/main/java/org/apolenkov/application/views/deck/components/dialogs/DeckFlashcardDeleteDialog.java	(revision 132c2c29773f5f4949b3855c362e338d983d3cd4)
+++ b/src/main/java/org/apolenkov/application/views/deck/components/dialogs/DeckFlashcardDeleteDialog.java	(date 1760129814237)
@@ -30,7 +30,6 @@
 public final class DeckFlashcardDeleteDialog extends Dialog {

     private static final Logger LOGGER = LoggerFactory.getLogger(DeckFlashcardDeleteDialog.class);
-    private static final Logger AUDIT_LOGGER = LoggerFactory.getLogger("org.apolenkov.application.audit");

     // Dependencies
     private final transient FlashcardUseCase flashcardUseCase;
@@ -143,17 +142,10 @@
         try {
             flashcardUseCase.deleteFlashcard(flashcard.getId());

-            // Audit log for flashcard deletion
-            AUDIT_LOGGER.info(
-                    "User deleted flashcard '{}' (ID: {}) from deck (ID: {})",
-                    flashcard.getFrontText(),
-                    flashcard.getId(),
-                    flashcard.getDeckId());
-
             notifyFlashcardDeleted();
             close();
             NotificationHelper.showSuccessBottom(getTranslation(DeckConstants.DECK_CARD_DELETED));
-            LOGGER.info("Flashcard {} deleted successfully", flashcard.getId());
+            LOGGER.debug("Flashcard {} deleted successfully", flashcard.getId());
         } catch (Exception ex) {
             handleDeletionError(ex);
         }
Index: src/main/java/org/apolenkov/application/views/deck/components/dialogs/DeckComplexDeleteDialog.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/org/apolenkov/application/views/deck/components/dialogs/DeckComplexDeleteDialog.java b/src/main/java/org/apolenkov/application/views/deck/components/dialogs/DeckComplexDeleteDialog.java
--- a/src/main/java/org/apolenkov/application/views/deck/components/dialogs/DeckComplexDeleteDialog.java	(revision 132c2c29773f5f4949b3855c362e338d983d3cd4)
+++ b/src/main/java/org/apolenkov/application/views/deck/components/dialogs/DeckComplexDeleteDialog.java	(date 1760129814237)
@@ -39,7 +39,6 @@
 public final class DeckComplexDeleteDialog extends Dialog {

     private static final Logger LOGGER = LoggerFactory.getLogger(DeckComplexDeleteDialog.class);
-    private static final Logger AUDIT_LOGGER = LoggerFactory.getLogger("org.apolenkov.application.audit");

     // Dependencies
     private final transient DeckUseCase deckUseCase;
@@ -276,7 +275,6 @@
     private void handleDeletion() {
         try {
             performDeletion();
-            logDeletionSuccess();
             handleSuccessfulDeletion();
         } catch (IllegalArgumentException ex) {
             handleValidationError();
@@ -290,18 +288,7 @@
      */
     private void performDeletion() {
         deckUseCase.deleteDeck(currentDeck.getId());
-    }
-
-    /**
-     * Logs successful deletion with audit information.
-     */
-    private void logDeletionSuccess() {
-        long cardCount = flashcardUseCase.countByDeckId(currentDeck.getId());
-        AUDIT_LOGGER.info(
-                "User deleted deck '{}' (ID: {}) with {} cards - Complex deletion (confirmed)",
-                currentDeck.getTitle(),
-                currentDeck.getId(),
-                cardCount);
+        LOGGER.debug("Deck deleted successfully: id={}, title='{}'", currentDeck.getId(), currentDeck.getTitle());
     }

     /**
Index: src/main/java/org/apolenkov/application/views/deck/components/dialogs/DeckFlashcardDialog.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/org/apolenkov/application/views/deck/components/dialogs/DeckFlashcardDialog.java b/src/main/java/org/apolenkov/application/views/deck/components/dialogs/DeckFlashcardDialog.java
--- a/src/main/java/org/apolenkov/application/views/deck/components/dialogs/DeckFlashcardDialog.java	(revision 132c2c29773f5f4949b3855c362e338d983d3cd4)
+++ b/src/main/java/org/apolenkov/application/views/deck/components/dialogs/DeckFlashcardDialog.java	(date 1760129814237)
@@ -37,7 +37,6 @@
 public final class DeckFlashcardDialog extends Dialog {

     private static final Logger LOGGER = LoggerFactory.getLogger(DeckFlashcardDialog.class);
-    private static final Logger AUDIT_LOGGER = LoggerFactory.getLogger("org.apolenkov.application.audit");

     // Dependencies
     private final transient FlashcardUseCase flashcardUseCase;
@@ -116,6 +115,7 @@

     /**
      * Opens the dialog with the specified flashcard data.
+     * Creates fresh form components each time to avoid component reuse issues.
      *
      * @param flashcard the flashcard to edit, or null for creating new
      */
@@ -123,10 +123,8 @@
         // Store the editing flashcard
         this.editingFlashcard = flashcard;

-        // Ensure form is created before using it
-        if (formLayout == null) {
-            createForm();
-        }
+        // Create fresh form components each time
+        createForm();

         // Set dialog title
         H3 title = new H3(
@@ -141,7 +139,7 @@
         VerticalLayout dialogLayout = new VerticalLayout();
         dialogLayout.add(title, formLayout, createButtonsLayout());

-        removeAll();
+        // No removeAll() needed - dialog is fresh from constructor
         add(dialogLayout);
         open();
     }
@@ -192,7 +190,6 @@
             Flashcard flashcard = prepareFlashcard(frontText, backText);
             flashcardUseCase.saveFlashcard(flashcard);

-            logFlashcardAction(flashcard);
             notifyParentAndClose(flashcard);

         } catch (Exception ex) {
@@ -223,24 +220,6 @@
         return flashcard;
     }

-    /**
-     * Logs flashcard action (create or edit).
-     *
-     * @param flashcard the flashcard being saved
-     */
-    private void logFlashcardAction(final Flashcard flashcard) {
-        boolean isEditing = editingFlashcard != null;
-        String action = isEditing ? "edited" : "created";
-
-        AUDIT_LOGGER.info(
-                "User {} flashcard '{}' (ID: {}) in deck '{}' (ID: {})",
-                action,
-                flashcard.getFrontText(),
-                flashcard.getId(),
-                currentDeck.getTitle(),
-                currentDeck.getId());
-    }
-
     /**
      * Notifies parent component and closes dialog.
      *
Index: src/main/java/org/apolenkov/application/domain/port/FlashcardRepository.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/org/apolenkov/application/domain/port/FlashcardRepository.java b/src/main/java/org/apolenkov/application/domain/port/FlashcardRepository.java
--- a/src/main/java/org/apolenkov/application/domain/port/FlashcardRepository.java	(revision 132c2c29773f5f4949b3855c362e338d983d3cd4)
+++ b/src/main/java/org/apolenkov/application/domain/port/FlashcardRepository.java	(date 1760197282014)
@@ -1,6 +1,8 @@
 package org.apolenkov.application.domain.port;

+import java.util.Collection;
 import java.util.List;
+import java.util.Map;
 import java.util.Optional;
 import org.apolenkov.application.model.Flashcard;

@@ -35,6 +37,14 @@
      */
     void save(Flashcard flashcard);

+    /**
+     * Saves multiple flashcards in batch operation.
+     * More efficient than calling save() multiple times.
+     *
+     * @param flashcards collection of flashcards to save
+     */
+    void saveAll(Collection<Flashcard> flashcards);
+
     /**
      * Deletes flashcard by identifier.
      *
@@ -50,6 +60,14 @@
      */
     long countByDeckId(long deckId);

+    /**
+     * Counts flashcards for multiple decks in single query.
+     *
+     * @param deckIds collection of deck identifiers (non-null, may be empty)
+     * @return map of deck ID to flashcard count (non-null, contains only decks with flashcards)
+     */
+    Map<Long, Long> countByDeckIds(Collection<Long> deckIds);
+
     /**
      * Deletes all flashcards in specific deck.
      *
Index: src/main/java/org/apolenkov/application/views/deck/components/dialogs/DeckSimpleDeleteDialog.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/org/apolenkov/application/views/deck/components/dialogs/DeckSimpleDeleteDialog.java b/src/main/java/org/apolenkov/application/views/deck/components/dialogs/DeckSimpleDeleteDialog.java
--- a/src/main/java/org/apolenkov/application/views/deck/components/dialogs/DeckSimpleDeleteDialog.java	(revision 132c2c29773f5f4949b3855c362e338d983d3cd4)
+++ b/src/main/java/org/apolenkov/application/views/deck/components/dialogs/DeckSimpleDeleteDialog.java	(date 1760129814242)
@@ -36,7 +36,6 @@
 public final class DeckSimpleDeleteDialog extends Dialog {

     private static final Logger LOGGER = LoggerFactory.getLogger(DeckSimpleDeleteDialog.class);
-    private static final Logger AUDIT_LOGGER = LoggerFactory.getLogger("org.apolenkov.application.audit");

     // Dependencies
     private final transient DeckUseCase deckUseCase;
@@ -194,11 +193,7 @@
         try {
             deckUseCase.deleteDeck(currentDeck.getId());

-            // Audit log for simple deck deletion
-            AUDIT_LOGGER.info(
-                    "User deleted empty deck '{}' (ID: {}) - Simple deletion (no cards)",
-                    currentDeck.getTitle(),
-                    currentDeck.getId());
+            LOGGER.debug("Deck deleted successfully: id={}, title='{}'", currentDeck.getId(), currentDeck.getTitle());

             close();
             NotificationHelper.showSuccessBottom(getTranslation(DeckConstants.DECK_DELETE_SUCCESS));
Index: src/main/java/org/apolenkov/application/domain/port/StatsRepository.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/org/apolenkov/application/domain/port/StatsRepository.java b/src/main/java/org/apolenkov/application/domain/port/StatsRepository.java
--- a/src/main/java/org/apolenkov/application/domain/port/StatsRepository.java	(revision 132c2c29773f5f4949b3855c362e338d983d3cd4)
+++ b/src/main/java/org/apolenkov/application/domain/port/StatsRepository.java	(date 1760194949867)
@@ -30,6 +30,14 @@
      */
     Set<Long> getKnownCardIds(long deckId);

+    /**
+     * Gets known card IDs for multiple decks in single query.
+     *
+     * @param deckIds collection of deck identifiers (non-null, may be empty)
+     * @return map of deck ID to set of known card IDs (decks with no known cards may be absent)
+     */
+    Map<Long, Set<Long>> getKnownCardIdsBatch(Collection<Long> deckIds);
+
     /**
      * Marks card as known or unknown for deck.
      *
Index: src/main/java/org/apolenkov/application/service/seed/DataSeedRepositories.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/org/apolenkov/application/service/seed/DataSeedRepositories.java b/src/main/java/org/apolenkov/application/service/seed/DataSeedRepositories.java
new file mode 100644
--- /dev/null	(date 1760205012072)
+++ b/src/main/java/org/apolenkov/application/service/seed/DataSeedRepositories.java	(date 1760205012072)
@@ -0,0 +1,24 @@
+package org.apolenkov.application.service.seed;
+
+import org.apolenkov.application.domain.port.DeckRepository;
+import org.apolenkov.application.domain.port.FlashcardRepository;
+import org.apolenkov.application.domain.port.NewsRepository;
+import org.apolenkov.application.domain.port.StatsRepository;
+import org.apolenkov.application.domain.port.UserRepository;
+
+/**
+ * Groups all repository dependencies required for data seed operations.
+ * This reduces constructor parameter count in DataSeedService.
+ *
+ * @param userRepository repository for user operations
+ * @param deckRepository repository for deck operations
+ * @param flashcardRepository repository for flashcard operations
+ * @param statsRepository repository for statistics operations
+ * @param newsRepository repository for news operations
+ */
+public record DataSeedRepositories(
+        UserRepository userRepository,
+        DeckRepository deckRepository,
+        FlashcardRepository flashcardRepository,
+        StatsRepository statsRepository,
+        NewsRepository newsRepository) {}
Index: src/main/java/org/apolenkov/application/views/deck/pages/DeckView.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/org/apolenkov/application/views/deck/pages/DeckView.java b/src/main/java/org/apolenkov/application/views/deck/pages/DeckView.java
--- a/src/main/java/org/apolenkov/application/views/deck/pages/DeckView.java	(revision 132c2c29773f5f4949b3855c362e338d983d3cd4)
+++ b/src/main/java/org/apolenkov/application/views/deck/pages/DeckView.java	(date 1760128854147)
@@ -4,6 +4,7 @@
 import com.vaadin.flow.component.Composite;
 import com.vaadin.flow.component.DetachEvent;
 import com.vaadin.flow.component.UI;
+import com.vaadin.flow.component.html.H2;
 import com.vaadin.flow.component.orderedlayout.FlexComponent;
 import com.vaadin.flow.component.orderedlayout.VerticalLayout;
 import com.vaadin.flow.router.BeforeEvent;
@@ -13,6 +14,8 @@
 import com.vaadin.flow.shared.Registration;
 import jakarta.annotation.PostConstruct;
 import jakarta.annotation.security.RolesAllowed;
+import java.util.List;
+import java.util.Optional;
 import org.apolenkov.application.config.constants.RouteConstants;
 import org.apolenkov.application.config.security.SecurityConstants;
 import org.apolenkov.application.domain.usecase.DeckUseCase;
@@ -22,7 +25,6 @@
 import org.apolenkov.application.service.stats.StatsService;
 import org.apolenkov.application.views.core.exception.EntityNotFoundException;
 import org.apolenkov.application.views.core.layout.PublicLayout;
-import org.apolenkov.application.views.deck.business.DeckViewState;
 import org.apolenkov.application.views.deck.components.detail.DeckViewLayout;
 import org.apolenkov.application.views.deck.components.dialogs.DeckDeleteDialog;
 import org.apolenkov.application.views.deck.components.dialogs.DeckEditDialog;
@@ -45,7 +47,7 @@
     private final transient StatsService statsService;

     // State and Layout
-    private transient DeckViewState deckViewState;
+    private transient Deck currentDeck;
     private transient DeckViewLayout deckViewLayout;

     // Event Registrations
@@ -82,11 +84,8 @@
         getContent().setSpacing(true);
         getContent().setAlignItems(FlexComponent.Alignment.CENTER);

-        // Initialize state management
-        deckViewState = new DeckViewState(deckUseCase, flashcardUseCase);
-
         // Show loading state initially
-        deckViewState.showLoadingState();
+        showLoadingState();
     }

     /**
@@ -166,7 +165,6 @@
     private void setupPracticeButtonListener() {
         if (practiceClickListenerRegistration == null) {
             practiceClickListenerRegistration = deckViewLayout.getDeckActions().addPracticeClickListener(e -> {
-                Deck currentDeck = deckViewState.getCurrentDeck();
                 if (currentDeck != null) {
                     NavigationHelper.navigateToPractice(currentDeck.getId());
                 }
@@ -190,7 +188,6 @@
     private void setupEditDeckButtonListener() {
         if (editDeckClickListenerRegistration == null) {
             editDeckClickListenerRegistration = deckViewLayout.getDeckActions().addEditDeckClickListener(e -> {
-                Deck currentDeck = deckViewState.getCurrentDeck();
                 if (currentDeck != null) {
                     new DeckEditDialog(deckUseCase, currentDeck, updated -> updateDeckInfo()).open();
                 }
@@ -227,6 +224,34 @@
         }
     }

+    /**
+     * Shows loading state while deck is being loaded.
+     */
+    private void showLoadingState() {
+        getContent().removeAll();
+
+        VerticalLayout loadingContainer = new VerticalLayout();
+        loadingContainer.setSpacing(true);
+        loadingContainer.setWidthFull();
+        loadingContainer.addClassName(DeckConstants.CONTAINER_MD_CLASS);
+        loadingContainer.setAlignItems(FlexComponent.Alignment.CENTER);
+
+        VerticalLayout loadingSection = new VerticalLayout();
+        loadingSection.setSpacing(true);
+        loadingSection.setPadding(true);
+        loadingSection.setWidthFull();
+        loadingSection.addClassName(DeckConstants.DECK_VIEW_SECTION_CLASS);
+        loadingSection.addClassName(DeckConstants.SURFACE_PANEL_CLASS);
+        loadingSection.addClassName(DeckConstants.CONTAINER_MD_CLASS);
+
+        H2 loadingTitle = new H2(getTranslation(DeckConstants.DECK_LOADING_STATE));
+        loadingTitle.addClassName(DeckConstants.DECK_VIEW_TITLE_CLASS);
+
+        loadingSection.add(loadingTitle);
+        loadingContainer.add(loadingSection);
+        getContent().add(loadingContainer);
+    }
+
     /**
      * Creates the main deck content after successful deck loading.
      */
@@ -240,9 +265,6 @@
         deckViewLayout.setEditFlashcardCallback(this::openFlashcardDialog);
         deckViewLayout.setDeleteFlashcardCallback(this::deleteFlashcard);

-        // Set layout in state management
-        deckViewState.setDeckViewLayout(deckViewLayout);
-
         // Create and add content
         VerticalLayout contentContainer = deckViewLayout.createDeckContent();
         getContent().add(contentContainer);
@@ -252,25 +274,54 @@
      * Loads a deck by ID and initializes the view.
      *
      * @param deckId the ID of the deck to load
+     * @throws EntityNotFoundException if deck is not found
      */
     private void loadDeck(final long deckId) {
-        deckViewState.loadDeck(deckId);
+        Optional<Deck> deckOpt = deckUseCase.getDeckById(deckId);
+        if (deckOpt.isPresent()) {
+            currentDeck = deckOpt.get();
+            LOGGER.info("Deck loaded successfully: {}", currentDeck.getTitle());
+        } else {
+            LOGGER.warn("Deck not found with ID: {}", deckId);
+            throw new EntityNotFoundException(
+                    String.valueOf(deckId), RouteConstants.DECKS_ROUTE, getTranslation(DeckConstants.DECK_NOT_FOUND));
+        }
+
         createDeckContent();
-        deckViewState.loadFlashcards();
+        loadFlashcards();
     }

     /**
      * Updates the display of deck information (title, stats, description).
      */
     private void updateDeckInfo() {
-        deckViewState.updateDeckInfo();
+        if (currentDeck != null && deckViewLayout != null) {
+            if (deckViewLayout.getDeckHeader() != null) {
+                deckViewLayout.getDeckHeader().setDeckTitle(currentDeck.getTitle());
+                deckViewLayout
+                        .getDeckHeader()
+                        .setDeckStats(getTranslation(
+                                DeckConstants.DECK_COUNT, flashcardUseCase.countByDeckId(currentDeck.getId())));
+            }
+            if (deckViewLayout.getDeckInfo() != null) {
+                String description = Optional.ofNullable(currentDeck.getDescription())
+                        .filter(desc -> !desc.trim().isEmpty())
+                        .orElse(getTranslation(DeckConstants.DECK_DESCRIPTION_EMPTY));
+                deckViewLayout.getDeckInfo().setDescription(description);
+            }
+        }
     }

     /**
      * Loads flashcards for the current deck and updates the grid.
      */
     private void loadFlashcards() {
-        deckViewState.loadFlashcards();
+        if (currentDeck != null && deckViewLayout != null && deckViewLayout.getDeckGrid() != null) {
+            List<Flashcard> flashcards = flashcardUseCase.getFlashcardsByDeckId(currentDeck.getId());
+            deckViewLayout.getDeckGrid().setCurrentDeckId(currentDeck.getId());
+            deckViewLayout.getDeckGrid().setFlashcards(flashcards);
+            LOGGER.info("Loaded {} flashcards for deck: {}", flashcards.size(), currentDeck.getTitle());
+        }
     }

     /**
@@ -279,7 +330,6 @@
      * @param flashcard the flashcard to edit, or null for creating new
      */
     private void openFlashcardDialog(final Flashcard flashcard) {
-        Deck currentDeck = deckViewState.getCurrentDeck();
         DeckFlashcardDialog dialog = new DeckFlashcardDialog(flashcardUseCase, currentDeck, savedFlashcard -> {
             if (flashcard == null) {
                 // New flashcard - reload all data
@@ -325,7 +375,6 @@
      * Shows simple dialog for empty decks, complex dialog for decks with cards.
      */
     private void deleteDeck() {
-        Deck currentDeck = deckViewState.getCurrentDeck();
         if (currentDeck == null) {
             return;
         }
Index: src/main/java/org/apolenkov/application/service/deck/DeckUseCaseService.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/org/apolenkov/application/service/deck/DeckUseCaseService.java b/src/main/java/org/apolenkov/application/service/deck/DeckUseCaseService.java
--- a/src/main/java/org/apolenkov/application/service/deck/DeckUseCaseService.java	(revision 132c2c29773f5f4949b3855c362e338d983d3cd4)
+++ b/src/main/java/org/apolenkov/application/service/deck/DeckUseCaseService.java	(date 1760195031769)
@@ -21,7 +21,7 @@
 public class DeckUseCaseService implements DeckUseCase {

     private static final Logger LOGGER = LoggerFactory.getLogger(DeckUseCaseService.class);
-    private static final Logger AUDIT_LOG = LoggerFactory.getLogger("org.apolenkov.application.audit");
+    private static final Logger AUDIT_LOGGER = LoggerFactory.getLogger("org.apolenkov.application.audit");

     private final DeckRepository deckRepository;
     private final FlashcardRepository flashcardRepository;
@@ -62,10 +62,7 @@
     @Override
     @Transactional(readOnly = true)
     public List<Deck> getAllDecks() {
-        LOGGER.debug("Retrieving all decks");
-        List<Deck> decks = deckRepository.findAll();
-        LOGGER.info("Retrieved {} decks from database", decks.size());
-        return decks;
+        return deckRepository.findAll();
     }

     /**
@@ -78,10 +75,7 @@
     @Override
     @Transactional(readOnly = true)
     public List<Deck> getDecksByUserId(final long userId) {
-        LOGGER.debug("Retrieving decks for user {}", userId);
-        List<Deck> decks = deckRepository.findByUserId(userId);
-        LOGGER.info("Retrieved {} decks for user {}", decks.size(), userId);
-        return decks;
+        return deckRepository.findByUserId(userId);
     }

     /**
@@ -94,14 +88,7 @@
     @Override
     @Transactional(readOnly = true)
     public Optional<Deck> getDeckById(final long id) {
-        LOGGER.debug("Retrieving deck with ID {}", id);
-        Optional<Deck> deck = deckRepository.findById(id);
-        if (deck.isPresent()) {
-            LOGGER.info("Deck {} found successfully", id);
-        } else {
-            LOGGER.debug("Deck {} not found", id);
-        }
-        return deck;
+        return deckRepository.findById(id);
     }

     /**
@@ -141,7 +128,7 @@
                 deck.getId() == null);

         // Audit log
-        AUDIT_LOG.info(
+        AUDIT_LOGGER.info(
                 "Deck {}: title='{}', userId={}, isNew={}",
                 savedDeck.getId(),
                 savedDeck.getTitle(),
@@ -184,6 +171,6 @@
         LOGGER.info("Deck deleted: id={}, title='{}', userId={}", id, deck.getTitle(), deck.getUserId());

         // Audit log
-        AUDIT_LOG.warn("Deck deleted: id={}, title='{}', userId={}", id, deck.getTitle(), deck.getUserId());
+        AUDIT_LOGGER.warn("Deck deleted: id={}, title='{}', userId={}", id, deck.getTitle(), deck.getUserId());
     }
 }
Index: src/main/java/org/apolenkov/application/infrastructure/repository/jdbc/adapter/DeckJdbcAdapter.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/org/apolenkov/application/infrastructure/repository/jdbc/adapter/DeckJdbcAdapter.java b/src/main/java/org/apolenkov/application/infrastructure/repository/jdbc/adapter/DeckJdbcAdapter.java
--- a/src/main/java/org/apolenkov/application/infrastructure/repository/jdbc/adapter/DeckJdbcAdapter.java	(revision 132c2c29773f5f4949b3855c362e338d983d3cd4)
+++ b/src/main/java/org/apolenkov/application/infrastructure/repository/jdbc/adapter/DeckJdbcAdapter.java	(date 1760197281924)
@@ -1,7 +1,11 @@
 package org.apolenkov.application.infrastructure.repository.jdbc.adapter;

+import java.sql.PreparedStatement;
+import java.sql.Statement;
 import java.sql.Timestamp;
 import java.time.LocalDateTime;
+import java.util.ArrayList;
+import java.util.Collection;
 import java.util.List;
 import java.util.Optional;
 import org.apolenkov.application.domain.port.DeckRepository;
@@ -16,6 +20,8 @@
 import org.springframework.dao.DataAccessException;
 import org.springframework.jdbc.core.JdbcTemplate;
 import org.springframework.jdbc.core.RowMapper;
+import org.springframework.jdbc.support.GeneratedKeyHolder;
+import org.springframework.jdbc.support.KeyHolder;
 import org.springframework.stereotype.Repository;

 /**
@@ -88,7 +94,9 @@
         LOGGER.debug("Retrieving all decks");
         try {
             List<DeckDto> deckDtos = jdbcTemplate.query(DeckSqlQueries.SELECT_ALL_DECKS, DECK_ROW_MAPPER);
-            return deckDtos.stream().map(DeckJdbcAdapter::toModel).toList();
+            List<Deck> decks = deckDtos.stream().map(DeckJdbcAdapter::toModel).toList();
+            LOGGER.debug("Retrieved {} decks from database", decks.size());
+            return decks;
         } catch (DataAccessException e) {
             throw new DeckRetrievalException("Failed to retrieve all decks", e);
         }
@@ -111,7 +119,9 @@
         try {
             List<DeckDto> deckDtos =
                     jdbcTemplate.query(DeckSqlQueries.SELECT_DECKS_BY_USER_ID, DECK_ROW_MAPPER, userId);
-            return deckDtos.stream().map(DeckJdbcAdapter::toModel).toList();
+            List<Deck> decks = deckDtos.stream().map(DeckJdbcAdapter::toModel).toList();
+            LOGGER.debug("Retrieved {} decks for user ID: {}", decks.size(), userId);
+            return decks;
         } catch (DataAccessException e) {
             throw new DeckRetrievalException("Failed to retrieve decks for user ID: " + userId, e);
         }
@@ -151,13 +161,13 @@
             throw new IllegalArgumentException("Deck cannot be null");
         }

-        LOGGER.debug("Saving deck: {}", deck.getTitle());
+        boolean isNew = deck.getId() == null;
+        LOGGER.debug("Saving deck: title='{}', isNew={}", deck.getTitle(), isNew);
+
         try {
-            if (deck.getId() == null) {
-                return createDeck(deck);
-            } else {
-                return updateDeck(deck);
-            }
+            Deck saved = isNew ? createDeck(deck) : updateDeck(deck);
+            LOGGER.debug("Deck saved: id={}, title='{}', isNew={}", saved.getId(), saved.getTitle(), isNew);
+            return saved;
         } catch (DataAccessException e) {
             throw new DeckPersistenceException("Failed to save deck: " + deck.getTitle(), e);
         }
@@ -175,6 +185,8 @@
             int deleted = jdbcTemplate.update(DeckSqlQueries.DELETE_DECK, id);
             if (deleted == 0) {
                 LOGGER.warn("No deck found with ID: {}", id);
+            } else {
+                LOGGER.debug("Deck deleted from database: id={}", id);
             }
         } catch (DataAccessException e) {
             throw new DeckPersistenceException("Failed to delete deck by ID: " + id, e);
@@ -230,4 +242,80 @@

         return deck;
     }
+
+    /**
+     * Saves multiple decks in batch operation for better performance.
+     * Uses batch insert for new decks only.
+     *
+     * @param decks collection of decks to save
+     * @return list of saved decks with generated IDs
+     */
+    @Override
+    public List<Deck> saveAll(final Collection<Deck> decks) {
+        if (decks == null || decks.isEmpty()) {
+            return List.of();
+        }
+
+        LOGGER.debug("Batch saving {} decks", decks.size());
+        List<Deck> savedDecks = new ArrayList<>(decks.size());
+
+        try {
+            // Process only new decks for batch insert
+            List<Deck> newDecks = decks.stream().filter(d -> d.getId() == null).toList();
+
+            if (!newDecks.isEmpty()) {
+                savedDecks.addAll(batchInsertDecks(newDecks));
+            }
+
+            // Update existing decks one by one (rare case in seed data)
+            for (Deck deck : decks) {
+                if (deck.getId() != null) {
+                    savedDecks.add(updateDeck(deck));
+                }
+            }
+
+            LOGGER.debug("Batch saved {} decks successfully", savedDecks.size());
+            return savedDecks;
+        } catch (DataAccessException e) {
+            throw new DeckPersistenceException("Failed to batch save decks", e);
+        }
+    }
+
+    /**
+     * Batch inserts new decks into database.
+     *
+     * @param newDecks list of new decks without IDs
+     * @return list of created decks with generated IDs
+     */
+    private List<Deck> batchInsertDecks(final List<Deck> newDecks) {
+        LocalDateTime now = LocalDateTime.now();
+        List<Deck> result = new ArrayList<>(newDecks.size());
+
+        // Insert each deck and collect generated IDs
+        for (Deck deck : newDecks) {
+            KeyHolder keyHolder = new GeneratedKeyHolder();
+
+            jdbcTemplate.update(
+                    connection -> {
+                        PreparedStatement ps = connection.prepareStatement(
+                                DeckSqlQueries.INSERT_DECK_RETURNING_ID, Statement.RETURN_GENERATED_KEYS);
+                        ps.setLong(1, deck.getUserId());
+                        ps.setString(2, deck.getTitle());
+                        ps.setString(3, deck.getDescription());
+                        ps.setTimestamp(4, Timestamp.valueOf(now));
+                        ps.setTimestamp(5, Timestamp.valueOf(now));
+                        return ps;
+                    },
+                    keyHolder);
+
+            Number key = keyHolder.getKey();
+            if (key != null) {
+                Long generatedId = key.longValue();
+                Deck savedDeck = new Deck(generatedId, deck.getUserId(), deck.getTitle(), deck.getDescription());
+                result.add(savedDeck);
+            }
+        }
+
+        return result;
+    }
 }
Index: src/main/java/org/apolenkov/application/service/card/FlashcardUseCaseService.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/org/apolenkov/application/service/card/FlashcardUseCaseService.java b/src/main/java/org/apolenkov/application/service/card/FlashcardUseCaseService.java
--- a/src/main/java/org/apolenkov/application/service/card/FlashcardUseCaseService.java	(revision 132c2c29773f5f4949b3855c362e338d983d3cd4)
+++ b/src/main/java/org/apolenkov/application/service/card/FlashcardUseCaseService.java	(date 1760195528851)
@@ -1,12 +1,16 @@
 package org.apolenkov.application.service.card;

 import jakarta.validation.Validator;
+import java.util.Collection;
 import java.util.List;
+import java.util.Map;
 import java.util.stream.Collectors;
 import org.apolenkov.application.domain.port.FlashcardRepository;
 import org.apolenkov.application.domain.usecase.FlashcardUseCase;
 import org.apolenkov.application.model.Flashcard;
 import org.apolenkov.application.views.core.constants.CoreConstants;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 import org.springframework.stereotype.Service;
 import org.springframework.transaction.annotation.Transactional;

@@ -16,6 +20,8 @@
 @Service
 public class FlashcardUseCaseService implements FlashcardUseCase {

+    private static final Logger LOGGER = LoggerFactory.getLogger(FlashcardUseCaseService.class);
+
     private final FlashcardRepository flashcardRepository;
     private final Validator validator;

@@ -51,15 +57,26 @@
     @Override
     @Transactional
     public void saveFlashcard(final Flashcard flashcard) {
+        LOGGER.debug("Saving flashcard: frontText='{}', deckId={}", flashcard.getFrontText(), flashcard.getDeckId());
+
         var violations = validator.validate(flashcard);
         if (!violations.isEmpty()) {
             String message = violations.stream()
                     .map(v -> v.getPropertyPath() + CoreConstants.SEPARATOR_SPACE + v.getMessage())
                     .collect(Collectors.joining(", "));
+            LOGGER.warn("Flashcard validation failed: {}", message);
             throw new IllegalArgumentException("Validation failed: " + message);
         }

+        boolean isNew = flashcard.getId() == null;
         flashcardRepository.save(flashcard);
+
+        LOGGER.info(
+                "Flashcard saved: id={}, frontText='{}', deckId={}, isNew={}",
+                flashcard.getId(),
+                flashcard.getFrontText(),
+                flashcard.getDeckId(),
+                isNew);
     }

     /**
@@ -70,7 +87,11 @@
     @Override
     @Transactional
     public void deleteFlashcard(final long id) {
+        LOGGER.debug("Deleting flashcard with ID: {}", id);
+
         flashcardRepository.deleteById(id);
+
+        LOGGER.info("Flashcard deleted successfully: id={}", id);
     }

     /**
@@ -84,4 +105,25 @@
     public long countByDeckId(final long deckId) {
         return flashcardRepository.countByDeckId(deckId);
     }
+
+    /**
+     * Returns flashcard counts for multiple decks in single database query.
+     *
+     * @param deckIds collection of deck IDs to count flashcards for
+     * @return map of deck ID to flashcard count (empty map if deckIds is empty)
+     */
+    @Override
+    @Transactional(readOnly = true)
+    public Map<Long, Long> countByDeckIds(final Collection<Long> deckIds) {
+        if (deckIds == null || deckIds.isEmpty()) {
+            LOGGER.debug("countByDeckIds called with empty collection, returning empty map");
+            return Map.of();
+        }
+
+        LOGGER.debug("Batch counting flashcards for {} decks", deckIds.size());
+        Map<Long, Long> counts = flashcardRepository.countByDeckIds(deckIds);
+        LOGGER.debug("Batch count completed: {} decks have flashcards", counts.size());
+
+        return counts;
+    }
 }
Index: src/main/java/org/apolenkov/application/infrastructure/repository/jdbc/adapter/StatsJdbcAdapter.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/org/apolenkov/application/infrastructure/repository/jdbc/adapter/StatsJdbcAdapter.java b/src/main/java/org/apolenkov/application/infrastructure/repository/jdbc/adapter/StatsJdbcAdapter.java
--- a/src/main/java/org/apolenkov/application/infrastructure/repository/jdbc/adapter/StatsJdbcAdapter.java	(revision 132c2c29773f5f4949b3855c362e338d983d3cd4)
+++ b/src/main/java/org/apolenkov/application/infrastructure/repository/jdbc/adapter/StatsJdbcAdapter.java	(date 1760195528836)
@@ -8,10 +8,12 @@
 import java.util.Set;
 import org.apolenkov.application.domain.dto.SessionStatsDto;
 import org.apolenkov.application.domain.port.StatsRepository;
+import org.apolenkov.application.infrastructure.repository.jdbc.exception.StatsRetrievalException;
 import org.apolenkov.application.infrastructure.repository.jdbc.sql.StatsSqlQueries;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 import org.springframework.context.annotation.Profile;
+import org.springframework.dao.DataAccessException;
 import org.springframework.jdbc.core.JdbcTemplate;
 import org.springframework.stereotype.Repository;

@@ -63,6 +65,7 @@
                 sessionStats.totalAnswerDelayMs());

         // Update known cards if provided
+        int knownCardsUpdated = 0;
         if (sessionStats.knownCardIdsDelta() != null) {
             for (Long cardId : sessionStats.knownCardIdsDelta()) {
                 jdbcTemplate.update(
@@ -71,8 +74,17 @@
                         cardId,
                         sessionStats.deckId(),
                         cardId);
+                knownCardsUpdated++;
             }
         }
+
+        LOGGER.debug(
+                "Session stats appended: deckId={}, date={}, viewed={}, correct={}, knownCardsUpdated={}",
+                sessionStats.deckId(),
+                date,
+                sessionStats.viewed(),
+                sessionStats.correct(),
+                knownCardsUpdated);
     }

     /**
@@ -88,6 +100,36 @@
         return new HashSet<>(jdbcTemplate.queryForList(StatsSqlQueries.SELECT_KNOWN_CARD_IDS, Long.class, deckId));
     }

+    /**
+     * Gets known card IDs for multiple decks in single query.
+     *
+     * @param deckIds collection of deck identifiers
+     * @return map of deck ID to set of known card IDs
+     */
+    @Override
+    public Map<Long, Set<Long>> getKnownCardIdsBatch(final Collection<Long> deckIds) {
+        if (deckIds == null || deckIds.isEmpty()) {
+            return Map.of();
+        }
+
+        LOGGER.debug("Batch getting known card IDs for {} decks using single query", deckIds.size());
+        try {
+            String sql = buildInClauseSql(StatsSqlQueries.SELECT_KNOWN_CARD_IDS_BATCH_TEMPLATE, deckIds.size());
+            Map<Long, Set<Long>> result =
+                    jdbcTemplate.query(sql, ps -> setLongParameters(ps, deckIds), this::extractKnownCardsByDeck);
+
+            Map<Long, Set<Long>> safeResult = (result != null) ? result : Map.of();
+            LOGGER.debug(
+                    "Batch known cards completed: {} decks have known cards (out of {} requested)",
+                    safeResult.size(),
+                    deckIds.size());
+            return safeResult;
+
+        } catch (DataAccessException e) {
+            throw new StatsRetrievalException("Failed to get known card IDs for deck IDs: " + deckIds, e);
+        }
+    }
+
     /**
      * Sets card known status for a deck.
      * This method can be safely overridden by subclasses.
@@ -105,6 +147,7 @@
         } else {
             jdbcTemplate.update(StatsSqlQueries.DELETE_KNOWN_CARD, deckId, cardId);
         }
+        LOGGER.debug("Card {} marked as {} in deck {}", cardId, known ? "known" : "unknown", deckId);
     }

     /**
@@ -118,10 +161,16 @@
         LOGGER.debug("Resetting progress for deck ID: {}", deckId);

         // Delete daily stats
-        jdbcTemplate.update(StatsSqlQueries.DELETE_DAILY_STATS_BY_DECK, deckId);
+        int statsDeleted = jdbcTemplate.update(StatsSqlQueries.DELETE_DAILY_STATS_BY_DECK, deckId);

         // Delete known cards
-        jdbcTemplate.update(StatsSqlQueries.DELETE_KNOWN_CARDS_BY_DECK, deckId);
+        int knownCardsDeleted = jdbcTemplate.update(StatsSqlQueries.DELETE_KNOWN_CARDS_BY_DECK, deckId);
+
+        LOGGER.debug(
+                "Deck progress reset: deckId={}, statsDeleted={}, knownCardsDeleted={}",
+                deckId,
+                statsDeleted,
+                knownCardsDeleted);
     }

     /**
@@ -140,40 +189,99 @@
             return new HashMap<>();
         }

-        String placeholders =
-                deckIds.stream().map(id -> "?").reduce((a, b) -> a + "," + b).orElse("");
+        String sql = buildInClauseSql(StatsSqlQueries.SELECT_AGGREGATES_FOR_DECKS_TEMPLATE, deckIds.size());
+        Object[] params = buildAggregateParams(today, deckIds);
+
+        Map<Long, DeckAggregate> result = new HashMap<>();
+        jdbcTemplate.query(
+                sql,
+                rs -> {
+                    Long deckId = rs.getLong("deck_id");
+                    DeckAggregate aggregate = mapToDeckAggregate(rs);
+                    result.put(deckId, aggregate);
+                },
+                params);
+
+        return result;
+    }
+
+    /**
+     * Builds SQL with IN clause placeholders.
+     *
+     * @param sqlTemplate SQL template with placeholder for IN clause
+     * @param paramCount number of parameters for IN clause
+     * @return SQL with placeholders
+     */
+    private String buildInClauseSql(final String sqlTemplate, final int paramCount) {
+        String placeholders = "?,".repeat(Math.max(0, paramCount - 1)) + "?";
+        return String.format(sqlTemplate, placeholders);
+    }

-        String sql = String.format(StatsSqlQueries.SELECT_AGGREGATES_FOR_DECKS_TEMPLATE, placeholders);
+    /**
+     * Sets long parameters in PreparedStatement.
+     *
+     * @param ps PreparedStatement to set parameters in
+     * @param values collection of long values
+     */
+    private void setLongParameters(final java.sql.PreparedStatement ps, final Collection<Long> values)
+            throws java.sql.SQLException {
+        int index = 1;
+        for (Long value : values) {
+            ps.setLong(index++, value);
+        }
+    }

+    /**
+     * Extracts known cards by deck from ResultSet.
+     *
+     * @param rs ResultSet to extract from
+     * @return map of deck ID to set of known card IDs
+     */
+    private Map<Long, Set<Long>> extractKnownCardsByDeck(final java.sql.ResultSet rs) throws java.sql.SQLException {
+        Map<Long, Set<Long>> knownCardsByDeck = new HashMap<>();
+        while (rs.next()) {
+            Long deckId = rs.getLong("deck_id");
+            Long cardId = rs.getLong("card_id");
+            knownCardsByDeck.computeIfAbsent(deckId, k -> new HashSet<>()).add(cardId);
+        }
+        return knownCardsByDeck;
+    }
+
+    /**
+     * Builds parameters array for aggregate query.
+     *
+     * @param today date for today's statistics
+     * @param deckIds collection of deck IDs
+     * @return parameters array
+     */
+    private Object[] buildAggregateParams(final LocalDate today, final Collection<Long> deckIds) {
         Object[] params = new Object[deckIds.size() + 4];
         params[0] = today;
         params[1] = today;
         params[2] = today;
         params[3] = today;
-        int i = 4;
+        int index = 4;
         for (Long deckId : deckIds) {
-            params[i++] = deckId;
+            params[index++] = deckId;
         }
+        return params;
+    }

-        Map<Long, DeckAggregate> result = new HashMap<>();
-        jdbcTemplate.query(
-                sql,
-                (rs, rowNum) -> {
-                    Long deckId = rs.getLong("deck_id");
-                    DeckAggregate aggregate = new DeckAggregate(
-                            rs.getInt("sessions_all"),
-                            rs.getInt("viewed_all"),
-                            rs.getInt("correct_all"),
-                            rs.getInt("hard_all"),
-                            rs.getInt("sessions_today"),
-                            rs.getInt("viewed_today"),
-                            rs.getInt("correct_today"),
-                            rs.getInt("hard_today"));
-                    result.put(deckId, aggregate);
-                    return null;
-                },
-                params);
-
-        return result;
+    /**
+     * Maps ResultSet row to DeckAggregate.
+     *
+     * @param rs ResultSet positioned at current row
+     * @return DeckAggregate from current row
+     */
+    private DeckAggregate mapToDeckAggregate(final java.sql.ResultSet rs) throws java.sql.SQLException {
+        return new DeckAggregate(
+                rs.getInt("sessions_all"),
+                rs.getInt("viewed_all"),
+                rs.getInt("correct_all"),
+                rs.getInt("hard_all"),
+                rs.getInt("sessions_today"),
+                rs.getInt("viewed_today"),
+                rs.getInt("correct_today"),
+                rs.getInt("hard_today"));
     }
 }
Index: src/main/java/org/apolenkov/application/service/seed/SeedConfig.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/org/apolenkov/application/service/seed/SeedConfig.java b/src/main/java/org/apolenkov/application/service/seed/SeedConfig.java
new file mode 100644
--- /dev/null	(date 1760205011585)
+++ b/src/main/java/org/apolenkov/application/service/seed/SeedConfig.java	(date 1760205011585)
@@ -0,0 +1,49 @@
+package org.apolenkov.application.service.seed;
+
+import org.springframework.boot.context.properties.ConfigurationProperties;
+
+/**
+ * Configuration properties for test data generation.
+ * Groups all seed-related configuration values to reduce constructor parameter count.
+ *
+ * @param batch batch sizes for bulk operations
+ * @param limits generation limits for different entity types
+ */
+@ConfigurationProperties(prefix = "app.seed")
+public record SeedConfig(Batch batch, Limits limits) {
+
+    /**
+     * Batch sizes for bulk operations.
+     *
+     * @param users batch size for user generation
+     */
+    public record Batch(int users) {
+        /**
+         * Compact constructor with validation.
+         */
+        public Batch {
+            if (users <= 0) {
+                throw new IllegalArgumentException("Batch size must be positive");
+            }
+        }
+    }
+
+    /**
+     * Generation limits for different entity types.
+     *
+     * @param users total users to generate
+     * @param decksPerUser decks per user
+     * @param cardsPerDeck cards per deck
+     * @param news news articles count
+     */
+    public record Limits(int users, int decksPerUser, int cardsPerDeck, int news) {
+        /**
+         * Compact constructor with validation.
+         */
+        public Limits {
+            if (users < 0 || decksPerUser < 0 || cardsPerDeck < 0 || news < 0) {
+                throw new IllegalArgumentException("Limits must be non-negative");
+            }
+        }
+    }
+}
Index: src/main/resources/application.yml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/resources/application.yml b/src/main/resources/application.yml
--- a/src/main/resources/application.yml	(revision 132c2c29773f5f4949b3855c362e338d983d3cd4)
+++ b/src/main/resources/application.yml	(date 1760205424719)
@@ -47,6 +47,12 @@
       show-details: when-authorized
       show-components: when-authorized

+app:
+  cache:
+    user:
+      ttl-minutes: ${CACHE_USER_TTL:30}
+      max-size: ${CACHE_USER_MAX_SIZE:1000}
+
 ---
 # Development Profile
 spring:
@@ -54,12 +60,20 @@
     activate:
       on-profile: dev

-# Demo user configuration
-demo:
-  admin:
-    password: ${DEMO_ADMIN_PASSWORD}
-  user:
-    password: ${DEMO_USER_PASSWORD}
+# Data seeding configuration (dev profile only)
+app:
+  seed:
+    demo:
+      admin-password: ${DEMO_ADMIN_PASSWORD:admin}
+      user-password: ${DEMO_USER_PASSWORD:user}
+      test-user-password: ${TEST_USER_PASSWORD:testPassword123}
+    batch:
+      users: ${BATCH_SIZE_USERS:100}
+    limits:
+      users: ${LIMIT_USERS:100}
+      decks-per-user: ${LIMIT_DECKS:10}
+      cards-per-deck: ${LIMIT_CARDS:50}
+      news: ${LIMIT_NEWS:50}

 vaadin:
   launch-browser: true
Index: src/main/java/org/apolenkov/application/service/security/PasswordResetService.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/org/apolenkov/application/service/security/PasswordResetService.java b/src/main/java/org/apolenkov/application/service/security/PasswordResetService.java
--- a/src/main/java/org/apolenkov/application/service/security/PasswordResetService.java	(revision 132c2c29773f5f4949b3855c362e338d983d3cd4)
+++ b/src/main/java/org/apolenkov/application/service/security/PasswordResetService.java	(date 1760184404764)
@@ -8,6 +8,8 @@
 import org.apolenkov.application.domain.usecase.PasswordResetUseCase;
 import org.apolenkov.application.model.PasswordResetToken;
 import org.apolenkov.application.model.User;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 import org.springframework.security.crypto.password.PasswordEncoder;
 import org.springframework.stereotype.Service;
 import org.springframework.transaction.annotation.Transactional;
@@ -18,6 +20,9 @@
 @Service
 public class PasswordResetService implements PasswordResetUseCase {

+    private static final Logger LOGGER = LoggerFactory.getLogger(PasswordResetService.class);
+    private static final Logger AUDIT_LOGGER = LoggerFactory.getLogger("org.apolenkov.application.audit");
+
     private final PasswordResetTokenRepository tokenRepository;
     private final UserRepository userRepository;
     private final PasswordEncoder passwordEncoder;
@@ -71,8 +76,12 @@
             throw new IllegalArgumentException("Email cannot be null or empty");
         }

+        LOGGER.debug("Processing password reset request for email: {}", email);
+
         Optional<User> userOpt = userRepository.findByEmail(email.trim());
         if (userOpt.isEmpty()) {
+            AUDIT_LOGGER.warn("Password reset attempt for non-existent email: {}", email);
+            LOGGER.debug("Password reset request for non-existent email: {}", email);
             // Return empty to prevent user enumeration attacks
             return Optional.empty();
         }
@@ -80,9 +89,10 @@
         User user = userOpt.get();

         // Invalidate any existing unused tokens for this user
-        tokenRepository
-                .findByUserIdAndNotUsed(user.getId())
-                .ifPresent(token -> tokenRepository.markAsUsed(token.getId()));
+        tokenRepository.findByUserIdAndNotUsed(user.getId()).ifPresent(token -> {
+            tokenRepository.markAsUsed(token.getId());
+            LOGGER.debug("Invalidated existing password reset token for user: {}", user.getEmail());
+        });

         // Generate new secure token
         String token = UUID.randomUUID().toString();
@@ -91,6 +101,13 @@
         PasswordResetToken resetToken = new PasswordResetToken(token, user.getId(), expiresAt);
         tokenRepository.save(resetToken);

+        AUDIT_LOGGER.info(
+                "Password reset token created for user: email={}, userId={}, expiresAt={}",
+                user.getEmail(),
+                user.getId(),
+                expiresAt);
+        LOGGER.info("Password reset token created for user: {}", user.getEmail());
+
         return Optional.of(token);
     }

@@ -114,8 +131,12 @@
             throw new IllegalArgumentException("New password cannot be null or empty");
         }

+        LOGGER.debug("Processing password reset with token");
+
         Optional<PasswordResetToken> tokenOpt = tokenRepository.findByToken(token.trim());
         if (tokenOpt.isEmpty()) {
+            AUDIT_LOGGER.warn("Password reset attempt with invalid token");
+            LOGGER.warn("Invalid password reset token provided");
             return false;
         }

@@ -123,12 +144,18 @@

         // Validate token is still valid
         if (resetToken.isUsed() || resetToken.isExpired()) {
+            AUDIT_LOGGER.warn(
+                    "Password reset attempt with {} token for userId={}",
+                    resetToken.isUsed() ? "used" : "expired",
+                    resetToken.getUserId());
+            LOGGER.warn("Password reset failed - token is {}", resetToken.isUsed() ? "used" : "expired");
             return false;
         }

         // Retrieve associated user
         Optional<User> userOpt = userRepository.findById(resetToken.getUserId());
         if (userOpt.isEmpty()) {
+            LOGGER.error("Password reset token references non-existent user: userId={}", resetToken.getUserId());
             return false;
         }

@@ -141,6 +168,9 @@
         // Mark token as used to prevent reuse
         tokenRepository.markAsUsed(resetToken.getId());

+        AUDIT_LOGGER.info("Password reset successful for user: email={}, userId={}", user.getEmail(), user.getId());
+        LOGGER.info("Password reset completed for user: {}", user.getEmail());
+
         return true;
     }

@@ -157,12 +187,21 @@
             throw new IllegalArgumentException("Token cannot be null or empty");
         }

+        LOGGER.debug("Validating password reset token");
+
         Optional<PasswordResetToken> tokenOpt = tokenRepository.findByToken(token.trim());
         if (tokenOpt.isEmpty()) {
+            LOGGER.debug("Token validation failed - token not found");
             return false;
         }

         PasswordResetToken resetToken = tokenOpt.get();
-        return !resetToken.isUsed() && !resetToken.isExpired();
+        boolean isValid = !resetToken.isUsed() && !resetToken.isExpired();
+
+        if (!isValid) {
+            LOGGER.debug("Token validation failed - used={}, expired={}", resetToken.isUsed(), resetToken.isExpired());
+        }
+
+        return isValid;
     }
 }
Index: src/main/java/org/apolenkov/application/service/user/JdbcRegistrationService.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/org/apolenkov/application/service/user/JdbcRegistrationService.java b/src/main/java/org/apolenkov/application/service/user/JdbcRegistrationService.java
--- a/src/main/java/org/apolenkov/application/service/user/JdbcRegistrationService.java	(revision 132c2c29773f5f4949b3855c362e338d983d3cd4)
+++ b/src/main/java/org/apolenkov/application/service/user/JdbcRegistrationService.java	(date 1760129814219)
@@ -3,6 +3,8 @@
 import org.apolenkov.application.config.security.SecurityConstants;
 import org.apolenkov.application.domain.port.UserRepository;
 import org.apolenkov.application.model.User;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 import org.springframework.context.annotation.Profile;
 import org.springframework.security.crypto.password.PasswordEncoder;
 import org.springframework.stereotype.Service;
@@ -15,6 +17,9 @@
 @Profile({"dev", "prod", "test"})
 public class JdbcRegistrationService implements RegistrationService {

+    private static final Logger LOGGER = LoggerFactory.getLogger(JdbcRegistrationService.class);
+    private static final Logger AUDIT_LOGGER = LoggerFactory.getLogger("org.apolenkov.application.audit");
+
     private final UserRepository userRepository;
     private final PasswordEncoder passwordEncoder;

@@ -42,15 +47,23 @@
     @Override
     @Transactional
     public void register(final String email, final String name, final String rawPassword) {
+        LOGGER.debug("Processing registration request for email: {}", email);
+
         userRepository.findByEmail(email).ifPresent(u -> {
+            AUDIT_LOGGER.warn("Registration attempt with existing email: {}", email);
+            LOGGER.warn("Registration failed - user already exists: {}", email);
             throw new IllegalArgumentException("User already exists");
         });
+
         User user = new User();
         user.setEmail(email);
         user.setName(name);
         user.setPasswordHash(passwordEncoder.encode(rawPassword));
         user.addRole(SecurityConstants.ROLE_USER);

-        userRepository.save(user);
+        User savedUser = userRepository.save(user);
+
+        AUDIT_LOGGER.info("New user registered: email={}, name={}, userId={}", email, name, savedUser.getId());
+        LOGGER.info("User registered successfully: email={}, userId={}", email, savedUser.getId());
     }
 }
Index: src/main/java/org/apolenkov/application/service/news/NewsService.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/org/apolenkov/application/service/news/NewsService.java b/src/main/java/org/apolenkov/application/service/news/NewsService.java
--- a/src/main/java/org/apolenkov/application/service/news/NewsService.java	(revision 132c2c29773f5f4949b3855c362e338d983d3cd4)
+++ b/src/main/java/org/apolenkov/application/service/news/NewsService.java	(date 1760129814195)
@@ -6,6 +6,8 @@
 import org.apolenkov.application.domain.port.NewsRepository;
 import org.apolenkov.application.domain.usecase.NewsUseCase;
 import org.apolenkov.application.model.News;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 import org.springframework.stereotype.Service;
 import org.springframework.transaction.annotation.Transactional;

@@ -16,6 +18,9 @@
 @Transactional
 public class NewsService implements NewsUseCase {

+    private static final Logger LOGGER = LoggerFactory.getLogger(NewsService.class);
+    private static final Logger AUDIT_LOGGER = LoggerFactory.getLogger("org.apolenkov.application.audit");
+
     private final NewsRepository newsRepository;

     /**
@@ -47,9 +52,15 @@
      */
     @Override
     public void createNews(final String title, final String content, final String author) {
+        LOGGER.debug("Creating news: title='{}', author={}", title, author);
+
         validate(title, content);
+
         News news = new News(null, title, content, author, LocalDateTime.now());
         newsRepository.save(news);
+
+        AUDIT_LOGGER.info("News created: title='{}', author={}, contentLength={}", title, author, content.length());
+        LOGGER.info("News created successfully: title='{}', author={}", title, author);
     }

     /**
@@ -63,19 +74,28 @@
      */
     @Override
     public void updateNews(final long id, final String title, final String content, final String author) {
+        LOGGER.debug("Updating news: id={}, title='{}'", id, title);
+
         Optional<News> existingOpt = newsRepository.findById(id);
         if (existingOpt.isEmpty()) {
+            LOGGER.warn("Attempted to update non-existent news: id={}", id);
             throw new IllegalArgumentException("News not found with id: " + id);
         }
+
         validate(title, content);

         News existing = existingOpt.get();
+        String oldTitle = existing.getTitle();
+
         existing.setTitle(title);
         existing.setContent(content);
         existing.setAuthor(author);
         existing.setUpdatedAt(LocalDateTime.now());

         newsRepository.save(existing);
+
+        AUDIT_LOGGER.info("News updated: id={}, titleChanged='{}' -> '{}', author={}", id, oldTitle, title, author);
+        LOGGER.info("News updated successfully: id={}, title='{}'", id, title);
     }

     /**
@@ -85,7 +105,19 @@
      */
     @Override
     public void deleteNews(final long id) {
+        LOGGER.debug("Deleting news: id={}", id);
+
+        Optional<News> newsOpt = newsRepository.findById(id);
+        if (newsOpt.isEmpty()) {
+            LOGGER.warn("Attempted to delete non-existent news: id={}", id);
+            return;
+        }
+
+        News news = newsOpt.get();
         newsRepository.deleteById(id);
+
+        AUDIT_LOGGER.warn("News deleted: id={}, title='{}', author={}", id, news.getTitle(), news.getAuthor());
+        LOGGER.info("News deleted successfully: id={}, title='{}'", id, news.getTitle());
     }

     /**
Index: src/main/java/org/apolenkov/application/infrastructure/repository/jdbc/adapter/NewsJdbcAdapter.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/org/apolenkov/application/infrastructure/repository/jdbc/adapter/NewsJdbcAdapter.java b/src/main/java/org/apolenkov/application/infrastructure/repository/jdbc/adapter/NewsJdbcAdapter.java
--- a/src/main/java/org/apolenkov/application/infrastructure/repository/jdbc/adapter/NewsJdbcAdapter.java	(revision 132c2c29773f5f4949b3855c362e338d983d3cd4)
+++ b/src/main/java/org/apolenkov/application/infrastructure/repository/jdbc/adapter/NewsJdbcAdapter.java	(date 1760197282072)
@@ -2,6 +2,8 @@

 import java.sql.Timestamp;
 import java.time.LocalDateTime;
+import java.util.ArrayList;
+import java.util.Collection;
 import java.util.List;
 import java.util.Optional;
 import org.apolenkov.application.domain.port.NewsRepository;
@@ -128,13 +130,16 @@
             throw new IllegalArgumentException("News cannot be null");
         }

-        LOGGER.debug("Saving news: {}", news.getTitle());
+        boolean isNew = news.getId() == null;
+        LOGGER.debug("Saving news: title='{}', isNew={}", news.getTitle(), isNew);
+
         try {
-            if (news.getId() == null) {
+            if (isNew) {
                 createNews(news);
             } else {
                 updateNews(news);
             }
+            LOGGER.debug("News saved: id={}, title='{}', isNew={}", news.getId(), news.getTitle(), isNew);
         } catch (DataAccessException e) {
             throw new NewsPersistenceException("Failed to save news: " + news.getTitle(), e);
         }
@@ -152,6 +157,8 @@
             int deleted = jdbcTemplate.update(NewsSqlQueries.DELETE_NEWS, id);
             if (deleted == 0) {
                 LOGGER.warn("No news found with ID: {}", id);
+            } else {
+                LOGGER.debug("News deleted from database: id={}", id);
             }
         } catch (DataAccessException e) {
             throw new NewsPersistenceException("Failed to delete news by ID: " + id, e);
@@ -203,4 +210,53 @@
                 LocalDateTime.now(), // Update timestamp
                 news.getId());
     }
+
+    /**
+     * Saves multiple news items in batch operation.
+     *
+     * @param items collection of news items to save
+     */
+    @Override
+    public void saveAll(final Collection<News> items) {
+        if (items == null || items.isEmpty()) {
+            return;
+        }
+
+        LOGGER.debug("Batch saving {} news items", items.size());
+
+        try {
+            LocalDateTime now = LocalDateTime.now();
+
+            // Batch insert new items
+            List<News> newItems = items.stream().filter(n -> n.getId() == null).toList();
+
+            if (!newItems.isEmpty()) {
+                List<Object[]> batchArgs = new ArrayList<>(newItems.size());
+                for (News news : newItems) {
+                    batchArgs.add(
+                            new Object[] {news.getTitle(), news.getContent(), news.getAuthor(), Timestamp.valueOf(now)
+                            });
+                }
+                jdbcTemplate.batchUpdate(NewsSqlQueries.INSERT_NEWS, batchArgs);
+            }
+
+            // Batch update existing items (rare case)
+            List<News> existingItems =
+                    items.stream().filter(n -> n.getId() != null).toList();
+
+            if (!existingItems.isEmpty()) {
+                List<Object[]> batchArgs = new ArrayList<>(existingItems.size());
+                for (News news : existingItems) {
+                    batchArgs.add(new Object[] {
+                        news.getTitle(), news.getContent(), news.getAuthor(), Timestamp.valueOf(now), news.getId()
+                    });
+                }
+                jdbcTemplate.batchUpdate(NewsSqlQueries.UPDATE_NEWS, batchArgs);
+            }
+
+            LOGGER.debug("Batch saved {} news items successfully", items.size());
+        } catch (DataAccessException e) {
+            throw new NewsPersistenceException("Failed to batch save news items", e);
+        }
+    }
 }
Index: src/main/java/org/apolenkov/application/service/user/UserUseCaseService.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/org/apolenkov/application/service/user/UserUseCaseService.java b/src/main/java/org/apolenkov/application/service/user/UserUseCaseService.java
--- a/src/main/java/org/apolenkov/application/service/user/UserUseCaseService.java	(revision 132c2c29773f5f4949b3855c362e338d983d3cd4)
+++ b/src/main/java/org/apolenkov/application/service/user/UserUseCaseService.java	(date 1760195528840)
@@ -2,6 +2,7 @@

 import java.util.List;
 import java.util.Optional;
+import org.apolenkov.application.config.cache.RequestScopedUserCache;
 import org.apolenkov.application.domain.port.UserRepository;
 import org.apolenkov.application.domain.usecase.UserUseCase;
 import org.apolenkov.application.model.User;
@@ -21,36 +22,42 @@
 public class UserUseCaseService implements UserUseCase {

     private static final Logger LOGGER = LoggerFactory.getLogger(UserUseCaseService.class);
+    private static final Logger AUDIT_LOGGER = LoggerFactory.getLogger("org.apolenkov.application.audit");

     private final UserRepository userRepository;
+    private final RequestScopedUserCache userCache;

     /**
-     * Creates a new UserUseCaseService with the required repository dependency.
+     * Creates a new UserUseCaseService with the required dependencies.
      *
      * @param userRepositoryValue the repository for user persistence operations (non-null)
-     * @throws IllegalArgumentException if userRepository is null
+     * @param userCacheValue request-scoped cache for current user (non-null)
+     * @throws IllegalArgumentException if any dependency is null
      */
-    public UserUseCaseService(final UserRepository userRepositoryValue) {
+    public UserUseCaseService(final UserRepository userRepositoryValue, final RequestScopedUserCache userCacheValue) {
         if (userRepositoryValue == null) {
             throw new IllegalArgumentException("UserRepository cannot be null");
         }
+        if (userCacheValue == null) {
+            throw new IllegalArgumentException("RequestScopedUserCache cannot be null");
+        }
         this.userRepository = userRepositoryValue;
+        this.userCache = userCacheValue;
     }

     /**
-     * Gets all users in the system with caching.
+     * Gets all users in the system.
      *
      * @return a list of all users in the system, never null (maybe empty)
      */
     @Override
     @Transactional(readOnly = true)
     public List<User> getAllUsers() {
-        LOGGER.debug("Retrieving all users from database");
         return userRepository.findAll();
     }

     /**
-     * Gets a specific user by their unique identifier with caching.
+     * Gets a specific user by their unique identifier.
      *
      * @param id the unique identifier of the user to retrieve
      * @return an Optional containing the user if found, empty otherwise
@@ -58,7 +65,6 @@
     @Override
     @Transactional(readOnly = true)
     public Optional<User> getUserById(final long id) {
-        LOGGER.debug("Retrieving user by ID: {}", id);
         return userRepository.findById(id);
     }

@@ -72,23 +78,46 @@
      */
     @Override
     @Transactional(readOnly = true)
+    @SuppressWarnings("java:S2139") // Security audit requires logging before rethrow (OWASP compliance)
     public User getCurrentUser() {
+        User cachedUser = userCache.get();
+        if (cachedUser != null) {
+            return cachedUser;
+        }
+
         Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
         if (authentication == null) {
+            AUDIT_LOGGER.warn("Unauthenticated access attempt to getCurrentUser()");
+            LOGGER.warn("Attempted to get current user without authentication");
             throw new IllegalStateException("Unauthenticated");
         }

         Object principal = authentication.getPrincipal();
         if (principal == null) {
+            AUDIT_LOGGER.error("Authenticated principal is null");
+            LOGGER.error("Authentication principal is null");
             throw new IllegalStateException("Authenticated principal is null");
         }

         String username = getUsername(principal);

-        return userRepository
-                .findByEmail(username)
-                .orElseThrow(
-                        () -> new IllegalStateException("Authenticated principal has no domain user: " + username));
+        try {
+            User user = userRepository.findByEmail(username).orElseThrow(() -> {
+                AUDIT_LOGGER.error("Authenticated principal has no domain user: username={}", username);
+                LOGGER.error("Domain user not found for authenticated principal: {}", username);
+                return new IllegalStateException("Authenticated principal has no domain user: " + username);
+            });
+
+            // Cache for current request to avoid repeated database calls
+            userCache.set(user);
+
+            LOGGER.debug("Current user retrieved from database: userId={}, email={}", user.getId(), user.getEmail());
+            return user;
+        } catch (Exception e) {
+            // S2139: Intentionally logging before rethrow for security audit trail (OWASP compliance)
+            LOGGER.error("Error retrieving current user: username={}", username, e);
+            throw e;
+        }
     }

     private String getUsername(final Object principal) {
Index: src/main/java/org/apolenkov/application/service/stats/StatsService.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/org/apolenkov/application/service/stats/StatsService.java b/src/main/java/org/apolenkov/application/service/stats/StatsService.java
--- a/src/main/java/org/apolenkov/application/service/stats/StatsService.java	(revision 132c2c29773f5f4949b3855c362e338d983d3cd4)
+++ b/src/main/java/org/apolenkov/application/service/stats/StatsService.java	(date 1760195528820)
@@ -1,12 +1,15 @@
 package org.apolenkov.application.service.stats;

 import java.time.LocalDate;
+import java.util.Collection;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
 import org.apolenkov.application.domain.dto.SessionStatsDto;
 import org.apolenkov.application.domain.port.StatsRepository;
 import org.apolenkov.application.domain.usecase.StatsUseCase;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 import org.springframework.stereotype.Service;
 import org.springframework.transaction.annotation.Transactional;

@@ -16,6 +19,9 @@
 @Service
 public class StatsService implements StatsUseCase {

+    private static final Logger LOGGER = LoggerFactory.getLogger(StatsService.class);
+    private static final Logger AUDIT_LOGGER = LoggerFactory.getLogger("org.apolenkov.application.audit");
+
     private final StatsRepository statsRepository;

     /**
@@ -36,13 +42,32 @@
     @Override
     @Transactional
     public void recordSession(final SessionStatsDto sessionData) {
+        LOGGER.debug(
+                "Recording session: deckId={}, viewed={}, correct={}, hard={}",
+                sessionData.deckId(),
+                sessionData.viewed(),
+                sessionData.correct(),
+                sessionData.hard());
+
         // Early return if no cards were viewed (including negative values)
         if (sessionData.viewed() <= 0) {
+            LOGGER.warn("Skipped recording session with invalid viewed count: {}", sessionData.viewed());
             return;
         }

         LocalDate today = LocalDate.now();
         statsRepository.appendSession(sessionData, today);
+
+        LOGGER.info(
+                "Session recorded: deckId={}, viewed={}, correct={}, hard={}, durationMs={}, knownDelta={}",
+                sessionData.deckId(),
+                sessionData.viewed(),
+                sessionData.correct(),
+                sessionData.hard(),
+                sessionData.sessionDurationMs(),
+                sessionData.knownCardIdsDelta() != null
+                        ? sessionData.knownCardIdsDelta().size()
+                        : 0);
     }

     /**
@@ -99,6 +124,27 @@
         return statsRepository.getKnownCardIds(deckId);
     }

+    /**
+     * Retrieves known card IDs for multiple decks in single database query.
+     *
+     * @param deckIds collection of deck IDs to retrieve known cards for
+     * @return map of deck ID to set of known card IDs (empty map if deckIds is empty)
+     */
+    @Override
+    @Transactional(readOnly = true)
+    public Map<Long, Set<Long>> getKnownCardIdsBatch(final Collection<Long> deckIds) {
+        if (deckIds == null || deckIds.isEmpty()) {
+            LOGGER.debug("getKnownCardIdsBatch called with empty collection, returning empty map");
+            return Map.of();
+        }
+
+        LOGGER.debug("Batch retrieving known cards for {} decks", deckIds.size());
+        Map<Long, Set<Long>> result = statsRepository.getKnownCardIdsBatch(deckIds);
+        LOGGER.debug("Batch retrieval completed: {} decks have known cards", result.size());
+
+        return result;
+    }
+
     /**
      * Sets knowledge status of specific card in deck.
      * Updates knowledge status of card, marking it as either known or unknown
@@ -111,7 +157,11 @@
     @Override
     @Transactional
     public void setCardKnown(final long deckId, final long cardId, final boolean known) {
+        LOGGER.debug("Setting card {} as {} for deck {}", cardId, known ? "KNOWN" : "UNKNOWN", deckId);
+
         statsRepository.setCardKnown(deckId, cardId, known);
+
+        LOGGER.info("Card marked as {} in deck {}: cardId={}", known ? "known" : "unknown", deckId, cardId);
     }

     /**
@@ -123,7 +173,14 @@
     @Override
     @Transactional
     public void resetDeckProgress(final long deckId) {
+        LOGGER.debug("Resetting progress for deck: {}", deckId);
+
+        int knownCardsBefore = statsRepository.getKnownCardIds(deckId).size();
+
         statsRepository.resetDeckProgress(deckId);
+
+        AUDIT_LOGGER.warn("Deck progress reset: deckId={}, knownCardsCleared={}", deckId, knownCardsBefore);
+        LOGGER.info("Deck progress reset successfully: deckId={}, cleared {} known cards", deckId, knownCardsBefore);
     }

     /**
Index: src/main/java/org/apolenkov/application/infrastructure/repository/jdbc/adapter/UserJdbcAdapter.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/org/apolenkov/application/infrastructure/repository/jdbc/adapter/UserJdbcAdapter.java b/src/main/java/org/apolenkov/application/infrastructure/repository/jdbc/adapter/UserJdbcAdapter.java
--- a/src/main/java/org/apolenkov/application/infrastructure/repository/jdbc/adapter/UserJdbcAdapter.java	(revision 132c2c29773f5f4949b3855c362e338d983d3cd4)
+++ b/src/main/java/org/apolenkov/application/infrastructure/repository/jdbc/adapter/UserJdbcAdapter.java	(date 1760199252351)
@@ -1,10 +1,16 @@
 package org.apolenkov.application.infrastructure.repository.jdbc.adapter;

+import java.sql.PreparedStatement;
+import java.sql.Statement;
 import java.sql.Timestamp;
+import java.time.LocalDateTime;
+import java.util.ArrayList;
+import java.util.Collection;
 import java.util.HashSet;
 import java.util.List;
 import java.util.Optional;
 import java.util.Set;
+import org.apolenkov.application.config.cache.CacheConfiguration;
 import org.apolenkov.application.domain.port.UserRepository;
 import org.apolenkov.application.infrastructure.repository.jdbc.dto.UserDto;
 import org.apolenkov.application.infrastructure.repository.jdbc.exception.UserPersistenceException;
@@ -13,10 +19,14 @@
 import org.apolenkov.application.model.User;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
+import org.springframework.cache.annotation.CacheEvict;
+import org.springframework.cache.annotation.Cacheable;
 import org.springframework.context.annotation.Profile;
 import org.springframework.dao.DataAccessException;
 import org.springframework.jdbc.core.JdbcTemplate;
 import org.springframework.jdbc.core.RowMapper;
+import org.springframework.jdbc.support.GeneratedKeyHolder;
+import org.springframework.jdbc.support.KeyHolder;
 import org.springframework.stereotype.Repository;

 /**
@@ -50,6 +60,32 @@
                 new HashSet<>() // Roles will be loaded separately
                 );
     };
+
+    /**
+     * RowMapper for UserDto with roles (optimized single query).
+     * Extracts user data and roles from a single result set using PostgreSQL array.
+     */
+    private static final RowMapper<UserDto> USER_WITH_ROLES_ROW_MAPPER = (rs, rowNum) -> {
+        Long id = rs.getLong("id");
+        String email = rs.getString("email");
+        String passwordHash = rs.getString("password_hash");
+        String name = rs.getString("name");
+        Timestamp createdAt = rs.getTimestamp("created_at");
+
+        // Extract roles from PostgreSQL array
+        java.sql.Array rolesArray = rs.getArray("roles");
+        Set<String> roles = new HashSet<>();
+        if (rolesArray != null) {
+            String[] rolesData = (String[]) rolesArray.getArray();
+            if (rolesData != null) {
+                roles.addAll(List.of(rolesData));
+            }
+        }
+
+        return UserDto.forExistingUser(
+                id, email, passwordHash, name, createdAt != null ? createdAt.toLocalDateTime() : null, roles);
+    };
+
     /**
      * RowMapper for user roles.
      */
@@ -105,6 +141,7 @@

     /**
      * Retrieves user by unique identifier.
+     * Uses optimized single query with JOIN to fetch user and roles together.
      *
      * @param id unique identifier of user
      * @return Optional containing user if found
@@ -113,13 +150,13 @@
     public Optional<User> findById(final long id) {
         LOGGER.debug("Retrieving user by ID: {}", id);
         try {
-            List<UserDto> users = jdbcTemplate.query(UserSqlQueries.SELECT_USER_BY_ID, USER_ROW_MAPPER, id);
+            List<UserDto> users =
+                    jdbcTemplate.query(UserSqlQueries.SELECT_USER_WITH_ROLES_BY_ID, USER_WITH_ROLES_ROW_MAPPER, id);
             if (users.isEmpty()) {
                 return Optional.empty();
             }

-            UserDto userDto = loadUserRoles(users.getFirst());
-            return Optional.of(toModel(userDto));
+            return Optional.of(toModel(users.getFirst()));
         } catch (DataAccessException e) {
             throw new UserRetrievalException("Failed to retrieve user by ID: " + id, e);
         }
@@ -127,26 +164,29 @@

     /**
      * Retrieves user by email address.
+     * Uses optimized single query with JOIN to fetch user and roles together.
+     * Results are cached using Caffeine cache with 30-minute TTL.
      *
      * @param email email address of user
      * @return Optional containing user if found
      * @throws IllegalArgumentException if email is null or empty
      */
     @Override
+    @Cacheable(value = CacheConfiguration.USER_BY_EMAIL_CACHE, key = "#email", unless = "#result.isEmpty()")
     public Optional<User> findByEmail(final String email) {
         if (email == null || email.trim().isEmpty()) {
             throw new IllegalArgumentException("Email cannot be null or empty");
         }

-        LOGGER.debug("Retrieving user by email: {}", email);
+        LOGGER.debug("Retrieving user by email from database: {}", email);
         try {
-            List<UserDto> users = jdbcTemplate.query(UserSqlQueries.SELECT_USER_BY_EMAIL, USER_ROW_MAPPER, email);
+            List<UserDto> users = jdbcTemplate.query(
+                    UserSqlQueries.SELECT_USER_WITH_ROLES_BY_EMAIL, USER_WITH_ROLES_ROW_MAPPER, email);
             if (users.isEmpty()) {
                 return Optional.empty();
             }

-            UserDto userDto = loadUserRoles(users.getFirst());
-            return Optional.of(toModel(userDto));
+            return Optional.of(toModel(users.getFirst()));
         } catch (DataAccessException e) {
             throw new UserRetrievalException("Failed to retrieve user by email: " + email, e);
         }
@@ -154,24 +194,27 @@

     /**
      * Saves user to database.
+     * Evicts user from cache by email to ensure consistency.
      *
      * @param user user to save
      * @return saved user with updated fields
      * @throws IllegalArgumentException if user is null
      */
     @Override
+    @CacheEvict(value = CacheConfiguration.USER_BY_EMAIL_CACHE, key = "#user.email")
     public User save(final User user) {
         if (user == null) {
             throw new IllegalArgumentException("User cannot be null");
         }

-        LOGGER.debug("Saving user: {}", user.getEmail());
+        boolean isNew = user.getId() == null;
+        LOGGER.debug("Saving user: email={}, isNew={}", user.getEmail(), isNew);
+
         try {
-            if (user.getId() == null) {
-                return createUser(user);
-            } else {
-                return updateUser(user);
-            }
+            User saved = isNew ? createUser(user) : updateUser(user);
+            LOGGER.debug(
+                    "User saved: id={}, email={}, isNew={}, cache evicted", saved.getId(), saved.getEmail(), isNew);
+            return saved;
         } catch (DataAccessException e) {
             throw new UserPersistenceException("Failed to save user: " + user.getEmail(), e);
         }
@@ -179,10 +222,12 @@

     /**
      * Deletes user by unique identifier.
+     * Clears entire user cache to ensure consistency.
      *
      * @param id unique identifier of user to delete
      */
     @Override
+    @CacheEvict(value = CacheConfiguration.USER_BY_EMAIL_CACHE, allEntries = true)
     public void deleteById(final long id) {
         LOGGER.debug("Deleting user by ID: {}", id);
         try {
@@ -193,6 +238,8 @@
             int deleted = jdbcTemplate.update(UserSqlQueries.DELETE_USER, id);
             if (deleted == 0) {
                 LOGGER.warn("No user found with ID: {}", id);
+            } else {
+                LOGGER.debug("User deleted from database: id={}, cache cleared", id);
             }
         } catch (DataAccessException e) {
             throw new UserPersistenceException("Failed to delete user by ID: " + id, e);
@@ -279,4 +326,110 @@
         return UserDto.forExistingUser(
                 userDto.id(), userDto.email(), userDto.passwordHash(), userDto.name(), userDto.createdAt(), roles);
     }
+
+    /**
+     * Saves multiple users in batch operation for better performance.
+     * Uses batch insert for new users only.
+     *
+     * @param users collection of users to save
+     * @return list of saved users with generated IDs
+     */
+    @Override
+    public List<User> saveAll(final Collection<User> users) {
+        if (users == null || users.isEmpty()) {
+            return List.of();
+        }
+
+        LOGGER.debug("Batch saving {} users", users.size());
+        List<User> savedUsers = new ArrayList<>(users.size());
+
+        try {
+            // Process only new users for batch insert
+            List<User> newUsers = users.stream().filter(u -> u.getId() == null).toList();
+
+            if (!newUsers.isEmpty()) {
+                savedUsers.addAll(batchInsertUsers(newUsers));
+            }
+
+            // Update existing users one by one (rare case in seed data)
+            for (User user : users) {
+                if (user.getId() != null) {
+                    savedUsers.add(updateUser(user));
+                }
+            }
+
+            LOGGER.debug("Batch saved {} users successfully", savedUsers.size());
+            return savedUsers;
+        } catch (DataAccessException e) {
+            throw new UserPersistenceException("Failed to batch save users", e);
+        }
+    }
+
+    /**
+     * Batch inserts new users into database.
+     * Uses ON CONFLICT to handle duplicate emails gracefully (for seed operations).
+     *
+     * @param newUsers list of new users without IDs
+     * @return list of created users with generated IDs
+     */
+    private List<User> batchInsertUsers(final List<User> newUsers) {
+        LocalDateTime now = LocalDateTime.now();
+        List<User> result = new ArrayList<>(newUsers.size());
+
+        // Batch insert users and collect generated IDs
+        List<Long> generatedIds = new ArrayList<>(newUsers.size());
+
+        for (User user : newUsers) {
+            KeyHolder keyHolder = new GeneratedKeyHolder();
+
+            jdbcTemplate.update(
+                    connection -> {
+                        PreparedStatement ps = connection.prepareStatement(
+                                UserSqlQueries.INSERT_USER_ON_CONFLICT_RETURNING_ID, Statement.RETURN_GENERATED_KEYS);
+                        ps.setString(1, user.getEmail());
+                        ps.setString(2, user.getPasswordHash());
+                        ps.setString(3, user.getName());
+                        ps.setTimestamp(4, Timestamp.valueOf(now));
+                        return ps;
+                    },
+                    keyHolder);
+
+            Number key = keyHolder.getKey();
+            if (key != null) {
+                generatedIds.add(key.longValue());
+            }
+        }
+
+        // Batch insert roles for all users (with conflict handling)
+        List<Object[]> roleBatchArgs = new ArrayList<>();
+        for (int i = 0; i < newUsers.size(); i++) {
+            User user = newUsers.get(i);
+            Long userId = generatedIds.get(i);
+
+            for (String role : user.getRoles()) {
+                roleBatchArgs.add(new Object[] {userId, role});
+            }
+        }
+
+        if (!roleBatchArgs.isEmpty()) {
+            jdbcTemplate.batchUpdate(UserSqlQueries.INSERT_USER_ROLE_ON_CONFLICT, roleBatchArgs);
+        }
+
+        // Build result users with generated IDs
+        for (int i = 0; i < newUsers.size(); i++) {
+            User user = newUsers.get(i);
+            Long generatedId = generatedIds.get(i);
+
+            User savedUser = new User();
+            savedUser.setId(generatedId);
+            savedUser.setEmail(user.getEmail());
+            savedUser.setName(user.getName());
+            savedUser.setPasswordHash(user.getPasswordHash());
+            savedUser.setRoles(new HashSet<>(user.getRoles()));
+
+            result.add(savedUser);
+        }
+
+        return result;
+    }
 }
Index: src/main/java/org/apolenkov/application/domain/usecase/StatsUseCase.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/org/apolenkov/application/domain/usecase/StatsUseCase.java b/src/main/java/org/apolenkov/application/domain/usecase/StatsUseCase.java
--- a/src/main/java/org/apolenkov/application/domain/usecase/StatsUseCase.java	(revision 132c2c29773f5f4949b3855c362e338d983d3cd4)
+++ b/src/main/java/org/apolenkov/application/domain/usecase/StatsUseCase.java	(date 1760194949877)
@@ -1,5 +1,6 @@
 package org.apolenkov.application.domain.usecase;

+import java.util.Collection;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
@@ -44,6 +45,14 @@
      */
     Set<Long> getKnownCardIds(long deckId);

+    /**
+     * Retrieves known card IDs for multiple decks in single operation.
+     *
+     * @param deckIds collection of deck IDs to retrieve known cards for
+     * @return map of deck ID to set of known card IDs (decks with no known cards may be absent)
+     */
+    Map<Long, Set<Long>> getKnownCardIdsBatch(Collection<Long> deckIds);
+
     /**
      * Sets knowledge status of specific card in deck.
      *
Index: src/main/java/org/apolenkov/application/infrastructure/repository/jdbc/adapter/FlashcardJdbcAdapter.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/org/apolenkov/application/infrastructure/repository/jdbc/adapter/FlashcardJdbcAdapter.java b/src/main/java/org/apolenkov/application/infrastructure/repository/jdbc/adapter/FlashcardJdbcAdapter.java
--- a/src/main/java/org/apolenkov/application/infrastructure/repository/jdbc/adapter/FlashcardJdbcAdapter.java	(revision 132c2c29773f5f4949b3855c362e338d983d3cd4)
+++ b/src/main/java/org/apolenkov/application/infrastructure/repository/jdbc/adapter/FlashcardJdbcAdapter.java	(date 1760197432674)
@@ -2,9 +2,12 @@

 import java.sql.Timestamp;
 import java.time.LocalDateTime;
+import java.util.Collection;
 import java.util.List;
+import java.util.Map;
 import java.util.Optional;
 import org.apolenkov.application.domain.port.FlashcardRepository;
+import org.apolenkov.application.infrastructure.repository.jdbc.batch.FlashcardBatchOperations;
 import org.apolenkov.application.infrastructure.repository.jdbc.dto.FlashcardDto;
 import org.apolenkov.application.infrastructure.repository.jdbc.exception.FlashcardPersistenceException;
 import org.apolenkov.application.infrastructure.repository.jdbc.exception.FlashcardRetrievalException;
@@ -30,6 +33,7 @@
 public class FlashcardJdbcAdapter implements FlashcardRepository {

     private static final Logger LOGGER = LoggerFactory.getLogger(FlashcardJdbcAdapter.class);
+
     /**
      * RowMapper for FlashcardDto.
      */
@@ -56,18 +60,25 @@
     };

     private final JdbcTemplate jdbcTemplate;
+    private final FlashcardBatchOperations batchOperations;

     /**
      * Creates adapter with JdbcTemplate dependency.
      *
      * @param jdbcTemplateValue the JdbcTemplate for database operations
+     * @param batchOperationsValue helper for batch operations
      * @throws IllegalArgumentException if jdbcTemplate is null
      */
-    public FlashcardJdbcAdapter(final JdbcTemplate jdbcTemplateValue) {
+    public FlashcardJdbcAdapter(
+            final JdbcTemplate jdbcTemplateValue, final FlashcardBatchOperations batchOperationsValue) {
         if (jdbcTemplateValue == null) {
             throw new IllegalArgumentException("JdbcTemplate cannot be null");
         }
+        if (batchOperationsValue == null) {
+            throw new IllegalArgumentException("BatchOperations cannot be null");
+        }
         this.jdbcTemplate = jdbcTemplateValue;
+        this.batchOperations = batchOperationsValue;
     }

     /**
@@ -143,13 +154,20 @@
             throw new IllegalArgumentException("Flashcard cannot be null");
         }

-        LOGGER.debug("Saving flashcard: {}", flashcard.getFrontText());
+        boolean isNew = flashcard.getId() == null;
+        LOGGER.debug("Saving flashcard: frontText='{}', isNew={}", flashcard.getFrontText(), isNew);
+
         try {
-            if (flashcard.getId() == null) {
+            if (isNew) {
                 createFlashcard(flashcard);
             } else {
                 updateFlashcard(flashcard);
             }
+            LOGGER.debug(
+                    "Flashcard saved: id={}, frontText='{}', isNew={}",
+                    flashcard.getId(),
+                    flashcard.getFrontText(),
+                    isNew);
         } catch (DataAccessException e) {
             throw new FlashcardPersistenceException("Failed to save flashcard: " + flashcard.getFrontText(), e);
         }
@@ -167,6 +185,8 @@
             int deleted = jdbcTemplate.update(FlashcardSqlQueries.DELETE_FLASHCARD, id);
             if (deleted == 0) {
                 LOGGER.warn("No flashcard found with ID: {}", id);
+            } else {
+                LOGGER.debug("Flashcard deleted from database: id={}", id);
             }
         } catch (DataAccessException e) {
             throw new FlashcardPersistenceException("Failed to delete flashcard by ID: " + id, e);
@@ -198,6 +218,37 @@
         }
     }

+    /**
+     * Counts flashcards for multiple decks in single query.
+     * Performance optimization using GROUP BY to avoid N+1 queries.
+     *
+     * @param deckIds collection of deck identifiers
+     * @return map of deck ID to flashcard count (only decks with flashcards are included)
+     */
+    @Override
+    public Map<Long, Long> countByDeckIds(final Collection<Long> deckIds) {
+        if (deckIds == null || deckIds.isEmpty()) {
+            return Map.of();
+        }
+
+        LOGGER.debug("Batch counting flashcards for {} decks using single query", deckIds.size());
+        try {
+            String sql = buildInClauseSql(deckIds.size());
+            Map<Long, Long> counts =
+                    jdbcTemplate.query(sql, ps -> setLongParameters(ps, deckIds), this::extractCountsByDeck);
+
+            Map<Long, Long> safeCounts = (counts != null) ? counts : Map.of();
+            LOGGER.debug(
+                    "Batch count completed: {} decks have flashcards (out of {} requested)",
+                    safeCounts.size(),
+                    deckIds.size());
+            return safeCounts;
+
+        } catch (DataAccessException e) {
+            throw new FlashcardRetrievalException("Failed to count flashcards for deck IDs: " + deckIds, e);
+        }
+    }
+
     /**
      * Deletes all flashcards belonging to a specific deck.
      *
@@ -274,4 +325,60 @@
                 LocalDateTime.now(), // Update timestamp
                 flashcard.getId());
     }
+
+    /**
+     * Builds SQL with IN clause placeholders.
+     *
+     * @param paramCount number of parameters for IN clause
+     * @return SQL with placeholders
+     */
+    private String buildInClauseSql(final int paramCount) {
+        String placeholders = "?,".repeat(Math.max(0, paramCount - 1)) + "?";
+        return String.format(FlashcardSqlQueries.COUNT_FLASHCARDS_BY_DECK_IDS_TEMPLATE, placeholders);
+    }
+
+    /**
+     * Sets long parameters in PreparedStatement.
+     *
+     * @param ps PreparedStatement to set parameters in
+     * @param values collection of long values
+     */
+    private void setLongParameters(final java.sql.PreparedStatement ps, final Collection<Long> values)
+            throws java.sql.SQLException {
+        int index = 1;
+        for (Long value : values) {
+            ps.setLong(index++, value);
+        }
+    }
+
+    /**
+     * Extracts flashcard counts by deck from ResultSet.
+     *
+     * @param rs ResultSet to extract from
+     * @return map of deck ID to flashcard count
+     */
+    private Map<Long, Long> extractCountsByDeck(final java.sql.ResultSet rs) throws java.sql.SQLException {
+        Map<Long, Long> results = new java.util.HashMap<>();
+        while (rs.next()) {
+            Long deckId = rs.getLong("deck_id");
+            Long count = rs.getLong("count");
+            results.put(deckId, count);
+        }
+        return results;
+    }
+
+    /**
+     * Saves multiple flashcards in batch operation for better performance.
+     * Delegates to batch operations helper for clean separation of concerns.
+     *
+     * @param flashcards collection of flashcards to save
+     */
+    @Override
+    public void saveAll(final Collection<Flashcard> flashcards) {
+        try {
+            batchOperations.saveAll(jdbcTemplate, flashcards);
+        } catch (DataAccessException e) {
+            throw new FlashcardPersistenceException("Failed to batch save flashcards", e);
+        }
+    }
 }
Index: docker-compose.yml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docker-compose.yml b/docker-compose.yml
--- a/docker-compose.yml	(revision 132c2c29773f5f4949b3855c362e338d983d3cd4)
+++ b/docker-compose.yml	(date 1760131511463)
@@ -4,8 +4,8 @@
     container_name: flashcards-postgres
     environment:
       POSTGRES_DB: flashcards
-      POSTGRES_USER: postgres
-      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
+      POSTGRES_USER: ${DB_USER}
+      POSTGRES_PASSWORD: ${DB_PASSWORD}
     ports:
       - "5432:5432"
     volumes:
Index: src/test/java/org/apolenkov/application/service/user/UserUseCaseServiceTest.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/test/java/org/apolenkov/application/service/user/UserUseCaseServiceTest.java b/src/test/java/org/apolenkov/application/service/user/UserUseCaseServiceTest.java
--- a/src/test/java/org/apolenkov/application/service/user/UserUseCaseServiceTest.java	(revision 132c2c29773f5f4949b3855c362e338d983d3cd4)
+++ b/src/test/java/org/apolenkov/application/service/user/UserUseCaseServiceTest.java	(date 1760185867392)
@@ -5,6 +5,7 @@

 import java.util.List;
 import java.util.Optional;
+import org.apolenkov.application.config.cache.RequestScopedUserCache;
 import org.apolenkov.application.domain.port.UserRepository;
 import org.apolenkov.application.model.User;
 import org.junit.jupiter.api.BeforeEach;
@@ -21,11 +22,14 @@
     @Mock
     private UserRepository userRepository;

+    @Mock
+    private RequestScopedUserCache userCache;
+
     private UserUseCaseService userUseCaseService;

     @BeforeEach
     void setUp() {
-        userUseCaseService = new UserUseCaseService(userRepository);
+        userUseCaseService = new UserUseCaseService(userRepository, userCache);
     }

     @Test
Index: Makefile
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Makefile b/Makefile
--- a/Makefile	(revision 132c2c29773f5f4949b3855c362e338d983d3cd4)
+++ b/Makefile	(date 1760205241608)
@@ -13,7 +13,7 @@
         code-quality code-quality-full code-quality-chars \
         coverage coverage-verify deps npm-install vaadin-prepare dev-setup quality-check \
         lint-css lint-css-fix spotless-check sonarlint \
-        spotbugs checkstyle vaadin-build-frontend erase seed
+        spotbugs checkstyle vaadin-build-frontend erase

 # =============================================================================
 # HELP
@@ -147,16 +147,8 @@
 	$(GRADLE) checkstyleMain checkstyleTest

 # =============================================================================
-# DATA SEEDING
+# DEVELOPMENT COMMANDS
 # =============================================================================
-dev: ## Start application in dev mode (demo data only)
-	@echo "🚀 Starting application in dev mode (demo data only)..."
-	@$(GRADLE) bootRun --args="--spring.profiles.active=dev"
-
-dev-seed: ## Start application with demo data and test data generation
-	@echo "🚀 Starting application with demo data and test data generation..."
-	@GENERATE_TEST_DATA=true $(GRADLE) bootRun --args="--spring.profiles.active=dev"
-
-dev-load: ## Start application with demo data and massive test data generation
-	@echo "🚀 Starting application with demo data and massive test data generation..."
-	@GENERATE_TEST_DATA=true $(GRADLE) bootRun --args="--spring.profiles.active=dev"
\ No newline at end of file
+dev: ## Start application (all config in .env)
+	@echo "Starting application..."
+	@$(GRADLE) bootRun --args="--spring.profiles.active=dev"
\ No newline at end of file
Index: src/main/java/org/apolenkov/application/views/deck/components/dialogs/DeckEditDialog.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/org/apolenkov/application/views/deck/components/dialogs/DeckEditDialog.java b/src/main/java/org/apolenkov/application/views/deck/components/dialogs/DeckEditDialog.java
--- a/src/main/java/org/apolenkov/application/views/deck/components/dialogs/DeckEditDialog.java	(revision 132c2c29773f5f4949b3855c362e338d983d3cd4)
+++ b/src/main/java/org/apolenkov/application/views/deck/components/dialogs/DeckEditDialog.java	(date 1760129814237)
@@ -28,7 +28,6 @@
 public class DeckEditDialog extends Dialog {

     private static final Logger LOGGER = LoggerFactory.getLogger(DeckEditDialog.class);
-    private static final Logger AUDIT_LOGGER = LoggerFactory.getLogger("org.apolenkov.application.audit");

     // Dependencies
     private final transient DeckUseCase deckUseCase;
@@ -161,23 +160,12 @@
         }

         try {
-            String originalTitle = deck.getTitle();
-            int originalDescLength =
-                    deck.getDescription() != null ? deck.getDescription().length() : 0;
-
             deck.setTitle(title);
             deck.setDescription(description);

             Deck saved = deckUseCase.saveDeck(deck);

-            AUDIT_LOGGER.info(
-                    "User edited deck '{}' (ID: {}) - Title changed: '{}' -> '{}', Description length: {} -> {}",
-                    saved.getTitle(),
-                    saved.getId(),
-                    originalTitle,
-                    saved.getTitle(),
-                    originalDescLength,
-                    saved.getDescription() != null ? saved.getDescription().length() : 0);
+            LOGGER.debug("Deck edited successfully: id={}, title='{}'", saved.getId(), saved.getTitle());

             NotificationHelper.showSuccessBottom(getTranslation(DeckConstants.DECK_EDIT_SUCCESS));
             close();
Index: src/main/java/org/apolenkov/application/service/user/JdbcUserDetailsService.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/org/apolenkov/application/service/user/JdbcUserDetailsService.java b/src/main/java/org/apolenkov/application/service/user/JdbcUserDetailsService.java
--- a/src/main/java/org/apolenkov/application/service/user/JdbcUserDetailsService.java	(revision 132c2c29773f5f4949b3855c362e338d983d3cd4)
+++ b/src/main/java/org/apolenkov/application/service/user/JdbcUserDetailsService.java	(date 1760196197288)
@@ -5,6 +5,8 @@
 import org.apolenkov.application.config.security.SecurityConstants;
 import org.apolenkov.application.domain.port.UserRepository;
 import org.apolenkov.application.model.User;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 import org.springframework.context.annotation.Profile;
 import org.springframework.security.core.GrantedAuthority;
 import org.springframework.security.core.authority.SimpleGrantedAuthority;
@@ -20,6 +22,9 @@
 @Profile({"dev", "prod", "test"})
 public class JdbcUserDetailsService implements UserDetailsService {

+    private static final Logger LOGGER = LoggerFactory.getLogger(JdbcUserDetailsService.class);
+    private static final Logger AUDIT_LOGGER = LoggerFactory.getLogger("org.apolenkov.application.audit");
+
     private final UserRepository userRepository;

     /**
@@ -37,27 +42,105 @@
      *
      * @param username the email address of the user to load (Spring Security uses email as username)
      * @return UserDetails object containing user authentication and authorization information
-     * @throws UsernameNotFoundException if no user exists with the specified email
-     * @throws IllegalStateException if the user exists but has no password hash
+     * @throws UsernameNotFoundException if authentication fails (generic message to prevent user enumeration)
      */
     @Override
+    @SuppressWarnings("java:S2139") // Security audit requires logging before rethrow (OWASP compliance)
     public UserDetails loadUserByUsername(final String username) throws UsernameNotFoundException {
+        // Validate username
         if (username == null || username.trim().isEmpty()) {
-            throw new UsernameNotFoundException("Username cannot be null or empty");
+            LOGGER.warn("Attempted to load user with null or empty username");
+            throw new UsernameNotFoundException("Bad credentials");
+        }
+
+        LOGGER.debug("Loading user details for username: {}", username);
+
+        try {
+            // Find user by email
+            User user = findUser(username).orElse(null);
+
+            // Validate user exists and has password hash
+            if (user == null || !hasValidPasswordHash(user)) {
+                if (user == null) {
+                    AUDIT_LOGGER.warn("Authentication failed: username={}", username);
+                    LOGGER.warn("Authentication failed for: {}", username);
+                } else {
+                    AUDIT_LOGGER.error("User has no password hash: userId={}, email={}", user.getId(), username);
+                    LOGGER.error("User has no password hash: {}", username);
+                }
+                // Generic error message to prevent user enumeration
+                throw new UsernameNotFoundException("Bad credentials");
+            }
+
+            Collection<? extends GrantedAuthority> authorities = mapAuthorities(user);
+
+            LOGGER.debug("User details loaded successfully: {}", username);
+            return buildUserDetails(user, authorities);
+
+        } catch (UsernameNotFoundException e) {
+            throw e;
+        } catch (Exception e) {
+            // S2139: Intentionally logging before rethrow for security audit trail (OWASP compliance)
+            logAuthenticationError(username, e);
+            throw new UsernameNotFoundException("Bad credentials");
         }
-        User user = userRepository
-                .findByEmail(username.trim())
-                .orElseThrow(() -> new UsernameNotFoundException("User not found: " + username));
-        Collection<? extends GrantedAuthority> authorities = user.getRoles().isEmpty()
-                ? List.of(new SimpleGrantedAuthority(SecurityConstants.ROLE_USER))
-                : user.getRoles().stream().map(SimpleGrantedAuthority::new).toList();
-        if (user.getPasswordHash() == null || user.getPasswordHash().isBlank()) {
-            throw new IllegalStateException("User has no password hash: " + username);
+    }
+
+    /**
+     * Finds user by email without throwing exceptions.
+     *
+     * @param username the email to search for
+     * @return Optional containing the user if found
+     */
+    private java.util.Optional<User> findUser(final String username) {
+        return userRepository.findByEmail(username.trim());
+    }
+
+    /**
+     * Checks if user has a valid password hash.
+     *
+     * @param user the user to validate
+     * @return true if user has valid password hash, false otherwise
+     */
+    private boolean hasValidPasswordHash(final User user) {
+        return user.getPasswordHash() != null && !user.getPasswordHash().isBlank();
+    }
+
+    /**
+     * Maps user roles to Spring Security authorities.
+     *
+     * @param user the user with roles
+     * @return collection of granted authorities
+     */
+    private Collection<? extends GrantedAuthority> mapAuthorities(final User user) {
+        if (user.getRoles().isEmpty()) {
+            return List.of(new SimpleGrantedAuthority(SecurityConstants.ROLE_USER));
         }
-        String password = user.getPasswordHash();
+        return user.getRoles().stream().map(SimpleGrantedAuthority::new).toList();
+    }
+
+    /**
+     * Builds Spring Security UserDetails from User.
+     *
+     * @param user the user entity
+     * @param authorities the granted authorities
+     * @return UserDetails for Spring Security
+     */
+    private UserDetails buildUserDetails(final User user, final Collection<? extends GrantedAuthority> authorities) {
         return org.springframework.security.core.userdetails.User.withUsername(user.getEmail())
-                .password(password)
+                .password(user.getPasswordHash())
                 .authorities(authorities)
                 .build();
     }
+
+    /**
+     * Logs authentication error to both audit and application logs.
+     *
+     * @param username the username that failed
+     * @param e the exception that occurred
+     */
+    private void logAuthenticationError(final String username, final Exception e) {
+        AUDIT_LOGGER.error("Error loading user details: username={}, error={}", username, e.getMessage());
+        LOGGER.error("Unexpected error loading user: {}", username, e);
+    }
 }
Index: src/main/java/org/apolenkov/application/views/deck/components/dialogs/CreateDeckDialog.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/org/apolenkov/application/views/deck/components/dialogs/CreateDeckDialog.java b/src/main/java/org/apolenkov/application/views/deck/components/dialogs/CreateDeckDialog.java
--- a/src/main/java/org/apolenkov/application/views/deck/components/dialogs/CreateDeckDialog.java	(revision 132c2c29773f5f4949b3855c362e338d983d3cd4)
+++ b/src/main/java/org/apolenkov/application/views/deck/components/dialogs/CreateDeckDialog.java	(date 1760129814237)
@@ -30,7 +30,6 @@
 public class CreateDeckDialog extends Dialog {

     private static final Logger LOGGER = LoggerFactory.getLogger(CreateDeckDialog.class);
-    private static final Logger AUDIT_LOGGER = LoggerFactory.getLogger("org.apolenkov.application.audit");

     // Dependencies
     private final transient DeckUseCase deckUseCase;
@@ -169,11 +168,7 @@

             Deck saved = deckUseCase.saveDeck(deck);

-            AUDIT_LOGGER.info(
-                    "User created new deck '{}' with {} characters description - Deck ID: {}",
-                    saved.getTitle(),
-                    saved.getDescription() != null ? saved.getDescription().length() : 0,
-                    saved.getId());
+            LOGGER.debug("Deck created successfully: id={}, title='{}'", saved.getId(), saved.getTitle());

             NotificationHelper.showSuccessBottom(getTranslation(DeckConstants.HOME_DECK_CREATED));
             close();
Index: src/main/java/org/apolenkov/application/views/core/error/ErrorDevInfo.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/org/apolenkov/application/views/core/error/ErrorDevInfo.java b/src/main/java/org/apolenkov/application/views/core/error/ErrorDevInfo.java
--- a/src/main/java/org/apolenkov/application/views/core/error/ErrorDevInfo.java	(revision 132c2c29773f5f4949b3855c362e338d983d3cd4)
+++ b/src/main/java/org/apolenkov/application/views/core/error/ErrorDevInfo.java	(date 1760126608880)
@@ -132,9 +132,9 @@
     /**
      * Updates the development info with error details and shows it if in dev profile.
      *
-     * @param state the error view state containing error information
+     * @param state the error state containing error information
      */
-    public void updateDevInfo(final ErrorViewState state) {
+    public void updateDevInfo(final ErrorView.ErrorState state) {
         if (!isDevProfile()) {
             devContainer.setVisible(false);
             return;
@@ -144,9 +144,9 @@

         // Sanitize error details for security
         String unknownText = getTranslation(CoreConstants.ERROR_UNKNOWN_KEY);
-        String safeErrorType = SanitizationUtils.sanitizeErrorDetail(state.getErrorType(), unknownText);
-        String safeErrorMessage = SanitizationUtils.sanitizeErrorDetail(state.getErrorMessage(), unknownText);
-        String safeErrorId = SanitizationUtils.sanitizeErrorDetail(state.getErrorId(), unknownText);
+        String safeErrorType = SanitizationUtils.sanitizeErrorDetail(state.errorType(), unknownText);
+        String safeErrorMessage = SanitizationUtils.sanitizeErrorDetail(state.errorMessage(), unknownText);
+        String safeErrorId = SanitizationUtils.sanitizeErrorDetail(state.errorId(), unknownText);

         errorTypeSpan.setText(
                 getTranslation(CoreConstants.ERROR_TYPE_KEY) + CoreConstants.SEPARATOR_COLON_SPACE + safeErrorType);
@@ -155,7 +155,7 @@
                 + safeErrorMessage);
         currentRouteSpan.setText(getTranslation(CoreConstants.ERROR_CURRENT_ROUTE_KEY)
                 + CoreConstants.SEPARATOR_COLON_SPACE
-                + state.getFromRoute());
+                + state.fromRoute());
         timestampSpan.setText(getTranslation(CoreConstants.ERROR_TIMESTAMP_KEY)
                 + CoreConstants.SEPARATOR_SPACE
                 + LocalDateTime.now().format(DateTimeFormatter.ofPattern(CoreConstants.DATETIME_PATTERN)));
Index: src/main/java/org/apolenkov/application/infrastructure/repository/jdbc/exception/StatsRetrievalException.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/org/apolenkov/application/infrastructure/repository/jdbc/exception/StatsRetrievalException.java b/src/main/java/org/apolenkov/application/infrastructure/repository/jdbc/exception/StatsRetrievalException.java
new file mode 100644
--- /dev/null	(date 1760185394712)
+++ b/src/main/java/org/apolenkov/application/infrastructure/repository/jdbc/exception/StatsRetrievalException.java	(date 1760185394712)
@@ -0,0 +1,17 @@
+package org.apolenkov.application.infrastructure.repository.jdbc.exception;
+
+/**
+ * Exception thrown when statistics retrieval operations fail.
+ */
+public class StatsRetrievalException extends RuntimeException {
+
+    /**
+     * Constructs a new statistics retrieval exception with the specified detail message and cause.
+     *
+     * @param message the detail message
+     * @param cause the cause
+     */
+    public StatsRetrievalException(final String message, final Throwable cause) {
+        super(message, cause);
+    }
+}
Index: src/main/java/org/apolenkov/application/views/practice/components/PracticeActions.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/org/apolenkov/application/views/practice/components/PracticeActions.java b/src/main/java/org/apolenkov/application/views/practice/components/PracticeActions.java
--- a/src/main/java/org/apolenkov/application/views/practice/components/PracticeActions.java	(revision 132c2c29773f5f4949b3855c362e338d983d3cd4)
+++ b/src/main/java/org/apolenkov/application/views/practice/components/PracticeActions.java	(date 1760122173749)
@@ -11,14 +11,20 @@
 /**
  * Actions component for practice view.
  * Manages practice action buttons (show answer, know, hard) and completion buttons.
+ * Uses visibility management to avoid component reuse issues.
  */
 public final class PracticeActions extends Composite<HorizontalLayout> {

-    // UI Components
+    // UI Components - Practice buttons
     private Button showAnswerButton;
     private Button knowButton;
     private Button hardButton;

+    // UI Components - Completion buttons (created dynamically)
+    private Button repeatButton;
+    private Button backToDeckButton;
+    private Button homeButton;
+
     /**
      * Creates a new PracticeActions component.
      */
@@ -40,6 +46,7 @@

     /**
      * Creates the main action buttons for practice.
+     * All buttons are added to the container immediately to avoid component reuse.
      *
      * @param container the container to add buttons to
      */
@@ -134,6 +141,7 @@

     /**
      * Shows completion buttons (optional repeat, back to deck, home).
+     * Hides practice buttons and shows completion buttons without removing from DOM.
      *
      * @param repeatHandler handler for repeat button (null if no failed cards)
      * @param backToDeckHandler handler for back to deck button
@@ -150,11 +158,50 @@
             throw new IllegalArgumentException("Home handler cannot be null");
         }

-        getContent().removeAll();
+        // Hide practice buttons instead of removing
+        hidePracticeButtons();
+
+        // Remove old completion buttons if they exist
+        removeCompletionButtons();
+
+        // Create and show new completion buttons
+        createCompletionButtons(repeatHandler, backToDeckHandler, homeHandler);
+    }
+
+    /**
+     * Resets to practice buttons state.
+     * Hides completion buttons and shows practice buttons without component reuse.
+     */
+    public void resetToPracticeButtons() {
+        // Remove completion buttons from DOM
+        removeCompletionButtons();
+
+        // Show practice buttons again
+        showQuestionState();
+    }

-        // Show repeat button only if there are failed cards to practice
+    /**
+     * Hides all practice buttons (show answer, know, hard).
+     */
+    private void hidePracticeButtons() {
+        showAnswerButton.setVisible(false);
+        knowButton.setVisible(false);
+        hardButton.setVisible(false);
+    }
+
+    /**
+     * Creates and adds completion buttons to the layout.
+     *
+     * @param repeatHandler handler for repeat button (null if no failed cards)
+     * @param backToDeckHandler handler for back to deck button
+     * @param homeHandler handler for home button
+     */
+    private void createCompletionButtons(
+            final Runnable repeatHandler, final Runnable backToDeckHandler, final Runnable homeHandler) {
+
+        // Create repeat button only if there are failed cards to practice
         if (repeatHandler != null) {
-            Button repeatButton = ButtonHelper.createButton(
+            repeatButton = ButtonHelper.createButton(
                     getTranslation(PracticeConstants.PRACTICE_REPEAT_HARD_KEY),
                     e -> repeatHandler.run(),
                     ButtonVariant.LUMO_ERROR,
@@ -162,21 +209,30 @@
             getContent().add(repeatButton);
         }

-        Button backToDeckButton = ButtonHelper.createButton(
+        backToDeckButton = ButtonHelper.createButton(
                 getTranslation(PracticeConstants.PRACTICE_BACK_TO_DECK_KEY), e -> backToDeckHandler.run());

-        Button homeButton = ButtonHelper.createButton(
+        homeButton = ButtonHelper.createButton(
                 getTranslation(PracticeConstants.PRACTICE_BACK_TO_DECKS_KEY), e -> homeHandler.run());

         getContent().add(backToDeckButton, homeButton);
     }

     /**
-     * Resets to practice buttons state.
+     * Removes completion buttons from the layout if they exist.
      */
-    public void resetToPracticeButtons() {
-        getContent().removeAll();
-        getContent().add(showAnswerButton, knowButton, hardButton);
-        showQuestionState();
+    private void removeCompletionButtons() {
+        if (repeatButton != null) {
+            getContent().remove(repeatButton);
+            repeatButton = null;
+        }
+        if (backToDeckButton != null) {
+            getContent().remove(backToDeckButton);
+            backToDeckButton = null;
+        }
+        if (homeButton != null) {
+            getContent().remove(homeButton);
+            homeButton = null;
+        }
     }
 }
Index: src/main/java/org/apolenkov/application/Application.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/org/apolenkov/application/Application.java b/src/main/java/org/apolenkov/application/Application.java
--- a/src/main/java/org/apolenkov/application/Application.java	(revision 132c2c29773f5f4949b3855c362e338d983d3cd4)
+++ b/src/main/java/org/apolenkov/application/Application.java	(date 1760205041130)
@@ -5,6 +5,7 @@
 import org.slf4j.LoggerFactory;
 import org.springframework.boot.SpringApplication;
 import org.springframework.boot.autoconfigure.SpringBootApplication;
+import org.springframework.boot.context.properties.ConfigurationPropertiesScan;

 /**
  * Main entry point for the Flashcards Spring Boot application.
@@ -13,6 +14,7 @@
  * All initialization logic is delegated to ApplicationInitializer.
  */
 @SpringBootApplication
+@ConfigurationPropertiesScan
 public final class Application {

     /**
Index: src/main/java/org/apolenkov/application/infrastructure/repository/jdbc/batch/FlashcardBatchOperations.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/org/apolenkov/application/infrastructure/repository/jdbc/batch/FlashcardBatchOperations.java b/src/main/java/org/apolenkov/application/infrastructure/repository/jdbc/batch/FlashcardBatchOperations.java
new file mode 100644
--- /dev/null	(date 1760197432598)
+++ b/src/main/java/org/apolenkov/application/infrastructure/repository/jdbc/batch/FlashcardBatchOperations.java	(date 1760197432598)
@@ -0,0 +1,152 @@
+package org.apolenkov.application.infrastructure.repository.jdbc.batch;
+
+import java.sql.Timestamp;
+import java.time.LocalDateTime;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.List;
+import org.apolenkov.application.infrastructure.repository.jdbc.sql.FlashcardSqlQueries;
+import org.apolenkov.application.model.Flashcard;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+import org.springframework.jdbc.core.JdbcTemplate;
+import org.springframework.stereotype.Component;
+
+/**
+ * Helper class for batch operations on flashcards.
+ * Separates batch logic from adapter for better maintainability.
+ */
+@Component
+public class FlashcardBatchOperations {
+
+    private static final Logger LOGGER = LoggerFactory.getLogger(FlashcardBatchOperations.class);
+    private static final int DEFAULT_BATCH_SIZE = 1000;
+
+    /**
+     * Performs batch save operations for flashcards.
+     *
+     * @param jdbcTemplate JDBC template for database operations
+     * @param flashcards collection of flashcards to save
+     */
+    public void saveAll(final JdbcTemplate jdbcTemplate, final Collection<Flashcard> flashcards) {
+        if (flashcards == null || flashcards.isEmpty()) {
+            return;
+        }
+
+        LOGGER.debug("Batch saving {} flashcards", flashcards.size());
+
+        // Separate new cards from updates
+        List<Flashcard> newCards =
+                flashcards.stream().filter(f -> f.getId() == null).toList();
+
+        List<Flashcard> existingCards =
+                flashcards.stream().filter(f -> f.getId() != null).toList();
+
+        // Batch insert new cards
+        if (!newCards.isEmpty()) {
+            batchInsert(jdbcTemplate, newCards);
+        }
+
+        // Batch update existing cards
+        if (!existingCards.isEmpty()) {
+            batchUpdate(jdbcTemplate, existingCards);
+        }
+
+        LOGGER.debug("Batch saved {} flashcards successfully", flashcards.size());
+    }
+
+    /**
+     * Batch inserts new flashcards in chunks for optimal performance.
+     *
+     * @param jdbcTemplate JDBC template for database operations
+     * @param newCards list of new flashcards
+     */
+    private void batchInsert(final JdbcTemplate jdbcTemplate, final List<Flashcard> newCards) {
+        LocalDateTime now = LocalDateTime.now();
+
+        // Process in chunks to avoid memory issues
+        for (int i = 0; i < newCards.size(); i += DEFAULT_BATCH_SIZE) {
+            int end = Math.min(i + DEFAULT_BATCH_SIZE, newCards.size());
+            List<Flashcard> chunk = newCards.subList(i, end);
+
+            List<Object[]> batchArgs = prepareBatchInsertArgs(chunk, now);
+            jdbcTemplate.batchUpdate(FlashcardSqlQueries.INSERT_FLASHCARD_RETURNING_ID, batchArgs);
+
+            logProgress(i, newCards.size());
+        }
+    }
+
+    /**
+     * Prepares batch arguments for insert operation.
+     *
+     * @param cards list of flashcards
+     * @param timestamp timestamp for created_at and updated_at
+     * @return list of batch arguments
+     */
+    private List<Object[]> prepareBatchInsertArgs(final List<Flashcard> cards, final LocalDateTime timestamp) {
+        List<Object[]> batchArgs = new ArrayList<>(cards.size());
+
+        for (Flashcard card : cards) {
+            batchArgs.add(new Object[] {
+                card.getDeckId(),
+                card.getFrontText(),
+                card.getBackText(),
+                card.getExample(),
+                card.getImageUrl(),
+                Timestamp.valueOf(timestamp),
+                Timestamp.valueOf(timestamp)
+            });
+        }
+
+        return batchArgs;
+    }
+
+    /**
+     * Batch updates existing flashcards.
+     *
+     * @param jdbcTemplate JDBC template for database operations
+     * @param existingCards list of flashcards to update
+     */
+    private void batchUpdate(final JdbcTemplate jdbcTemplate, final List<Flashcard> existingCards) {
+        LocalDateTime now = LocalDateTime.now();
+        List<Object[]> batchArgs = prepareBatchUpdateArgs(existingCards, now);
+        jdbcTemplate.batchUpdate(FlashcardSqlQueries.UPDATE_FLASHCARD, batchArgs);
+    }
+
+    /**
+     * Prepares batch arguments for update operation.
+     *
+     * @param cards list of flashcards
+     * @param timestamp timestamp for updated_at
+     * @return list of batch arguments
+     */
+    private List<Object[]> prepareBatchUpdateArgs(final List<Flashcard> cards, final LocalDateTime timestamp) {
+        List<Object[]> batchArgs = new ArrayList<>(cards.size());
+
+        for (Flashcard card : cards) {
+            batchArgs.add(new Object[] {
+                card.getDeckId(),
+                card.getFrontText(),
+                card.getBackText(),
+                card.getExample(),
+                card.getImageUrl(),
+                Timestamp.valueOf(timestamp),
+                card.getId()
+            });
+        }
+
+        return batchArgs;
+    }
+
+    /**
+     * Logs progress for large batch operations.
+     *
+     * @param processed number of processed items
+     * @param total total number of items
+     */
+    private void logProgress(final int processed, final int total) {
+        if ((processed / DEFAULT_BATCH_SIZE) % 10 == 0) {
+            LOGGER.debug("Processed {}/{} flashcards", Math.min(processed + DEFAULT_BATCH_SIZE, total), total);
+        }
+    }
+}
Index: src/main/java/org/apolenkov/application/views/practice/constants/PracticeConstants.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/org/apolenkov/application/views/practice/constants/PracticeConstants.java b/src/main/java/org/apolenkov/application/views/practice/constants/PracticeConstants.java
--- a/src/main/java/org/apolenkov/application/views/practice/constants/PracticeConstants.java	(revision 132c2c29773f5f4949b3855c362e338d983d3cd4)
+++ b/src/main/java/org/apolenkov/application/views/practice/constants/PracticeConstants.java	(date 1760127589917)
@@ -56,13 +56,6 @@
     public static final String KNOW_LABEL = "know";
     public static final String HARD_LABEL = "hard";

-    // Session Constants
-    public static final int MIN_SESSION_MINUTES = 1;
-    public static final double MIN_TOTAL_VIEWED = 1.0;
-    public static final long MIN_AVERAGE_SECONDS = 1L;
-    public static final int MAX_SESSION_MINUTES = Integer.MAX_VALUE;
-    public static final double MAX_TOTAL_VIEWED = Double.MAX_VALUE;
-
     // Private constructor to prevent instantiation
     private PracticeConstants() {
         throw new UnsupportedOperationException("Utility class");
Index: src/main/java/org/apolenkov/application/service/seed/DataGenerationException.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/org/apolenkov/application/service/seed/DataGenerationException.java b/src/main/java/org/apolenkov/application/service/seed/DataGenerationException.java
new file mode 100644
--- /dev/null	(date 1760197368997)
+++ b/src/main/java/org/apolenkov/application/service/seed/DataGenerationException.java	(date 1760197368997)
@@ -0,0 +1,17 @@
+package org.apolenkov.application.service.seed;
+
+/**
+ * Exception thrown when test data generation fails.
+ */
+public class DataGenerationException extends RuntimeException {
+
+    /**
+     * Constructs exception with message and cause.
+     *
+     * @param message error description
+     * @param cause underlying exception
+     */
+    public DataGenerationException(final String message, final Throwable cause) {
+        super(message, cause);
+    }
+}
Index: src/main/java/org/apolenkov/application/views/deck/components/detail/DeckActions.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/org/apolenkov/application/views/deck/components/detail/DeckActions.java b/src/main/java/org/apolenkov/application/views/deck/components/detail/DeckActions.java
--- a/src/main/java/org/apolenkov/application/views/deck/components/detail/DeckActions.java	(revision 132c2c29773f5f4949b3855c362e338d983d3cd4)
+++ b/src/main/java/org/apolenkov/application/views/deck/components/detail/DeckActions.java	(date 1760129814236)
@@ -20,7 +20,6 @@
 public final class DeckActions extends Composite<HorizontalLayout> {

     private static final Logger LOGGER = LoggerFactory.getLogger(DeckActions.class);
-    private static final Logger AUDIT_LOGGER = LoggerFactory.getLogger("org.apolenkov.application.audit");

     // UI Components
     private final Button practiceButton;
@@ -94,7 +93,7 @@
      */
     public Registration addPracticeClickListener(final ComponentEventListener<ClickEvent<Button>> listener) {
         return practiceButton.addClickListener(e -> {
-            logPracticeAction();
+            LOGGER.debug("Practice button clicked");
             listener.onComponentEvent(e);
         });
     }
@@ -107,7 +106,7 @@
      */
     public Registration addEditDeckClickListener(final ComponentEventListener<ClickEvent<Button>> listener) {
         return editDeckButton.addClickListener(e -> {
-            logEditAction();
+            LOGGER.debug("Edit deck button clicked");
             listener.onComponentEvent(e);
         });
     }
@@ -120,32 +119,8 @@
      */
     public Registration addDeleteDeckClickListener(final ComponentEventListener<ClickEvent<Button>> listener) {
         return deleteDeckButton.addClickListener(e -> {
-            logDeleteAction();
-            listener.onComponentEvent(e);
-        });
-    }
-
-    /**
-     * Logs practice action for audit purposes.
-     */
-    private void logPracticeAction() {
-        AUDIT_LOGGER.info("User clicked PRACTICE button - starting practice session");
-        LOGGER.debug("Practice button clicked");
-    }
-
-    /**
-     * Logs edit action for audit purposes.
-     */
-    private void logEditAction() {
-        AUDIT_LOGGER.info("User clicked EDIT button - opening deck edit dialog");
-        LOGGER.debug("Edit deck button clicked");
-    }
-
-    /**
-     * Logs delete action for audit purposes.
-     */
-    private void logDeleteAction() {
-        AUDIT_LOGGER.info("User clicked DELETE button - initiating deck deletion process");
-        LOGGER.debug("Delete deck button clicked");
+            LOGGER.debug("Delete deck button clicked");
+            listener.onComponentEvent(e);
+        });
     }
 }
Index: src/main/java/org/apolenkov/application/config/cache/RequestScopedUserCache.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/org/apolenkov/application/config/cache/RequestScopedUserCache.java b/src/main/java/org/apolenkov/application/config/cache/RequestScopedUserCache.java
new file mode 100644
--- /dev/null	(date 1760194949854)
+++ b/src/main/java/org/apolenkov/application/config/cache/RequestScopedUserCache.java	(date 1760194949854)
@@ -0,0 +1,56 @@
+package org.apolenkov.application.config.cache;
+
+import org.apolenkov.application.model.User;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+import org.springframework.stereotype.Component;
+import org.springframework.web.context.annotation.RequestScope;
+
+/**
+ * Request-scoped cache for current authenticated user.
+ */
+@Component
+@RequestScope
+public class RequestScopedUserCache {
+
+    private static final Logger LOGGER = LoggerFactory.getLogger(RequestScopedUserCache.class);
+
+    private User cachedUser;
+
+    /**
+     * Gets cached user or returns null if not cached yet.
+     *
+     * @return cached user or null
+     */
+    public User get() {
+        if (cachedUser != null) {
+            LOGGER.debug("Cache HIT: Returning cached user [userId={}]", cachedUser.getId());
+        } else {
+            LOGGER.debug("Cache MISS: No user in cache");
+        }
+        return cachedUser;
+    }
+
+    /**
+     * Caches user for current request scope.
+     *
+     * @param user user to cache
+     */
+    public void set(final User user) {
+        if (user == null) {
+            throw new IllegalArgumentException("User cannot be null");
+        }
+        this.cachedUser = user;
+        LOGGER.debug("User cached for current request [userId={}, email={}]", user.getId(), user.getEmail());
+    }
+
+    /**
+     * Clears cached user.
+     */
+    public void clear() {
+        if (cachedUser != null) {
+            LOGGER.debug("Cache cleared [userId={}]", cachedUser.getId());
+        }
+        this.cachedUser = null;
+    }
+}
Index: src/main/java/org/apolenkov/application/views/deck/components/detail/DeckGrid.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/org/apolenkov/application/views/deck/components/detail/DeckGrid.java b/src/main/java/org/apolenkov/application/views/deck/components/detail/DeckGrid.java
--- a/src/main/java/org/apolenkov/application/views/deck/components/detail/DeckGrid.java	(revision 132c2c29773f5f4949b3855c362e338d983d3cd4)
+++ b/src/main/java/org/apolenkov/application/views/deck/components/detail/DeckGrid.java	(date 1760129814219)
@@ -30,7 +30,6 @@
 public final class DeckGrid extends Composite<VerticalLayout> {

     private static final Logger LOGGER = LoggerFactory.getLogger(DeckGrid.class);
-    private static final Logger AUDIT_LOGGER = LoggerFactory.getLogger("org.apolenkov.application.audit");

     // Dependencies
     private final transient StatsService statsService;
@@ -115,21 +114,6 @@
             boolean known = statsService.isCardKnown(currentDeckId, flashcard.getId());
             LOGGER.debug("Toggling known status for card {}: {} -> {}", flashcard.getId(), known, !known);

-            // Audit log for learning progress
-            if (!known) {
-                AUDIT_LOGGER.info(
-                        "Card {} marked as KNOWN in deck {} - User learned: '{}'",
-                        flashcard.getId(),
-                        currentDeckId,
-                        flashcard.getFrontText());
-            } else {
-                AUDIT_LOGGER.info(
-                        "Card {} marked as UNKNOWN in deck {} - User forgot: '{}'",
-                        flashcard.getId(),
-                        currentDeckId,
-                        flashcard.getFrontText());
-            }
-
             statsService.setCardKnown(currentDeckId, flashcard.getId(), !known);
             applyFilter();
         }
@@ -140,13 +124,7 @@
      */
     private void handleResetProgress() {
         if (currentDeckId != null) {
-            LOGGER.info("Resetting progress for deck {}", currentDeckId);
-
-            // Audit log for progress reset
-            AUDIT_LOGGER.info(
-                    "User reset ALL progress for deck {} - {} cards marked as unknown",
-                    currentDeckId,
-                    allFlashcards != null ? allFlashcards.size() : 0);
+            LOGGER.debug("Resetting progress for deck {}", currentDeckId);

             statsService.resetDeckProgress(currentDeckId);
             applyFilter();
Index: src/main/java/org/apolenkov/application/service/auth/AuthService.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/org/apolenkov/application/service/auth/AuthService.java b/src/main/java/org/apolenkov/application/service/auth/AuthService.java
--- a/src/main/java/org/apolenkov/application/service/auth/AuthService.java	(revision 132c2c29773f5f4949b3855c362e338d983d3cd4)
+++ b/src/main/java/org/apolenkov/application/service/auth/AuthService.java	(date 1760184404612)
@@ -5,6 +5,8 @@
 import com.vaadin.flow.server.VaadinServletResponse;
 import jakarta.servlet.http.HttpServletRequest;
 import jakarta.servlet.http.HttpServletResponse;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
 import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;
 import org.springframework.security.core.Authentication;
@@ -20,6 +22,9 @@
 @Service
 public class AuthService {

+    private static final Logger LOGGER = LoggerFactory.getLogger(AuthService.class);
+    private static final Logger AUDIT_LOGGER = LoggerFactory.getLogger("org.apolenkov.application.audit");
+
     private final AuthenticationConfiguration authenticationConfiguration;

     /**
@@ -44,11 +49,24 @@
      * @param rawPassword plain text password for authentication
      * @throws IllegalArgumentException if authentication fails due to invalid credentials or invalid parameters
      */
+    @SuppressWarnings("java:S2139") // Security audit requires logging before rethrow (OWASP compliance)
     public void authenticateAndPersist(final String username, final String rawPassword) {
         validateCredentials(username, rawPassword);

-        Authentication auth = performAuthentication(username, rawPassword);
-        persistAuthenticationContext(auth);
+        LOGGER.debug("Attempting authentication for user: {}", username);
+
+        try {
+            Authentication auth = performAuthentication(username, rawPassword);
+            persistAuthenticationContext(auth);
+
+            AUDIT_LOGGER.info("User logged in successfully: {}", username);
+            LOGGER.info("Authentication successful for user: {}", username);
+        } catch (IllegalArgumentException e) {
+            // S2139: Intentionally logging before rethrow for security audit trail (OWASP compliance)
+            AUDIT_LOGGER.warn("Failed login attempt for user: {} - Reason: {}", username, e.getMessage());
+            LOGGER.warn("Authentication failed for user: {}", username);
+            throw e;
+        }
     }

     /**
Index: src/test/java/org/apolenkov/application/domain/dto/SessionStatsDtoTest.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/test/java/org/apolenkov/application/domain/dto/SessionStatsDtoTest.java b/src/test/java/org/apolenkov/application/domain/dto/SessionStatsDtoTest.java
--- a/src/test/java/org/apolenkov/application/domain/dto/SessionStatsDtoTest.java	(revision 132c2c29773f5f4949b3855c362e338d983d3cd4)
+++ b/src/test/java/org/apolenkov/application/domain/dto/SessionStatsDtoTest.java	(date 1760122796604)
@@ -14,7 +14,15 @@
     @Test
     @DisplayName("Should create valid session stats")
     void shouldCreateValidSessionStats() {
-        SessionStatsDto stats = SessionStatsDto.of(1L, 10, 8, 1, 60000L, 15000L, List.of(1L, 2L));
+        SessionStatsDto stats = SessionStatsDto.builder()
+                .deckId(1L)
+                .viewed(10)
+                .correct(8)
+                .hard(1)
+                .sessionDurationMs(60000L)
+                .totalAnswerDelayMs(15000L)
+                .knownCardIdsDelta(List.of(1L, 2L))
+                .build();

         assertThat(stats.deckId()).isEqualTo(1L);
         assertThat(stats.viewed()).isEqualTo(10);
@@ -31,7 +39,15 @@
     }

     private void createInvalidSessionStatsWithZeroValues() {
-        SessionStatsDto.of(1L, 0, 0, 0, 0L, 0L, Set.of());
+        SessionStatsDto.builder()
+                .deckId(1L)
+                .viewed(0)
+                .correct(0)
+                .hard(0)
+                .sessionDurationMs(0L)
+                .totalAnswerDelayMs(0L)
+                .knownCardIdsDelta(Set.of())
+                .build();
     }

     @Test
@@ -41,13 +57,29 @@
     }

     private void createInvalidSessionStatsWithZeroDeckId() {
-        SessionStatsDto.of(0L, 10, 8, 0, 0L, 0L, null);
+        SessionStatsDto.builder()
+                .deckId(0L)
+                .viewed(10)
+                .correct(8)
+                .hard(0)
+                .sessionDurationMs(0L)
+                .totalAnswerDelayMs(0L)
+                .knownCardIdsDelta(null)
+                .build();
     }

     @Test
     @DisplayName("Should handle null known card ids delta")
     void shouldHandleNullKnownCardIdsDelta() {
-        SessionStatsDto stats = SessionStatsDto.of(1L, 10, 8, 0, 60000L, 15000L, null);
+        SessionStatsDto stats = SessionStatsDto.builder()
+                .deckId(1L)
+                .viewed(10)
+                .correct(8)
+                .hard(0)
+                .sessionDurationMs(60000L)
+                .totalAnswerDelayMs(15000L)
+                .knownCardIdsDelta(null)
+                .build();

         assertThat(stats.knownCardIdsDelta()).isNull();
     }
Index: src/test/java/org/apolenkov/application/model/DeckTest.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/test/java/org/apolenkov/application/model/DeckTest.java b/src/test/java/org/apolenkov/application/model/DeckTest.java
--- a/src/test/java/org/apolenkov/application/model/DeckTest.java	(revision 132c2c29773f5f4949b3855c362e338d983d3cd4)
+++ b/src/test/java/org/apolenkov/application/model/DeckTest.java	(date 1760202400048)
@@ -235,8 +235,8 @@
     @Test
     @DisplayName("Should handle deck with unicode characters")
     void shouldHandleDeckWithUnicodeCharacters() {
-        String unicodeTitle = "Колода с русскими символами";
-        Deck deck = Deck.create(1L, unicodeTitle, "Описание");
+        String unicodeTitle = "Deck with unicode characters: 你好世界";
+        Deck deck = Deck.create(1L, unicodeTitle, "Test description");

         assertThat(deck.getTitle()).isEqualTo(unicodeTitle);
     }
Index: src/test/java/org/apolenkov/application/model/FlashcardTest.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/test/java/org/apolenkov/application/model/FlashcardTest.java b/src/test/java/org/apolenkov/application/model/FlashcardTest.java
--- a/src/test/java/org/apolenkov/application/model/FlashcardTest.java	(revision 132c2c29773f5f4949b3855c362e338d983d3cd4)
+++ b/src/test/java/org/apolenkov/application/model/FlashcardTest.java	(date 1760202400106)
@@ -230,7 +230,7 @@
     @Test
     @DisplayName("Should handle unicode characters in text")
     void shouldHandleUnicodeCharactersInText() {
-        String unicodeText = "Текст с русскими символами";
+        String unicodeText = "Text with unicode characters: 你好世界";
         testFlashcard.setFrontText(unicodeText);

         assertThat(testFlashcard.getFrontText()).isEqualTo(unicodeText);
Index: src/test/java/org/apolenkov/application/model/UserTest.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/test/java/org/apolenkov/application/model/UserTest.java b/src/test/java/org/apolenkov/application/model/UserTest.java
--- a/src/test/java/org/apolenkov/application/model/UserTest.java	(revision 132c2c29773f5f4949b3855c362e338d983d3cd4)
+++ b/src/test/java/org/apolenkov/application/model/UserTest.java	(date 1760202400164)
@@ -214,7 +214,7 @@
     @Test
     @DisplayName("Should handle user with unicode characters")
     void shouldHandleUserWithUnicodeCharacters() {
-        String unicodeName = "Пользователь с русскими символами";
+        String unicodeName = "User with unicode characters: 你好世界";
         testUser.setName(unicodeName);

         assertThat(testUser.getName()).isEqualTo(unicodeName);
Index: src/main/java/org/apolenkov/application/views/practice/pages/PracticeView.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/org/apolenkov/application/views/practice/pages/PracticeView.java b/src/main/java/org/apolenkov/application/views/practice/pages/PracticeView.java
--- a/src/main/java/org/apolenkov/application/views/practice/pages/PracticeView.java	(revision 132c2c29773f5f4949b3855c362e338d983d3cd4)
+++ b/src/main/java/org/apolenkov/application/views/practice/pages/PracticeView.java	(date 1760129814238)
@@ -9,24 +9,24 @@
 import com.vaadin.flow.router.Route;
 import jakarta.annotation.PostConstruct;
 import jakarta.annotation.security.RolesAllowed;
+import java.util.List;
 import java.util.Optional;
 import org.apolenkov.application.config.constants.RouteConstants;
 import org.apolenkov.application.config.security.SecurityConstants;
-import org.apolenkov.application.domain.usecase.FlashcardUseCase;
 import org.apolenkov.application.model.Deck;
+import org.apolenkov.application.model.Flashcard;
 import org.apolenkov.application.model.PracticeDirection;
 import org.apolenkov.application.views.core.exception.EntityNotFoundException;
 import org.apolenkov.application.views.core.layout.PublicLayout;
-import org.apolenkov.application.views.practice.business.PracticePresenter;
 import org.apolenkov.application.views.practice.business.PracticeSession;
+import org.apolenkov.application.views.practice.business.PracticeSessionManager;
+import org.apolenkov.application.views.practice.business.PracticeSessionService;
 import org.apolenkov.application.views.practice.components.PracticeActions;
 import org.apolenkov.application.views.practice.components.PracticeAllKnownDialog;
 import org.apolenkov.application.views.practice.components.PracticeCard;
 import org.apolenkov.application.views.practice.components.PracticeHeader;
 import org.apolenkov.application.views.practice.components.PracticeProgress;
 import org.apolenkov.application.views.practice.constants.PracticeConstants;
-import org.apolenkov.application.views.practice.controllers.PracticeCompletionFlow;
-import org.apolenkov.application.views.practice.controllers.PracticeSessionFlow;
 import org.apolenkov.application.views.shared.utils.NavigationHelper;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
@@ -41,15 +41,10 @@
 public class PracticeView extends Composite<VerticalLayout> implements HasUrlParameter<String>, HasDynamicTitle {

     private static final Logger LOGGER = LoggerFactory.getLogger(PracticeView.class);
-    private static final Logger AUDIT_LOGGER = LoggerFactory.getLogger("org.apolenkov.application.audit");

     // Dependencies
-    private final transient FlashcardUseCase flashcardUseCase;
-    private final transient PracticePresenter presenter;
-
-    // Controllers
-    private transient PracticeSessionFlow sessionFlow;
-    private transient PracticeCompletionFlow completionFlow;
+    private final transient PracticeSessionService sessionService;
+    private final transient PracticeSessionManager sessionManager;

     // Data
     private transient Deck currentDeck;
@@ -65,12 +60,13 @@
     /**
      * Creates a new PracticeView with required dependencies.
      *
-     * @param useCase service for flashcard operations
-     * @param practicePresenter presenter for managing practice session logic
+     * @param sessionServiceParam service for session preparation and configuration
+     * @param sessionManagerParam manager for active session operations
      */
-    public PracticeView(final FlashcardUseCase useCase, final PracticePresenter practicePresenter) {
-        this.flashcardUseCase = useCase;
-        this.presenter = practicePresenter;
+    public PracticeView(
+            final PracticeSessionService sessionServiceParam, final PracticeSessionManager sessionManagerParam) {
+        this.sessionService = sessionServiceParam;
+        this.sessionManager = sessionManagerParam;
     }

     /**
@@ -81,51 +77,20 @@
     @PostConstruct
     @SuppressWarnings("unused")
     private void init() {
-        setupMainLayout();
-        createPracticeInterface();
-    }
-
-    /**
-     * Sets up the main layout properties.
-     */
-    private void setupMainLayout() {
+        // Main layout setup
         getContent().setWidthFull();
         getContent().setPadding(true);
         getContent().setSpacing(true);
         getContent().setAlignItems(FlexComponent.Alignment.CENTER);
-    }
-
-    /**
-     * Creates the complete practice interface.
-     */
-    private void createPracticeInterface() {
-        VerticalLayout contentContainer = createContentContainer();
-        VerticalLayout pageSection = createPageSection();

-        contentContainer.add(pageSection);
-        getContent().add(contentContainer);
-    }
-
-    /**
-     * Creates the main content container.
-     *
-     * @return configured content container
-     */
-    private VerticalLayout createContentContainer() {
+        // Content container
         VerticalLayout contentContainer = new VerticalLayout();
         contentContainer.setSpacing(true);
         contentContainer.setWidthFull();
         contentContainer.addClassName(PracticeConstants.CONTAINER_MD_CLASS);
         contentContainer.setAlignItems(FlexComponent.Alignment.CENTER);
-        return contentContainer;
-    }

-    /**
-     * Creates the main page section with all practice components.
-     *
-     * @return configured page section
-     */
-    private VerticalLayout createPageSection() {
+        // Page section
         VerticalLayout pageSection = new VerticalLayout();
         pageSection.setSpacing(true);
         pageSection.setPadding(true);
@@ -134,16 +99,13 @@
         pageSection.addClassName(PracticeConstants.SURFACE_PANEL_CLASS);
         pageSection.addClassName(PracticeConstants.CONTAINER_MD_CLASS);

+        // Initialize components
         initializeComponents();
-        initializeControllers();
-
-        // Add components to layout first - this triggers initContent() for Composite components
         pageSection.add(practiceHeader, practiceProgress, practiceCard, practiceActions);
-
-        // Setup handlers AFTER components are added and initialized
         setupActionHandlers();

-        return pageSection;
+        contentContainer.add(pageSection);
+        getContent().add(contentContainer);
     }

     /**
@@ -156,15 +118,7 @@
         practiceActions = new PracticeActions();

         // Load practice direction from user settings
-        sessionDirection = presenter.defaultDirection();
-    }
-
-    /**
-     * Initializes controllers with components.
-     */
-    private void initializeControllers() {
-        sessionFlow = new PracticeSessionFlow(presenter, practiceCard, practiceProgress, practiceActions);
-        completionFlow = new PracticeCompletionFlow(presenter, flashcardUseCase, practiceCard, practiceActions);
+        sessionDirection = sessionService.defaultDirection();
     }

     /**
@@ -200,17 +154,16 @@
     @Override
     public void setParameter(final BeforeEvent event, final String parameter) {
         try {
-            LOGGER.debug("Initializing practice session for deck ID: {}", parameter);
+            long deckId = Long.parseLong(parameter);
+            LOGGER.debug("Initializing practice session for deck ID: {}", deckId);

-            long deckId = parseDeckId(parameter);
             loadDeck(deckId);
             if (currentDeck != null) {
-                AUDIT_LOGGER.info(
-                        "User started practice session for deck '{}' (ID: {})",
+                LOGGER.debug(
+                        "Starting practice session for deck '{}' (ID: {})",
                         currentDeck.getTitle(),
                         currentDeck.getId());
                 startDefaultPractice();
-                LOGGER.debug("Practice session initialized successfully for deck: {}", currentDeck.getTitle());
             }
         } catch (NumberFormatException e) {
             LOGGER.error("Invalid deck ID format: {}", parameter, e);
@@ -219,26 +172,20 @@
         }
     }

-    /**
-     * Parses the deck ID from the URL parameter.
-     *
-     * @param parameter the deck ID as a string from the URL
-     * @return parsed deck ID as long
-     * @throws NumberFormatException if the parameter is not a valid number
-     */
-    private long parseDeckId(final String parameter) throws NumberFormatException {
-        return Long.parseLong(parameter);
-    }
-
     /**
      * Starts default practice session.
      */
     private void startDefaultPractice() {
-        session =
-                sessionFlow.startDefaultPractice(currentDeck, sessionDirection).orElse(null);
-        if (session == null) {
+        List<Flashcard> notKnownCards = sessionService.getNotKnownCards(currentDeck.getId());
+        if (notKnownCards.isEmpty()) {
             showAllKnownDialogAndRedirect();
+            return;
         }
+
+        int defaultCount = sessionService.resolveDefaultCount(currentDeck.getId());
+        boolean random = sessionService.isRandom();
+        session = sessionService.startSession(currentDeck.getId(), defaultCount, random);
+        showCurrentCard();
     }

     /**
@@ -266,7 +213,7 @@
      * @param deckId the deck ID to load
      */
     private void loadDeck(final long deckId) {
-        Optional<Deck> deckOpt = presenter.loadDeck(deckId);
+        Optional<Deck> deckOpt = sessionService.loadDeck(deckId);
         if (deckOpt.isPresent()) {
             currentDeck = deckOpt.get();
             practiceHeader.setDeckTitle(getTranslation(PracticeConstants.PRACTICE_TITLE_KEY, currentDeck.getTitle()));
@@ -280,11 +227,35 @@
         }
     }

+    /**
+     * Shows the current card in question state.
+     */
+    private void showCurrentCard() {
+        if (session == null || sessionManager.isComplete(session)) {
+            return;
+        }
+
+        updateProgress();
+        Flashcard currentCard = sessionManager.currentCard(session);
+        sessionManager.startQuestion(session);
+
+        practiceCard.displayQuestionCard(currentCard, sessionDirection);
+        practiceActions.showQuestionState();
+    }
+
     /**
      * Shows the answer for the current card.
      */
     private void showAnswer() {
-        session = sessionFlow.showAnswer(session, sessionDirection);
+        if (session == null || sessionManager.isComplete(session)) {
+            return;
+        }
+
+        Flashcard currentCard = sessionManager.currentCard(session);
+        session = sessionManager.reveal(session);
+
+        practiceCard.displayAnswerCard(currentCard, sessionDirection);
+        practiceActions.showAnswerState();
     }

     /**
@@ -293,30 +264,105 @@
      * @param label the label to apply (know or hard)
      */
     private void markLabeled(final String label) {
-        session = sessionFlow.markLabeled(session, label, sessionDirection);
-        if (presenter.isComplete(session)) {
+        if (session == null || !session.isShowingAnswer()) {
+            return;
+        }
+
+        session = processCardLabel(label);
+        updateProgress();
+        practiceActions.hideActionButtons();
+        nextCard();
+
+        if (sessionManager.isComplete(session)) {
             handlePracticeComplete();
         }
     }

+    /**
+     * Processes the card label.
+     *
+     * @param label the label to process
+     * @return updated session
+     */
+    private PracticeSession processCardLabel(final String label) {
+        if (PracticeConstants.KNOW_LABEL.equals(label)) {
+            return sessionManager.markKnow(session);
+        } else {
+            return sessionManager.markHard(session);
+        }
+    }
+
+    /**
+     * Moves to the next card or completes the session.
+     */
+    private void nextCard() {
+        if (sessionManager.isComplete(session)) {
+            return;
+        }
+        showCurrentCard();
+    }
+
+    /**
+     * Updates the progress display.
+     */
+    private void updateProgress() {
+        if (session == null || session.getCards() == null || session.getCards().isEmpty()) {
+            return;
+        }
+        PracticeSessionManager.Progress progress = sessionManager.progress(session);
+        practiceProgress.updateProgress(progress);
+    }
+
     /**
      * Handles practice session completion.
      */
     private void handlePracticeComplete() {
-        AUDIT_LOGGER.info(
-                "User completed practice session for deck '{}' (ID: {})", currentDeck.getTitle(), currentDeck.getId());
-        completionFlow.showPracticeComplete(session, currentDeck, this::handleRepeatSession);
-        session = null; // Mark session as completed
+        LOGGER.debug("Completing practice session for deck '{}' (ID: {})", currentDeck.getTitle(), currentDeck.getId());
+
+        sessionManager.recordAndPersist(session, sessionService);
+        showCompletionDisplay();
+        showCompletionButtons();
+        session = null;
+    }
+
+    /**
+     * Shows completion display with session statistics.
+     */
+    private void showCompletionDisplay() {
+        PracticeSessionService.SessionCompletionMetrics metrics = sessionService.calculateCompletionMetrics(session);
+
+        practiceCard.displayCompletion(
+                currentDeck.getTitle(),
+                session.getCorrectCount(),
+                metrics.totalCards(),
+                session.getHardCount(),
+                metrics.sessionMinutes(),
+                metrics.avgSeconds());
+    }
+
+    /**
+     * Shows completion action buttons.
+     */
+    private void showCompletionButtons() {
+        List<Flashcard> failedCards = sessionService.getFailedCards(currentDeck.getId(), session.getFailedCardIds());
+
+        Runnable repeatHandler = failedCards.isEmpty() ? null : () -> handleRepeatPractice(failedCards);
+
+        practiceActions.showCompletionButtons(
+                repeatHandler,
+                () -> NavigationHelper.navigateToDeck(currentDeck.getId()),
+                NavigationHelper::navigateToDecks);
     }

     /**
      * Handles repeat practice with new session.
      *
-     * @param newSession the new session with failed cards
+     * @param failedCards list of failed cards to practice
      */
-    private void handleRepeatSession(final PracticeSession newSession) {
-        session = newSession;
-        sessionFlow.showCurrentCard(session, sessionDirection);
+    private void handleRepeatPractice(final List<Flashcard> failedCards) {
+        practiceActions.resetToPracticeButtons();
+        session = sessionService.startRepeatSession(currentDeck.getId(), failedCards);
+        showCurrentCard();
     }

     /**
Index: src/main/java/org/apolenkov/application/views/deck/components/grid/DeckFlashcardGrid.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/org/apolenkov/application/views/deck/components/grid/DeckFlashcardGrid.java b/src/main/java/org/apolenkov/application/views/deck/components/grid/DeckFlashcardGrid.java
--- a/src/main/java/org/apolenkov/application/views/deck/components/grid/DeckFlashcardGrid.java	(revision 132c2c29773f5f4949b3855c362e338d983d3cd4)
+++ b/src/main/java/org/apolenkov/application/views/deck/components/grid/DeckFlashcardGrid.java	(date 1760195528848)
@@ -6,6 +6,7 @@
 import com.vaadin.flow.data.provider.ListDataProvider;
 import java.util.ArrayList;
 import java.util.List;
+import java.util.Set;
 import java.util.function.Consumer;
 import org.apolenkov.application.model.Flashcard;
 import org.apolenkov.application.service.stats.StatsService;
@@ -30,6 +31,7 @@

     // Logic
     private transient Long currentDeckId;
+    private transient Set<Long> cachedKnownCardIds;

     /**
      * Creates a new DeckFlashcardGrid component.
@@ -63,14 +65,28 @@

     /**
      * Adds all necessary columns to the flashcard grid.
+     * Uses supplier pattern to load known card IDs only once per grid render.
      */
     private void addColumns() {
         DeckGridColumns.addFrontColumn(this);
         DeckGridColumns.addExampleColumn(this);
-        DeckGridColumns.addStatusColumn(this, statsService, currentDeckId);
+        // Supplier pattern: known IDs are loaded once per render, cached, and reused
+        DeckGridColumns.addStatusColumn(this, this::getCachedKnownCardIds);
         DeckGridColumns.addActionsColumn(this, editFlashcardCallback, toggleKnownCallback, deleteFlashcardCallback);
     }

+    /**
+     * Gets cached known card IDs, loading them if not yet cached.
+     *
+     * @return set of known card IDs
+     */
+    private Set<Long> getCachedKnownCardIds() {
+        if (cachedKnownCardIds == null && currentDeckId != null) {
+            cachedKnownCardIds = statsService.getKnownCardIds(currentDeckId);
+        }
+        return cachedKnownCardIds != null ? cachedKnownCardIds : Set.of();
+    }
+
     /**
      * Sets the current deck ID for statistics tracking.
      *
@@ -110,10 +126,14 @@

     /**
      * Updates the grid data provider with filtered flashcards.
+     * Invalidates cache to force reload of known card IDs on next render.
      *
      * @param filteredFlashcards the filtered flashcards to display
      */
     public void updateData(final List<Flashcard> filteredFlashcards) {
+        // Invalidate cache to ensure fresh data on next render
+        cachedKnownCardIds = null;
+
         // Data
         ListDataProvider<Flashcard> flashcardsDataProvider =
                 new ListDataProvider<>(new ArrayList<>(filteredFlashcards));
Index: src/main/java/org/apolenkov/application/views/deck/business/DeckListPresenter.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/org/apolenkov/application/views/deck/business/DeckListPresenter.java b/src/main/java/org/apolenkov/application/views/deck/business/DeckListPresenter.java
--- a/src/main/java/org/apolenkov/application/views/deck/business/DeckListPresenter.java	(revision 132c2c29773f5f4949b3855c362e338d983d3cd4)
+++ b/src/main/java/org/apolenkov/application/views/deck/business/DeckListPresenter.java	(date 1760195528858)
@@ -3,6 +3,8 @@
 import java.util.Comparator;
 import java.util.List;
 import java.util.Locale;
+import java.util.Map;
+import java.util.Set;
 import org.apolenkov.application.domain.usecase.DeckUseCase;
 import org.apolenkov.application.domain.usecase.FlashcardUseCase;
 import org.apolenkov.application.domain.usecase.UserUseCase;
@@ -79,22 +81,39 @@
                 .sorted(Comparator.comparing(Deck::getTitle, Comparator.nullsLast(String::compareToIgnoreCase)))
                 .toList();

-        return decks.stream().map(this::toViewModel).toList();
+        // Step 1: Batch load flashcard counts for all decks in single query
+        List<Long> deckIds = decks.stream().map(Deck::getId).toList();
+        Map<Long, Long> deckSizes = flashcardUseCase.countByDeckIds(deckIds);
+
+        // Step 2: Batch load known card IDs for all decks in single query
+        Map<Long, Set<Long>> knownCardsByDeck = statsService.getKnownCardIdsBatch(deckIds);
+
+        return decks.stream()
+                .map(deck -> toViewModel(deck, deckSizes, knownCardsByDeck))
+                .toList();
     }

     /**
      * Converts a deck entity to a view model for UI display.
+     * Uses pre-loaded data maps to avoid repeated database queries.
      *
      * @param deck the deck entity to convert
+     * @param deckSizes pre-loaded map of deck ID to flashcard count
+     * @param knownCardsByDeck pre-loaded map of deck ID to known card IDs
      * @return a DeckCardViewModel with deck data and progress statistics
      */
-    private DeckCardViewModel toViewModel(final Deck deck) {
-        // Calculate deck size by counting flashcards
-        int deckSize = (int) flashcardUseCase.countByDeckId(deck.getId());
-        // Count cards marked as known by the user
-        int known = statsService.getKnownCardIds(deck.getId()).size();
-        // Calculate progress percentage based on known cards vs. total
-        int percent = statsService.getDeckProgressPercent(deck.getId(), deckSize);
+    private DeckCardViewModel toViewModel(
+            final Deck deck, final Map<Long, Long> deckSizes, final Map<Long, Set<Long>> knownCardsByDeck) {
+        // Get deck size from pre-loaded map (no database query)
+        int deckSize = deckSizes.getOrDefault(deck.getId(), 0L).intValue();
+
+        // Get known cards count from pre-loaded map (no database query)
+        Set<Long> knownCards = knownCardsByDeck.getOrDefault(deck.getId(), Set.of());
+        int known = knownCards.size();
+
+        // Calculate progress percentage inline (no additional query)
+        int percent = deckSize > 0 ? (int) Math.round(100.0 * known / deckSize) : 0;
+        percent = Math.clamp(percent, 0, 100);

         return new DeckCardViewModel(deck.getId(), deck.getTitle(), deck.getDescription(), deckSize, known, percent);
     }
Index: src/main/java/org/apolenkov/application/views/deck/components/grid/DeckGridColumns.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/org/apolenkov/application/views/deck/components/grid/DeckGridColumns.java b/src/main/java/org/apolenkov/application/views/deck/components/grid/DeckGridColumns.java
--- a/src/main/java/org/apolenkov/application/views/deck/components/grid/DeckGridColumns.java	(revision 132c2c29773f5f4949b3855c362e338d983d3cd4)
+++ b/src/main/java/org/apolenkov/application/views/deck/components/grid/DeckGridColumns.java	(date 1760195528825)
@@ -9,9 +9,10 @@
 import com.vaadin.flow.component.orderedlayout.FlexComponent;
 import com.vaadin.flow.component.orderedlayout.HorizontalLayout;
 import java.util.Optional;
+import java.util.Set;
 import java.util.function.Consumer;
+import java.util.function.Supplier;
 import org.apolenkov.application.model.Flashcard;
-import org.apolenkov.application.service.stats.StatsService;
 import org.apolenkov.application.views.deck.constants.DeckConstants;
 import org.apolenkov.application.views.shared.utils.ButtonHelper;
 import org.apolenkov.application.views.shared.utils.TextFormattingUtils;
@@ -52,12 +53,10 @@
      * Adds the status column to the grid.
      *
      * @param grid the grid to add column to
-     * @param statsService service for statistics tracking
-     * @param currentDeckId current deck ID
+     * @param knownCardIdsSupplier supplier for known card IDs (called once per render)
      */
-    public static void addStatusColumn(
-            final Grid<Flashcard> grid, final StatsService statsService, final Long currentDeckId) {
-        grid.addComponentColumn(flashcard -> createStatusComponent(flashcard, statsService, currentDeckId))
+    public static void addStatusColumn(final Grid<Flashcard> grid, final Supplier<Set<Long>> knownCardIdsSupplier) {
+        grid.addComponentColumn(flashcard -> createStatusComponent(flashcard, knownCardIdsSupplier))
                 .setHeader(grid.getTranslation(DeckConstants.DECK_COL_STATUS))
                 .setTextAlign(ColumnTextAlign.CENTER)
                 .setFlexGrow(1);
@@ -65,15 +64,16 @@

     /**
      * Creates a status component for a flashcard.
+     * Checks if card is known using pre-loaded Set to avoid database queries.
      *
      * @param flashcard the flashcard to create status for
-     * @param statsService service for statistics tracking
-     * @param currentDeckId current deck ID
+     * @param knownCardIdsSupplier supplier for known card IDs
      * @return the status component
      */
     private static Span createStatusComponent(
-            final Flashcard flashcard, final StatsService statsService, final Long currentDeckId) {
-        boolean known = currentDeckId != null && statsService.isCardKnown(currentDeckId, flashcard.getId());
+            final Flashcard flashcard, final Supplier<Set<Long>> knownCardIdsSupplier) {
+        Set<Long> knownCardIds = knownCardIdsSupplier.get();
+        boolean known = knownCardIds.contains(flashcard.getId());
         if (known) {
             Span statusSpan = new Span("✓");
             statusSpan.addClassName(DeckConstants.KNOWN_STATUS_CLASS);
Index: src/main/java/org/apolenkov/application/views/deck/components/grid/DeckGridFilter.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/org/apolenkov/application/views/deck/components/grid/DeckGridFilter.java b/src/main/java/org/apolenkov/application/views/deck/components/grid/DeckGridFilter.java
--- a/src/main/java/org/apolenkov/application/views/deck/components/grid/DeckGridFilter.java	(revision 132c2c29773f5f4949b3855c362e338d983d3cd4)
+++ b/src/main/java/org/apolenkov/application/views/deck/components/grid/DeckGridFilter.java	(date 1760195528855)
@@ -1,6 +1,7 @@
 package org.apolenkov.application.views.deck.components.grid;

 import java.util.List;
+import java.util.Set;
 import org.apolenkov.application.model.Flashcard;
 import org.apolenkov.application.service.stats.StatsService;
 import org.slf4j.Logger;
@@ -48,14 +49,13 @@
                 hideKnown,
                 flashcards.size());

+        Set<Long> knownCardIds = hideKnown ? statsService.getKnownCardIds(currentDeckId) : Set.of();
+
         List<Flashcard> filtered = flashcards.stream()
                 .filter(card -> searchQuery.isEmpty()
                         || card.getFrontText().toLowerCase().contains(searchQuery)
                         || card.getBackText().toLowerCase().contains(searchQuery))
-                .filter(card -> {
-                    boolean isKnown = statsService.isCardKnown(currentDeckId, card.getId());
-                    return !hideKnown || !isKnown;
-                })
+                .filter(card -> !hideKnown || !knownCardIds.contains(card.getId()))
                 .toList();

         LOGGER.debug("Filter applied: {} cards visible out of {}", filtered.size(), flashcards.size());
Index: .cursor/rules/env-config.mdc
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.cursor/rules/env-config.mdc b/.cursor/rules/env-config.mdc
new file mode 100644
--- /dev/null	(date 1760204369731)
+++ b/.cursor/rules/env-config.mdc	(date 1760204369731)
@@ -0,0 +1,58 @@
+---
+alwaysApply: true
+autoFix: true
+version: "1.0.0"
+---
+
+# ENV-BASED CONFIGURATION
+
+## STACK
+Spring Boot Profiles | application-{profile}.yml | Environment Variables | @Value
+
+## RULES [OK]
+
+**Structure**:
+- application.yml (defaults)
+- application-{profile}.yml (env-specific)
+- @Profile for conditional beans
+- @Value with defaults: `@Value("${key:defaultValue}")`
+
+**Profiles**:
+- dev (local development)
+- test (integration tests)
+- prod (production)
+
+**Environment Variables**:
+- Override via `ENV_VAR_NAME`
+- Spring Boot auto-mapping
+- Docker/K8s friendly
+
+**Secrets**:
+- NO hardcoded passwords/keys
+- Environment variables for secrets
+- Spring Cloud Config/Vault for production
+
+**Database**:
+- Profile-specific datasource
+- Connection pooling per env
+- Migration per profile
+
+**Logging**:
+- logback-spring.xml with `<springProfile>`
+- Log levels per environment
+- File/console output per env
+
+## ANTIPATTERNS [BAD]
+1. Hardcoded values → externalize
+2. Secrets in code/git → env vars
+3. Single config for all envs → profiles
+4. No defaults → always provide fallback
+5. Magic values → named properties
+
+## CHECKLIST
+- [ ] application-{profile}.yml for each env
+- [ ] @Profile for conditional beans
+- [ ] @Value with defaults
+- [ ] NO secrets in code
+- [ ] Environment variable overrides
+- [ ] Profile-specific logging
Index: src/main/resources/db/migration/V4__auto_update_timestamps.sql
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/resources/db/migration/V4__auto_update_timestamps.sql b/src/main/resources/db/migration/V4__auto_update_timestamps.sql
new file mode 100644
--- /dev/null	(date 1760121927529)
+++ b/src/main/resources/db/migration/V4__auto_update_timestamps.sql	(date 1760121927529)
@@ -0,0 +1,36 @@
+-- V4: Auto-update timestamps trigger
+-- This migration adds PostgreSQL trigger to automatically update updated_at column
+
+-- Create function that updates updated_at timestamp
+CREATE OR REPLACE FUNCTION update_updated_at_column()
+RETURNS TRIGGER AS $$
+BEGIN
+    NEW.updated_at = CURRENT_TIMESTAMP;
+    RETURN NEW;
+END;
+$$ LANGUAGE plpgsql;
+
+-- Apply trigger to decks table
+CREATE TRIGGER update_decks_updated_at
+    BEFORE UPDATE ON decks
+    FOR EACH ROW
+    EXECUTE FUNCTION update_updated_at_column();
+
+-- Apply trigger to flashcards table
+CREATE TRIGGER update_flashcards_updated_at
+    BEFORE UPDATE ON flashcards
+    FOR EACH ROW
+    EXECUTE FUNCTION update_updated_at_column();
+
+-- Apply trigger to news table
+CREATE TRIGGER update_news_updated_at
+    BEFORE UPDATE ON news
+    FOR EACH ROW
+    EXECUTE FUNCTION update_updated_at_column();
+
+-- Apply trigger to deck_daily_stats table
+CREATE TRIGGER update_deck_daily_stats_updated_at
+    BEFORE UPDATE ON deck_daily_stats
+    FOR EACH ROW
+    EXECUTE FUNCTION update_updated_at_column();
+
Index: .env.example
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.env.example b/.env.example
--- a/.env.example	(revision 132c2c29773f5f4949b3855c362e338d983d3cd4)
+++ b/.env.example	(date 1760205044070)
@@ -1,50 +1,66 @@
 # =============================================================================
-# ENVIRONMENT CONFIGURATION
-# =============================================================================
-# Copy this file to .env and update with your actual values
-# cp .env.example .env
-
+# FLASHCARDS APPLICATION - ENVIRONMENT VARIABLES
 # =============================================================================
-# DATABASE CONFIGURATION
+# Copy to .env and configure: cp .env.example .env
 # =============================================================================
-# PostgreSQL connection settings (required for all profiles)
+
+# Database Connection (REQUIRED)
 DB_URL=jdbc:postgresql://localhost:5432/flashcards
-DB_USER=postgres
-DB_PASSWORD=postgres
+DB_USER=flashcards_user
+DB_PASSWORD=your_secure_password_here

-# =============================================================================
-# DEMO USERS (Development Only)
-# =============================================================================
-# These users are created automatically in development mode
-# DO NOT use these passwords in production!
-
-# Admin user - full access to all features
+# Demo Users (dev only)
 DEMO_ADMIN_PASSWORD=admin
-
-# Regular user - standard access
 DEMO_USER_PASSWORD=user
+TEST_USER_PASSWORD=testPassword123
+
+# Data Generation Control
+# Edit these flags, then run: make dev
+SEED_DEMO_DATA=true
+GENERATE_TEST_DATA=false
+
+# Batch Size (generation speed)
+# Higher = faster, but more RAM. Range: 50-1000
+BATCH_SIZE_USERS=100
+
+# Generation Limits (data volume)
+LIMIT_USERS=1000
+LIMIT_DECKS=10
+LIMIT_CARDS=50
+LIMIT_NEWS=50
+
+# Caching (performance)
+CACHE_USER_TTL=30
+CACHE_USER_MAX_SIZE=1000

 # =============================================================================
-# ACTUATOR ENDPOINTS AUTHENTICATION
+# PRESETS (copy values above)
 # =============================================================================
-# All actuator endpoints (/actuator/*) require authentication
-# Use demo users for development, create separate credentials for production
-#
-# Development: use admin/admin or user/user
-# Production: create dedicated monitoring user with strong password
-#
-# Example for production:
-# ACTUATOR_USER=monitoring
-# ACTUATOR_PASSWORD=generate_secure_random_password_here
-#
-# Access examples:
-# curl -u admin:admin http://localhost:8080/actuator/health
-# curl -u admin:admin http://localhost:8080/actuator/metrics
+
+# SMALL (30 sec, 10MB)
+# LIMIT_USERS=100
+# LIMIT_DECKS=5
+# LIMIT_CARDS=20
+
+# MEDIUM (2-3 min, 500MB) - DEFAULT
+# LIMIT_USERS=1000
+# LIMIT_DECKS=10
+# LIMIT_CARDS=50
+
+# LARGE (10-15 min, 10GB)
+# LIMIT_USERS=5000
+# LIMIT_DECKS=20
+# LIMIT_CARDS=100
+# BATCH_SIZE_USERS=500
+
+# EXTREME (1+ hour, 100GB)
+# LIMIT_USERS=10000
+# LIMIT_DECKS=50
+# LIMIT_CARDS=200
+# BATCH_SIZE_USERS=1000

 # =============================================================================
-# NOTES
+# USAGE
 # =============================================================================
-# - Never commit .env file to version control
-# - Use strong passwords in production
-# - Store production secrets in secure vaults (Kubernetes Secrets, HashiCorp Vault)
-# - Generate random passwords: openssl rand -base64 32
+# Edit .env, then: make dev
+# Override on-the-fly: GENERATE_TEST_DATA=true make dev
Index: src/main/java/org/apolenkov/application/service/seed/DataSeedService.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/org/apolenkov/application/service/seed/DataSeedService.java b/src/main/java/org/apolenkov/application/service/seed/DataSeedService.java
--- a/src/main/java/org/apolenkov/application/service/seed/DataSeedService.java	(revision 132c2c29773f5f4949b3855c362e338d983d3cd4)
+++ b/src/main/java/org/apolenkov/application/service/seed/DataSeedService.java	(date 1760205041506)
@@ -1,11 +1,14 @@
 package org.apolenkov.application.service.seed;

+import jakarta.annotation.PostConstruct;
 import java.security.SecureRandom;
 import java.time.LocalDate;
 import java.time.LocalDateTime;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Set;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.Executors;
 import org.apolenkov.application.domain.dto.SessionStatsDto;
 import org.apolenkov.application.domain.port.DeckRepository;
 import org.apolenkov.application.domain.port.FlashcardRepository;
@@ -18,14 +21,18 @@
 import org.apolenkov.application.model.User;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
+import org.springframework.context.annotation.Profile;
 import org.springframework.security.crypto.password.PasswordEncoder;
 import org.springframework.stereotype.Service;
-import org.springframework.transaction.annotation.Transactional;
+import org.springframework.transaction.PlatformTransactionManager;
+import org.springframework.transaction.support.TransactionTemplate;

 /**
- * Simple service for generating test data.
+ * Optimized service for generating test data using batch operations and virtual threads.
+ * Only active in dev and test profiles for safety.
  */
 @Service
+@Profile({"dev", "test"})
 public class DataSeedService {

     private static final Logger LOGGER = LoggerFactory.getLogger(DataSeedService.class);
@@ -36,8 +43,20 @@
     private final StatsRepository statsRepository;
     private final NewsRepository newsRepository;
     private final PasswordEncoder passwordEncoder;
+    private final TransactionTemplate transactionTemplate;
     private final SecureRandom random = new SecureRandom();

+    private String cachedPasswordHash;
+
+    // Configurable batch sizes via environment variables
+    private final int batchSizeUsers;
+
+    // Configurable generation limits via environment variables
+    private final int limitUsers;
+    private final int limitDecksPerUser;
+    private final int limitCardsPerDeck;
+    private final int limitNews;
+
     private static final String[] USER_NAMES = {"Alex", "Maria", "John", "Anna", "David", "Elena", "Michael", "Sophia"};
     private static final String[] LAST_NAMES = {
         "Smith", "Johnson", "Williams", "Brown", "Jones", "Garcia", "Miller", "Davis"
@@ -62,75 +81,215 @@
         "NullPointerException, IndexOutOfBounds, StackOverflow",
         "Unit tests, Integration tests, E2E testing"
     };
-    private static final String DEFAULT_TEST_PASSWORD = "testPassword123";
-    private static final String TEST_PASSWORD_PROPERTY = "seed.test.password";
+
+    // Batch processing configuration
+    private static final int STATS_DAYS_TO_GENERATE = 90;
+    private static final double STATS_PROBABILITY = 0.7;

     /**
-     * Constructs DataSeedService with required dependencies.
+     * Constructs DataSeedService with required dependencies and configuration.
      *
-     * @param userRepositoryValue repository for user operations
-     * @param deckRepositoryValue repository for deck operations
-     * @param flashcardRepositoryValue repository for flashcard operations
-     * @param statsRepositoryValue repository for statistics operations
-     * @param newsRepositoryValue repository for news operations
+     * @param repositories grouped repository dependencies
      * @param passwordEncoderValue encoder for password hashing
+     * @param transactionManager transaction manager for manual TX control
+     * @param config seed configuration with batch sizes and generation limits
      */
     public DataSeedService(
-            final UserRepository userRepositoryValue,
-            final DeckRepository deckRepositoryValue,
-            final FlashcardRepository flashcardRepositoryValue,
-            final StatsRepository statsRepositoryValue,
-            final NewsRepository newsRepositoryValue,
-            final PasswordEncoder passwordEncoderValue) {
-        this.userRepository = userRepositoryValue;
-        this.deckRepository = deckRepositoryValue;
-        this.flashcardRepository = flashcardRepositoryValue;
-        this.statsRepository = statsRepositoryValue;
-        this.newsRepository = newsRepositoryValue;
+            final DataSeedRepositories repositories,
+            final PasswordEncoder passwordEncoderValue,
+            final PlatformTransactionManager transactionManager,
+            final SeedConfig config) {
+        this.userRepository = repositories.userRepository();
+        this.deckRepository = repositories.deckRepository();
+        this.flashcardRepository = repositories.flashcardRepository();
+        this.statsRepository = repositories.statsRepository();
+        this.newsRepository = repositories.newsRepository();
         this.passwordEncoder = passwordEncoderValue;
+        this.transactionTemplate = new TransactionTemplate(transactionManager);
+
+        // Batch size
+        this.batchSizeUsers = config.batch().users();
+
+        // Generation limits
+        this.limitUsers = config.limits().users();
+        this.limitDecksPerUser = config.limits().decksPerUser();
+        this.limitCardsPerDeck = config.limits().cardsPerDeck();
+        this.limitNews = config.limits().news();
+
+        LOGGER.info(
+                "DataSeedService initialized with batch size: users={}",
+                config.batch().users());
+        LOGGER.info(
+                "Generation limits: {} users, {} decks/user, {} cards/deck, {} news",
+                config.limits().users(),
+                config.limits().decksPerUser(),
+                config.limits().cardsPerDeck(),
+                config.limits().news());
     }

     /**
-     * Generates test data for load testing.
-     * Delegates to specialized methods to reduce cognitive complexity.
+     * Initializes cached password hash after bean construction.
+     * Avoids expensive password encoding in loops.
      */
-    @Transactional
+    @PostConstruct
+    void initPasswordCache() {
+        LOGGER.debug("Caching password hash for test data generation...");
+        this.cachedPasswordHash = passwordEncoder.encode(getTestPassword());
+        LOGGER.debug("Password hash cached successfully");
+    }
+
+    /**
+     * Generates test data for load testing using batch operations and virtual threads.
+     * Use LIMIT_* environment variables to control data volume.
+     */
     public void generateTestData() {
-        LOGGER.info("=== Starting test data generation ===");
+        LOGGER.info("=== Starting OPTIMIZED test data generation ===");
         long startTime = System.currentTimeMillis();

-        // Generate all test data using specialized methods
-        List<User> users = generateTestUsers();
-        int[] deckAndCardCounts = generateDecksAndCards(users);
-        int statsGenerated = generateStatistics(users);
-        generateNewsArticles();
+        // Step 1: Generate users in batches
+        List<User> users = generateTestUsersBatch();
+
+        // Step 2: Generate decks and flashcards using Virtual Threads for parallelization
+        int[] deckAndCardCounts = generateDecksAndCardsParallel(users);
+
+        // Step 3: Generate statistics and news in parallel (non-blocking)
+        CompletableFuture<Integer> statsFuture = CompletableFuture.supplyAsync(() -> generateStatistics(users));
+        CompletableFuture<Integer> newsFuture = CompletableFuture.supplyAsync(this::generateNewsArticlesBatch);
+
+        // Wait for parallel operations to complete
+        int statsGenerated = statsFuture.join();
+        int newsGenerated = newsFuture.join();

         // Log completion summary
-        logGenerationSummary(startTime, users.size(), deckAndCardCounts[0], deckAndCardCounts[1], statsGenerated);
+        logGenerationSummary(
+                startTime, users.size(), deckAndCardCounts[0], deckAndCardCounts[1], statsGenerated, newsGenerated);
     }

     /**
-     * Generates test users for load testing.
+     * Generates test users in batches for better performance.
+     * Uses configured LIMIT_USERS for total count.
      *
      * @return list of generated users
      */
-    private List<User> generateTestUsers() {
-        LOGGER.info("Generating 1000 test users...");
-        List<User> users = new ArrayList<>();
+    private List<User> generateTestUsersBatch() {
+        LOGGER.info("Generating {} test users in batches of {}...", limitUsers, batchSizeUsers);
+        List<User> allUsers = new ArrayList<>();
+
+        for (int i = 0; i < limitUsers; i += batchSizeUsers) {
+            int end = Math.min(i + batchSizeUsers, limitUsers);
+            int currentBatch = i;
+
+            // Create batch in separate transaction to reduce lock time
+            List<User> batch = transactionTemplate.execute(status -> {
+                List<User> users = new ArrayList<>(batchSizeUsers);
+                for (int j = currentBatch; j < end; j++) {
+                    users.add(createTestUser(j));
+                }
+                return userRepository.saveAll(users);
+            });
+
+            assert batch != null;
+            allUsers.addAll(batch);
+
+            if ((i / batchSizeUsers) % 5 == 0) {
+                LOGGER.info("Generated {}/{} users", allUsers.size(), limitUsers);
+            }
+        }
+
+        LOGGER.info("Successfully generated {} users", allUsers.size());
+        return allUsers;
+    }
+
+    /**
+     * Generates decks and flashcards using Virtual Threads for parallel processing.
+     * Uses configured LIMIT_DECKS and LIMIT_CARDS for quantities.
+     *
+     * @param users list of users to generate data for
+     * @return array with [totalDecks, totalCards] counts
+     */
+    @SuppressWarnings("java:S2139") // Security audit requires logging before rethrow (OWASP compliance)
+    private int[] generateDecksAndCardsParallel(final List<User> users) {
+        LOGGER.info("Generating decks and flashcards using Virtual Threads...");

-        for (int i = 0; i < 1000; i++) {
-            logProgress(i, 20, "Generated {} users so far...", i);
+        int totalDecks = 0;
+        int totalCards = 0;

-            User user = createTestUser(i);
-            users.add(userRepository.save(user));
-        }
+        LOGGER.info(
+                "Using generation limits: {} decks per user, {} cards per deck", limitDecksPerUser, limitCardsPerDeck);
+
+        // Process users in chunks with Virtual Threads
+        int chunkSize = batchSizeUsers;
+        try (var executor = Executors.newVirtualThreadPerTaskExecutor()) {
+            List<java.util.concurrent.Future<int[]>> futures = new ArrayList<>();
+
+            for (int i = 0; i < users.size(); i += chunkSize) {
+                int endIdx = Math.min(i + chunkSize, users.size());
+                List<User> userChunk = users.subList(i, endIdx);
+
+                futures.add(executor.submit(() -> processUserChunk(userChunk, limitDecksPerUser, limitCardsPerDeck)));
+            }

-        LOGGER.info("Successfully generated {} users", users.size());
-        return users;
+            // Collect results
+            for (var future : futures) {
+                int[] counts = future.get();
+                totalDecks += counts[0];
+                totalCards += counts[1];
+            }
+        } catch (InterruptedException e) {
+            Thread.currentThread().interrupt();
+            LOGGER.error("Thread interrupted during parallel processing", e);
+            throw new DataGenerationException("Failed to generate decks and cards - interrupted", e);
+        } catch (Exception e) {
+            LOGGER.error("Error in parallel processing", e);
+            throw new DataGenerationException("Failed to generate decks and cards", e);
+        }
+
+        LOGGER.info("Successfully generated {} decks and {} flashcards", totalDecks, totalCards);
+        return new int[] {totalDecks, totalCards};
+    }
+
+    /**
+     * Processes a chunk of users to generate their decks and flashcards.
+     *
+     * @param userChunk chunk of users to process
+     * @param deckCount number of decks per user
+     * @param cardCount number of cards per deck
+     * @return array with [decks, cards] counts
+     */
+    private int[] processUserChunk(final List<User> userChunk, final int deckCount, final int cardCount) {
+        return transactionTemplate.execute(status -> {
+            int decks = 0;
+            int cards = 0;
+
+            for (User user : userChunk) {
+                // Generate decks for this user in batch
+                List<Deck> userDecks = new ArrayList<>(deckCount);
+                for (int i = 0; i < deckCount; i++) {
+                    userDecks.add(createTestDeck(user, i));
+                }
+
+                List<Deck> savedDecks = deckRepository.saveAll(userDecks);
+                decks += savedDecks.size();
+
+                // Generate flashcards for all decks in batch
+                List<Flashcard> allCards = new ArrayList<>(deckCount * cardCount);
+                for (Deck deck : savedDecks) {
+                    for (int j = 0; j < cardCount; j++) {
+                        allCards.add(createTestCard(deck, j));
+                    }
+                }
+
+                flashcardRepository.saveAll(allCards);
+                cards += allCards.size();
+            }
+
+            return new int[] {decks, cards};
+        });
     }

     /**
      * Creates a single test user with random data.
+     * Uses cached password hash for performance.
      *
      * @param index user index for unique email generation
      * @return configured test user
@@ -144,59 +303,12 @@
         User user = new User();
         user.setEmail(email);
         user.setName(name);
-        user.setPasswordHash(passwordEncoder.encode(getTestPassword()));
+        user.setPasswordHash(cachedPasswordHash); // Use cached hash instead of encoding each time
         user.setRoles(Set.of("USER"));

         return user;
     }

-    /**
-     * Generates decks and flashcards for all users.
-     *
-     * @param users list of users to generate data for
-     * @return array with [totalDecks, totalCards] counts
-     */
-    private int[] generateDecksAndCards(final List<User> users) {
-        LOGGER.info("Generating decks and flashcards...");
-        int totalDecks = 0;
-        int totalCards = 0;
-        int userCount = 0;
-
-        for (User user : users) {
-            userCount++;
-            logProgress(userCount, 10, "Processing user {} of {}...", userCount, users.size());
-
-            int[] userCounts = generateUserDecksAndCards(user);
-            totalDecks += userCounts[0];
-            totalCards += userCounts[1];
-        }
-
-        LOGGER.info("Successfully generated {} decks and {} flashcards", totalDecks, totalCards);
-        return new int[] {totalDecks, totalCards};
-    }
-
-    /**
-     * Generates decks and cards for a single user.
-     *
-     * @param user the user to generate data for
-     * @return array with [decks, cards] counts for this user
-     */
-    private int[] generateUserDecksAndCards(final User user) {
-        int userDecks = 0;
-        int userCards = 0;
-
-        for (int i = 0; i < 10; i++) {
-            Deck deck = createTestDeck(user, i);
-            deck = deckRepository.save(deck);
-            userDecks++;
-
-            int cardsInDeck = generateDeckCards(deck);
-            userCards += cardsInDeck;
-        }
-
-        return new int[] {userDecks, userCards};
-    }
-
     /**
      * Creates a test deck for a user.
      *
@@ -209,24 +321,6 @@
         return new Deck(null, user.getId(), title, "Test deck for load testing");
     }

-    /**
-     * Generates flashcards for a deck.
-     *
-     * @param deck the deck to generate cards for
-     * @return number of cards generated
-     */
-    private int generateDeckCards(final Deck deck) {
-        int cardsGenerated = 0;
-
-        for (int j = 0; j < 50; j++) {
-            Flashcard card = createTestCard(deck, j);
-            flashcardRepository.save(card);
-            cardsGenerated++;
-        }
-
-        return cardsGenerated;
-    }
-
     /**
      * Creates a test flashcard.
      *
@@ -284,7 +378,7 @@
     private int generateDeckStatistics(final Deck deck) {
         int statsGenerated = 0;

-        for (int day = 0; day < 90; day++) {
+        for (int day = 0; day < STATS_DAYS_TO_GENERATE; day++) {
             if (shouldGenerateStatsForDay()) {
                 SessionStatsDto stats = createSessionStats(deck);
                 statsRepository.appendSession(stats, LocalDate.now().minusDays(day));
@@ -298,10 +392,10 @@
     /**
      * Determines if statistics should be generated for a specific day.
      *
-     * @return true if stats should be generated (70% probability)
+     * @return true if stats should be generated based on probability
      */
     private boolean shouldGenerateStatsForDay() {
-        return random.nextDouble() < 0.7;
+        return random.nextDouble() < STATS_PROBABILITY;
     }

     /**
@@ -317,21 +411,38 @@
         long duration = viewed * 30000L;
         long delay = viewed * 3000L;

-        return SessionStatsDto.of(deck.getId(), viewed, correct, hard, duration, delay, null);
+        return SessionStatsDto.builder()
+                .deckId(deck.getId())
+                .viewed(viewed)
+                .correct(correct)
+                .hard(hard)
+                .sessionDurationMs(duration)
+                .totalAnswerDelayMs(delay)
+                .knownCardIdsDelta(null)
+                .build();
     }

     /**
-     * Generates news articles for testing.
+     * Generates news articles in batch for testing.
+     * Uses configured LIMIT_NEWS for count.
+     *
+     * @return number of news articles generated
      */
-    private void generateNewsArticles() {
-        LOGGER.info("Generating news articles...");
+    private int generateNewsArticlesBatch() {
+        LOGGER.info("Generating {} news articles in batch...", limitNews);

-        for (int i = 0; i < 50; i++) {
-            News news = createTestNews(i);
-            newsRepository.save(news);
+        List<News> newsList = new ArrayList<>(limitNews);
+        for (int i = 0; i < limitNews; i++) {
+            newsList.add(createTestNews(i));
         }

-        LOGGER.info("Successfully generated 50 news articles");
+        transactionTemplate.execute(status -> {
+            newsRepository.saveAll(newsList);
+            return null;
+        });
+
+        LOGGER.info("Successfully generated {} news articles", limitNews);
+        return limitNews;
     }

     /**
@@ -349,20 +460,6 @@
                 LocalDateTime.now());
     }

-    /**
-     * Logs generation progress at specified intervals.
-     *
-     * @param current current progress
-     * @param interval logging interval
-     * @param message log message template
-     * @param args message arguments
-     */
-    private void logProgress(final int current, final int interval, final String message, final Object... args) {
-        if (current % interval == 0) {
-            LOGGER.debug(message, args);
-        }
-    }
-
     /**
      * Logs final generation summary.
      *
@@ -371,28 +468,37 @@
      * @param deckCount number of decks generated
      * @param cardCount number of cards generated
      * @param statsCount number of statistics records generated
+     * @param newsCount number of news articles generated
      */
     private void logGenerationSummary(
-            final long startTime, final int userCount, final int deckCount, final int cardCount, final int statsCount) {
+            final long startTime,
+            final int userCount,
+            final int deckCount,
+            final int cardCount,
+            final int statsCount,
+            final int newsCount) {
         long endTime = System.currentTimeMillis();
         long duration = endTime - startTime;
+        long seconds = duration / 1000;
+        long minutes = seconds / 60;

-        LOGGER.info("=== Test data generation completed in {} ms ===", duration);
+        LOGGER.info("=== Test data generation completed in {} ms ({} min {} sec) ===", duration, minutes, seconds % 60);
         LOGGER.info(
-                "Summary: {} users, {} decks, {} flashcards, {} statistics, 50 news",
+                "Summary: {} users, {} decks, {} flashcards, {} statistics, {} news",
                 userCount,
                 deckCount,
                 cardCount,
-                statsCount);
+                statsCount,
+                newsCount);
+        LOGGER.info("Average speed: {} flashcards/sec", cardCount / Math.max(1, seconds));
     }

     /**
-     * Gets test password from system property or uses default.
-     * This method centralizes password handling to avoid hardcoded values.
+     * Gets test password from environment variable or uses default.
      *
      * @return test password for generated users
      */
     private String getTestPassword() {
-        return System.getProperty(TEST_PASSWORD_PROPERTY, DEFAULT_TEST_PASSWORD);
+        return System.getenv().getOrDefault("TEST_USER_PASSWORD", "testPassword123");
     }
 }
Index: src/test/java/org/apolenkov/application/service/StatsServiceTest.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/test/java/org/apolenkov/application/service/StatsServiceTest.java b/src/test/java/org/apolenkov/application/service/StatsServiceTest.java
--- a/src/test/java/org/apolenkov/application/service/StatsServiceTest.java	(revision 132c2c29773f5f4949b3855c362e338d983d3cd4)
+++ b/src/test/java/org/apolenkov/application/service/StatsServiceTest.java	(date 1760122796609)
@@ -14,7 +14,15 @@
     @Test
     @DisplayName("Should create valid session stats")
     void shouldCreateValidSessionStats() {
-        SessionStatsDto stats = SessionStatsDto.of(1L, 10, 8, 1, 60000L, 15000L, null);
+        SessionStatsDto stats = SessionStatsDto.builder()
+                .deckId(1L)
+                .viewed(10)
+                .correct(8)
+                .hard(1)
+                .sessionDurationMs(60000L)
+                .totalAnswerDelayMs(15000L)
+                .knownCardIdsDelta(null)
+                .build();

         assertThat(stats.deckId()).isEqualTo(1L);
         assertThat(stats.viewed()).isEqualTo(10);
@@ -30,7 +38,15 @@
     }

     private void createInvalidSessionStatsWithZeroValues() {
-        SessionStatsDto.of(1L, 0, 0, 0, 0L, 0L, Set.of());
+        SessionStatsDto.builder()
+                .deckId(1L)
+                .viewed(0)
+                .correct(0)
+                .hard(0)
+                .sessionDurationMs(0L)
+                .totalAnswerDelayMs(0L)
+                .knownCardIdsDelta(Set.of())
+                .build();
     }

     @Test
@@ -40,6 +56,14 @@
     }

     private void createInvalidSessionStatsWithZeroDeckId() {
-        SessionStatsDto.of(0L, 10, 8, 0, 0L, 0L, null);
+        SessionStatsDto.builder()
+                .deckId(0L)
+                .viewed(10)
+                .correct(8)
+                .hard(0)
+                .sessionDurationMs(0L)
+                .totalAnswerDelayMs(0L)
+                .knownCardIdsDelta(null)
+                .build();
     }
 }
Index: src/main/java/org/apolenkov/application/config/ApplicationConfiguration.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/org/apolenkov/application/config/ApplicationConfiguration.java b/src/main/java/org/apolenkov/application/config/ApplicationConfiguration.java
--- a/src/main/java/org/apolenkov/application/config/ApplicationConfiguration.java	(revision 132c2c29773f5f4949b3855c362e338d983d3cd4)
+++ b/src/main/java/org/apolenkov/application/config/ApplicationConfiguration.java	(date 1760205041209)
@@ -1,8 +1,15 @@
 package org.apolenkov.application.config;

 import java.time.Clock;
+import org.apolenkov.application.domain.port.DeckRepository;
+import org.apolenkov.application.domain.port.FlashcardRepository;
+import org.apolenkov.application.domain.port.NewsRepository;
+import org.apolenkov.application.domain.port.StatsRepository;
+import org.apolenkov.application.domain.port.UserRepository;
+import org.apolenkov.application.service.seed.DataSeedRepositories;
 import org.springframework.context.annotation.Bean;
 import org.springframework.context.annotation.Configuration;
+import org.springframework.context.annotation.Profile;

 /**
  * Application-wide configuration for common beans and utilities.
@@ -19,4 +26,27 @@
     public Clock clock() {
         return Clock.systemUTC();
     }
+
+    /**
+     * Groups repository dependencies for data seed service.
+     * Only created in dev and test profiles where DataSeedService is active.
+     *
+     * @param userRepository repository for user operations
+     * @param deckRepository repository for deck operations
+     * @param flashcardRepository repository for flashcard operations
+     * @param statsRepository repository for statistics operations
+     * @param newsRepository repository for news operations
+     * @return grouped repository dependencies
+     */
+    @Bean
+    @Profile({"dev", "test"})
+    public DataSeedRepositories dataSeedRepositories(
+            final UserRepository userRepository,
+            final DeckRepository deckRepository,
+            final FlashcardRepository flashcardRepository,
+            final StatsRepository statsRepository,
+            final NewsRepository newsRepository) {
+        return new DataSeedRepositories(
+                userRepository, deckRepository, flashcardRepository, statsRepository, newsRepository);
+    }
 }
Index: src/main/java/org/apolenkov/application/views/core/error/ErrorView.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/org/apolenkov/application/views/core/error/ErrorView.java b/src/main/java/org/apolenkov/application/views/core/error/ErrorView.java
--- a/src/main/java/org/apolenkov/application/views/core/error/ErrorView.java	(revision 132c2c29773f5f4949b3855c362e338d983d3cd4)
+++ b/src/main/java/org/apolenkov/application/views/core/error/ErrorView.java	(date 1760126608880)
@@ -1,16 +1,26 @@
 package org.apolenkov.application.views.core.error;

+import com.vaadin.flow.component.button.Button;
+import com.vaadin.flow.component.button.ButtonVariant;
+import com.vaadin.flow.component.html.H2;
+import com.vaadin.flow.component.html.Span;
+import com.vaadin.flow.component.orderedlayout.FlexComponent;
+import com.vaadin.flow.component.orderedlayout.HorizontalLayout;
 import com.vaadin.flow.component.orderedlayout.VerticalLayout;
 import com.vaadin.flow.router.BeforeEnterEvent;
 import com.vaadin.flow.router.BeforeEnterObserver;
 import com.vaadin.flow.router.HasDynamicTitle;
+import com.vaadin.flow.router.Location;
+import com.vaadin.flow.router.QueryParameters;
 import com.vaadin.flow.router.Route;
 import com.vaadin.flow.server.auth.AnonymousAllowed;
 import jakarta.annotation.PostConstruct;
 import java.util.Arrays;
+import java.util.List;
 import org.apolenkov.application.config.constants.RouteConstants;
 import org.apolenkov.application.views.core.constants.CoreConstants;
 import org.apolenkov.application.views.core.layout.PublicLayout;
+import org.apolenkov.application.views.shared.utils.ButtonHelper;
 import org.apolenkov.application.views.shared.utils.NavigationHelper;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
@@ -18,7 +28,6 @@

 /**
  * Generic error page view with user-friendly error display.
- * Coordinates between specialized components to provide a complete error handling experience.
  * Shows a formatted error message with navigation options.
  * In development profile, displays additional debugging information.
  */
@@ -28,12 +37,16 @@

     private static final Logger LOGGER = LoggerFactory.getLogger(ErrorView.class);
     private final transient Environment environment;
-
-    // Specialized components
-    private final transient ErrorViewState state;
-    private final transient ErrorViewLayout layout;
     private final transient ErrorDevInfo devInfo;

+    // Error state
+    private transient ErrorState errorState;
+
+    // UI Components
+    private H2 errorTitle;
+    private Span errorDescription;
+    private VerticalLayout errorContainer;
+
     /**
      * Creates a new error view.
      *
@@ -41,12 +54,12 @@
      */
     public ErrorView(final Environment env) {
         this.environment = env;
-        this.state = new ErrorViewState();
-        this.layout = new ErrorViewLayout();
         this.devInfo = new ErrorDevInfo(env);
+        this.errorState = new ErrorState("", "", "", "");
     }

     @PostConstruct
+    @SuppressWarnings("unused")
     private void initializeUI() {
         LOGGER.debug("Initializing ErrorView UI components");

@@ -56,7 +69,8 @@
         setPadding(true);
         setSpacing(true);

-        setupLayout();
+        createErrorLayout();
+        add(errorContainer, devInfo);

         LOGGER.debug("ErrorView UI initialization completed");
     }
@@ -65,31 +79,120 @@
     public void beforeEnter(final BeforeEnterEvent event) {
         LOGGER.debug("Processing beforeEnter event for ErrorView");

-        ErrorParameterExtractor.extractParameters(event, state);
+        extractErrorParameters(event);

-        if (!state.hasValidErrorParameters()) {
+        if (!hasValidErrorParameters()) {
             handleRedirectToHome(event);
             return;
         }

-        createNavigationButtons();
+        updateErrorDisplay();
+        addNavigationButtons();
         processErrorBasedOnProfile();
     }

     /**
-     * Sets up the main layout with all components.
+     * Creates the main error layout.
      */
-    private void setupLayout() {
-        add(layout);
-        add(devInfo);
+    private void createErrorLayout() {
+        errorContainer = new VerticalLayout();
+        errorContainer.addClassName(CoreConstants.ERROR_CONTAINER_CLASS);
+        errorContainer.addClassName(CoreConstants.SURFACE_PANEL_CLASS);
+        errorContainer.setSpacing(true);
+        errorContainer.setAlignItems(FlexComponent.Alignment.CENTER);
+
+        errorTitle = new H2();
+        errorTitle.addClassName(CoreConstants.ERROR_VIEW_TITLE_CLASS);
+
+        errorDescription = new Span();
+        errorDescription.addClassName(CoreConstants.ERROR_VIEW_DESCRIPTION_CLASS);
+
+        errorContainer.add(errorTitle, errorDescription);
     }

     /**
-     * Creates navigation buttons with the correct fromRoute from state.
+     * Extracts error parameters from the before enter event.
+     *
+     * @param event the before enter event containing query parameters
      */
-    private void createNavigationButtons() {
-        ErrorNavigationButtons navigationButtons = new ErrorNavigationButtons(state.getFromRoute());
-        layout.addComponent(navigationButtons);
+    private void extractErrorParameters(final BeforeEnterEvent event) {
+        Location location = event.getLocation();
+        QueryParameters queryParams = location.getQueryParameters();
+
+        String fromRoute = extractParameter(queryParams, CoreConstants.FROM_PARAM);
+        String errorType = extractParameter(queryParams, CoreConstants.ERROR_PARAM);
+        String errorMessage = extractParameter(queryParams, CoreConstants.MESSAGE_PARAM);
+        String errorId = extractParameter(queryParams, CoreConstants.ID_PARAM);
+
+        errorState = new ErrorState(fromRoute, errorType, errorMessage, errorId);
+
+        LOGGER.info(
+                "Extracted parameters: fromRoute={}, errorType={}, errorMessage={}, errorId={}",
+                errorState.fromRoute(),
+                errorState.errorType(),
+                errorState.errorMessage(),
+                errorState.errorId());
+    }
+
+    /**
+     * Extracts a single parameter value from query parameters.
+     *
+     * @param queryParams the query parameters
+     * @param paramName the parameter name to extract
+     * @return the parameter value or empty string if not found
+     */
+    private String extractParameter(final QueryParameters queryParams, final String paramName) {
+        return queryParams.getParameters().getOrDefault(paramName, List.of("")).getFirst();
+    }
+
+    /**
+     * Checks if error parameters are valid.
+     *
+     * @return true if valid
+     */
+    private boolean hasValidErrorParameters() {
+        return !errorState.fromRoute().isEmpty() && !errorState.errorType().isEmpty();
+    }
+
+    /**
+     * Updates the error display with error information.
+     */
+    private void updateErrorDisplay() {
+        errorTitle.setText(getTranslation(CoreConstants.ERROR_500_KEY));
+        errorDescription.setText(getTranslation(CoreConstants.ERROR_500_DESCRIPTION_KEY));
+    }
+
+    /**
+     * Adds navigation buttons to the error container.
+     */
+    private void addNavigationButtons() {
+        HorizontalLayout navigationButtons = createNavigationButtons();
+        errorContainer.add(navigationButtons);
+    }
+
+    /**
+     * Creates navigation buttons for error recovery.
+     *
+     * @return configured button layout
+     */
+    private HorizontalLayout createNavigationButtons() {
+        HorizontalLayout layout = new HorizontalLayout();
+        layout.setSpacing(true);
+        layout.setAlignItems(FlexComponent.Alignment.CENTER);
+        layout.setJustifyContentMode(FlexComponent.JustifyContentMode.CENTER);
+
+        Button goHomeButton = ButtonHelper.createButton(
+                getTranslation(CoreConstants.ERROR_GO_HOME_KEY),
+                e -> NavigationHelper.navigateToHome(),
+                ButtonVariant.LUMO_PRIMARY);
+
+        Button tryAgainButton = ButtonHelper.createButton(
+                getTranslation(CoreConstants.ERROR_TRY_AGAIN_KEY),
+                e -> NavigationHelper.navigateTo(errorState.fromRoute()),
+                ButtonVariant.LUMO_TERTIARY);
+
+        layout.add(goHomeButton, tryAgainButton);
+        return layout;
     }

     /**
@@ -117,9 +220,8 @@
      * Processes error in development profile with detailed information.
      */
     private void processDevProfileError() {
-        LOGGER.info("Processing error in dev mode: {}", state);
-        layout.updateWithGenericError();
-        devInfo.updateDevInfo(state);
+        LOGGER.info("Processing error in dev mode: {}", errorState);
+        devInfo.updateDevInfo(errorState);
     }

     /**
@@ -128,10 +230,9 @@
     private void processProductionError() {
         LOGGER.warn(
                 "Error occurred: fromRoute={}, errorType={}, errorId={}",
-                state.getFromRoute(),
-                state.getErrorType(),
-                state.getErrorId());
-        layout.updateWithGenericError();
+                errorState.fromRoute(),
+                errorState.errorType(),
+                errorState.errorId());
         devInfo.hideDevInfo();
     }

@@ -149,4 +250,14 @@
     public String getPageTitle() {
         return getTranslation(CoreConstants.ERROR_500_KEY);
     }
+
+    /**
+     * Error state record for encapsulating error parameters.
+     *
+     * @param fromRoute the route that caused the error
+     * @param errorType the type of error
+     * @param errorMessage the error message
+     * @param errorId the unique error identifier
+     */
+    public record ErrorState(String fromRoute, String errorType, String errorMessage, String errorId) {}
 }
Index: src/main/java/org/apolenkov/application/views/core/navigation/LanguageSwitcher.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/org/apolenkov/application/views/core/navigation/LanguageSwitcher.java b/src/main/java/org/apolenkov/application/views/core/navigation/LanguageSwitcher.java
--- a/src/main/java/org/apolenkov/application/views/core/navigation/LanguageSwitcher.java	(revision 132c2c29773f5f4949b3855c362e338d983d3cd4)
+++ b/src/main/java/org/apolenkov/application/views/core/navigation/LanguageSwitcher.java	(date 1760198497590)
@@ -22,6 +22,7 @@
 import org.apolenkov.application.domain.usecase.UserUseCase;
 import org.apolenkov.application.service.settings.UserSettingsService;
 import org.apolenkov.application.views.core.constants.CoreConstants;
+import org.apolenkov.application.views.shared.utils.AuthRedirectHelper;
 import org.springframework.stereotype.Component;

 /**
@@ -63,6 +64,7 @@
      * dependencies are properly injected before UI initialization.
      */
     @PostConstruct
+    @SuppressWarnings("unused")
     private void init() {
         setSpacing(true);
         setPadding(false);
@@ -202,12 +204,16 @@
         if (userUseCase == null || userSettingsService == null) {
             return;
         }
+        // Skip for anonymous users
+        if (!AuthRedirectHelper.isAuthenticated()) {
+            return;
+        }
         try {
             long userId = userUseCase.getCurrentUser().getId();
             userSettingsService.setPreferredLocale(userId, locale);
         } catch (Exception ex) {
-            // Intentionally ignoring exceptions for anonymous users or when user service is unavailable
-            // This allows the language switcher to work without authentication
+            // Intentionally ignoring exceptions when user service is unavailable
+            // This allows the language switcher to work without database access
         }
     }

Index: build.gradle.kts
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/build.gradle.kts b/build.gradle.kts
--- a/build.gradle.kts	(revision 132c2c29773f5f4949b3855c362e338d983d3cd4)
+++ b/build.gradle.kts	(date 1760199031361)
@@ -94,6 +94,7 @@
     implementation("org.springframework.boot:spring-boot-starter-security")
     implementation("org.springframework.boot:spring-boot-starter-actuator")
     implementation("org.springframework.boot:spring-boot-starter-cache")
+    implementation("com.github.ben-manes.caffeine:caffeine")

     // Persistence
     implementation("org.springframework.boot:spring-boot-starter-jdbc")
Index: src/main/java/org/apolenkov/application/config/data/DataInitializer.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/org/apolenkov/application/config/data/DataInitializer.java b/src/main/java/org/apolenkov/application/config/data/DataInitializer.java
--- a/src/main/java/org/apolenkov/application/config/data/DataInitializer.java	(revision 132c2c29773f5f4949b3855c362e338d983d3cd4)
+++ b/src/main/java/org/apolenkov/application/config/data/DataInitializer.java	(date 1760204623434)
@@ -35,10 +35,10 @@

     private static final Logger LOGGER = LoggerFactory.getLogger(DataInitializer.class);

-    @Value("${demo.admin.password:admin}")
+    @Value("${app.seed.demo.admin-password:admin}")
     private String demoAdminPassword;

-    @Value("${demo.user.password:user}")
+    @Value("${app.seed.demo.user-password:user}")
     private String demoUserPassword;

     /**
@@ -81,7 +81,7 @@
                     ADMIN_NAME,
                     Set.of(SecurityConstants.ROLE_ADMIN));

-            LOGGER.info("✅ Domain users ensured");
+            LOGGER.info("Domain users ensured");
         };
     }

@@ -132,7 +132,7 @@
     private User findDemoUser(final UserRepository users) {
         final Optional<User> opt = users.findByEmail(USER_EMAIL);
         if (opt.isEmpty()) {
-            LOGGER.info("ℹ️ Demo user not found, skipping demo data creation");
+            LOGGER.info("Demo user not found, skipping demo data creation");
             return null;
         }
         return opt.get();
@@ -148,15 +148,22 @@
      */
     private void createDemoDataIfNeeded(
             final User user, final DeckRepository decks, final FlashcardRepository cards, final NewsRepository news) {
+        final String seedDemoData = System.getenv().getOrDefault("SEED_DEMO_DATA", "true");
+
+        if (!"true".equalsIgnoreCase(seedDemoData)) {
+            LOGGER.info("Demo data creation disabled (SEED_DEMO_DATA=false)");
+            return;
+        }
+
         if (!decks.findByUserId(user.getId()).isEmpty()) {
-            LOGGER.info("ℹ️ Demo data already exists, skipping demo data creation");
+            LOGGER.info("Demo data already exists, skipping demo data creation");
             return;
         }

-        LOGGER.info("🌱 Creating demo data...");
+        LOGGER.info("Creating demo data...");
         createDemoDecks(user, decks, cards);
         createWelcomeNews(news);
-        LOGGER.info("✅ Demo data creation completed");
+        LOGGER.info("Demo data creation completed");
     }

     /**
@@ -265,20 +272,19 @@
      * @param dataSeedService service for generating test data
      */
     private void generateTestDataIfEnabled(final DataSeedService dataSeedService) {
-        final String generateTestData =
-                System.getProperty("generate.test.data", System.getenv().getOrDefault("GENERATE_TEST_DATA", "false"));
+        final String generateTestData = System.getenv().getOrDefault("GENERATE_TEST_DATA", "false");

         if (!"true".equalsIgnoreCase(generateTestData)) {
-            LOGGER.info("ℹ️ Test data generation skipped (set -D generate.test.data=true to enable)");
+            LOGGER.info("Test data generation skipped (set GENERATE_TEST_DATA=true to enable)");
             return;
         }

-        LOGGER.info("🌱 Generating test data for load testing...");
+        LOGGER.info("Generating test data for load testing...");
         try {
             dataSeedService.generateTestData();
-            LOGGER.info("✅ Test data generation completed successfully!");
+            LOGGER.info("Test data generation completed successfully");
         } catch (Exception e) {
-            LOGGER.error("❌ Failed to generate test data: {}", e.getMessage(), e);
+            LOGGER.error("Failed to generate test data: {}", e.getMessage(), e);
         }
     }

Index: src/main/java/org/apolenkov/application/infrastructure/repository/jdbc/sql/NewsSqlQueries.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/org/apolenkov/application/infrastructure/repository/jdbc/sql/NewsSqlQueries.java b/src/main/java/org/apolenkov/application/infrastructure/repository/jdbc/sql/NewsSqlQueries.java
--- a/src/main/java/org/apolenkov/application/infrastructure/repository/jdbc/sql/NewsSqlQueries.java	(revision 132c2c29773f5f4949b3855c362e338d983d3cd4)
+++ b/src/main/java/org/apolenkov/application/infrastructure/repository/jdbc/sql/NewsSqlQueries.java	(date 1760197197650)
@@ -32,15 +32,6 @@
             WHERE n.id = ?
             """;

-    /**
-     * SQL query to insert new news article.
-     */
-    public static final String INSERT_NEWS =
-            """
-            INSERT INTO news (title, content, author, created_at, updated_at)
-            VALUES (?, ?, ?, ?, ?)
-            """;
-
     /**
      * SQL query to insert new news article and return generated ID.
      */
@@ -50,6 +41,15 @@
             VALUES (?, ?, ?, ?, ?)
             RETURNING id
             """;
+
+    /**
+     * SQL query to insert new news article for batch operations.
+     */
+    public static final String INSERT_NEWS =
+            """
+            INSERT INTO news (title, content, author, created_at)
+            VALUES (?, ?, ?, ?)
+            """;

     /**
      * SQL query to update existing news article.
Index: src/main/java/org/apolenkov/application/config/cache/CacheConfiguration.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/org/apolenkov/application/config/cache/CacheConfiguration.java b/src/main/java/org/apolenkov/application/config/cache/CacheConfiguration.java
new file mode 100644
--- /dev/null	(date 1760199251913)
+++ b/src/main/java/org/apolenkov/application/config/cache/CacheConfiguration.java	(date 1760199251913)
@@ -0,0 +1,64 @@
+package org.apolenkov.application.config.cache;
+
+import com.github.benmanes.caffeine.cache.Caffeine;
+import java.util.concurrent.TimeUnit;
+import org.springframework.beans.factory.annotation.Value;
+import org.springframework.cache.CacheManager;
+import org.springframework.cache.annotation.EnableCaching;
+import org.springframework.cache.caffeine.CaffeineCacheManager;
+import org.springframework.context.annotation.Bean;
+import org.springframework.context.annotation.Configuration;
+
+/**
+ * Cache configuration using Caffeine for application-level caching.
+ * Provides in-memory cache for frequently accessed data like users.
+ */
+@Configuration
+@EnableCaching
+public class CacheConfiguration {
+
+    /**
+     * Cache name constants.
+     */
+    public static final String USER_CACHE = "users";
+
+    public static final String USER_BY_EMAIL_CACHE = "usersByEmail";
+
+    @Value("${app.cache.user.ttl-minutes:30}")
+    private int userCacheTtlMinutes;
+
+    @Value("${app.cache.user.max-size:1000}")
+    private int userCacheMaxSize;
+
+    /**
+     * Creates and configures Caffeine-based cache manager.
+     * Uses TTL (Time-To-Live) and size-based eviction.
+     *
+     * @return configured cache manager
+     */
+    @Bean
+    public CacheManager cacheManager() {
+        CaffeineCacheManager cacheManager = new CaffeineCacheManager(USER_CACHE, USER_BY_EMAIL_CACHE);
+        cacheManager.setCaffeine(caffeineCacheBuilder());
+        return cacheManager;
+    }
+
+    /**
+     * Configures Caffeine cache with TTL and maximum size.
+     *
+     * <p>Configuration:
+     * <ul>
+     *   <li>TTL: 30 minutes (configurable via property)</li>
+     *   <li>Max size: 1000 entries (configurable via property)</li>
+     *   <li>Stats: enabled for monitoring</li>
+     * </ul>
+     *
+     * @return Caffeine builder with configuration
+     */
+    Caffeine<Object, Object> caffeineCacheBuilder() {
+        return Caffeine.newBuilder()
+                .expireAfterWrite(userCacheTtlMinutes, TimeUnit.MINUTES)
+                .maximumSize(userCacheMaxSize)
+                .recordStats();
+    }
+}
Index: src/main/java/org/apolenkov/application/infrastructure/repository/jdbc/sql/UserSqlQueries.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/org/apolenkov/application/infrastructure/repository/jdbc/sql/UserSqlQueries.java b/src/main/java/org/apolenkov/application/infrastructure/repository/jdbc/sql/UserSqlQueries.java
--- a/src/main/java/org/apolenkov/application/infrastructure/repository/jdbc/sql/UserSqlQueries.java	(revision 132c2c29773f5f4949b3855c362e338d983d3cd4)
+++ b/src/main/java/org/apolenkov/application/infrastructure/repository/jdbc/sql/UserSqlQueries.java	(date 1760198420239)
@@ -42,6 +42,34 @@
             WHERE u.email = ?
             """;

+    /**
+     * SQL query to select user with roles by email (optimized single query).
+     * Uses LEFT JOIN and ARRAY_AGG to fetch user and roles in one query.
+     */
+    public static final String SELECT_USER_WITH_ROLES_BY_EMAIL =
+            """
+            SELECT u.id, u.email, u.password_hash, u.name, u.created_at,
+                   COALESCE(ARRAY_AGG(ur.role ORDER BY ur.role) FILTER (WHERE ur.role IS NOT NULL), ARRAY[]::TEXT[]) as roles
+            FROM users u
+            LEFT JOIN user_roles ur ON ur.user_id = u.id
+            WHERE u.email = ?
+            GROUP BY u.id, u.email, u.password_hash, u.name, u.created_at
+            """;
+
+    /**
+     * SQL query to select user with roles by ID (optimized single query).
+     * Uses LEFT JOIN and ARRAY_AGG to fetch user and roles in one query.
+     */
+    public static final String SELECT_USER_WITH_ROLES_BY_ID =
+            """
+            SELECT u.id, u.email, u.password_hash, u.name, u.created_at,
+                   COALESCE(ARRAY_AGG(ur.role ORDER BY ur.role) FILTER (WHERE ur.role IS NOT NULL), ARRAY[]::TEXT[]) as roles
+            FROM users u
+            LEFT JOIN user_roles ur ON ur.user_id = u.id
+            WHERE u.id = ?
+            GROUP BY u.id, u.email, u.password_hash, u.name, u.created_at
+            """;
+
     /**
      * SQL query to select user roles by user ID.
      */
@@ -63,6 +91,19 @@
             RETURNING id
             """;

+    /**
+     * SQL query to insert new user with conflict handling (for seed/batch operations).
+     * Returns existing ID if email already exists, new ID otherwise.
+     */
+    public static final String INSERT_USER_ON_CONFLICT_RETURNING_ID =
+            """
+            INSERT INTO users (email, password_hash, name, created_at)
+            VALUES (?, ?, ?, ?)
+            ON CONFLICT (email) DO UPDATE
+            SET email = EXCLUDED.email
+            RETURNING id
+            """;
+
     /**
      * SQL query to update existing user.
      */
@@ -89,6 +130,16 @@
             INSERT INTO user_roles (user_id, role)
             VALUES (?, ?)
             """;
+
+    /**
+     * SQL query to insert user role with conflict handling (for seed/batch operations).
+     */
+    public static final String INSERT_USER_ROLE_ON_CONFLICT =
+            """
+            INSERT INTO user_roles (user_id, role)
+            VALUES (?, ?)
+            ON CONFLICT (user_id, role) DO NOTHING
+            """;

     /**
      * SQL query to delete all user roles.
Index: src/main/java/org/apolenkov/application/views/core/navigation/TopMenu.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/org/apolenkov/application/views/core/navigation/TopMenu.java b/src/main/java/org/apolenkov/application/views/core/navigation/TopMenu.java
--- a/src/main/java/org/apolenkov/application/views/core/navigation/TopMenu.java	(revision 132c2c29773f5f4949b3855c362e338d983d3cd4)
+++ b/src/main/java/org/apolenkov/application/views/core/navigation/TopMenu.java	(date 1760122173742)
@@ -21,8 +21,6 @@
 @UIScope
 public class TopMenu extends HorizontalLayout {

-    private Anchor title;
-
     private final transient TopMenuAuthService authService;
     private final transient TopMenuLayoutService layoutService;

@@ -51,21 +49,24 @@
         setAlignItems(Alignment.CENTER);
         setJustifyContentMode(JustifyContentMode.BETWEEN);

-        setupTitle();
         refreshMenu();
     }

     /**
-     * Sets up the title anchor with logo icon.
+     * Creates a new title anchor with logo icon.
+     * Each call creates a fresh instance to avoid component reuse.
+     *
+     * @return new Anchor instance with logo
      */
-    private void setupTitle() {
-        title = new Anchor(RouteConstants.ROOT_PATH, "");
+    private Anchor createTitle() {
+        Anchor anchor = new Anchor(RouteConstants.ROOT_PATH, "");

         Image navIcon = new Image(
                 new StreamResource(VaadinApplicationShell.ResourcePaths.LOGO_ICON_NAME, () -> getClass()
                         .getResourceAsStream(VaadinApplicationShell.ResourcePaths.LOGO_ICON_FULL_PATH)),
                 getTranslation(CoreConstants.APP_TITLE_KEY));
-        title.add(navIcon);
+        anchor.add(navIcon);
+        return anchor;
     }

     /**
@@ -73,6 +74,7 @@
      * This method is called after route changes to ensure the menu accurately
      * reflects the user's current authentication status. Delegates to layout service
      * for UI component creation and coordination.
+     * Creates fresh component instances to avoid state tree corruption.
      */
     public void refreshMenu() {
         removeAll();
@@ -80,8 +82,11 @@
         Authentication auth = authService.getCurrentAuthentication();
         boolean isAuthenticated = authService.isAuthenticated(auth);

+        // Create fresh title anchor each time to avoid component reuse
+        Anchor freshTitle = createTitle();
+
         HorizontalLayout leftSection = layoutService.createLeftSection(
-                title, auth, isAuthenticated, getTranslation(CoreConstants.MAIN_GREETING_KEY));
+                freshTitle, auth, isAuthenticated, getTranslation(CoreConstants.MAIN_GREETING_KEY));

         HorizontalLayout buttonsSection = layoutService.createMenuButtonsLayout(auth, isAuthenticated);

Index: src/main/java/org/apolenkov/application/infrastructure/repository/jdbc/sql/FlashcardSqlQueries.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/org/apolenkov/application/infrastructure/repository/jdbc/sql/FlashcardSqlQueries.java b/src/main/java/org/apolenkov/application/infrastructure/repository/jdbc/sql/FlashcardSqlQueries.java
--- a/src/main/java/org/apolenkov/application/infrastructure/repository/jdbc/sql/FlashcardSqlQueries.java	(revision 132c2c29773f5f4949b3855c362e338d983d3cd4)
+++ b/src/main/java/org/apolenkov/application/infrastructure/repository/jdbc/sql/FlashcardSqlQueries.java	(date 1760195528829)
@@ -80,4 +80,17 @@
             FROM flashcards
             WHERE deck_id = ?
             """;
+
+    /**
+     * SQL query to count flashcards for multiple decks in single query.
+     * Returns only decks that have flashcards (decks with 0 flashcards are excluded).
+     * Note: Requires dynamic SQL for IN clause (deckIds parameter).
+     */
+    public static final String COUNT_FLASHCARDS_BY_DECK_IDS_TEMPLATE =
+            """
+            SELECT deck_id, COUNT(*) as count
+            FROM flashcards
+            WHERE deck_id IN (%s)
+            GROUP BY deck_id
+            """;
 }
Index: src/main/java/org/apolenkov/application/config/vaadin/VaadinApplicationShell.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/org/apolenkov/application/config/vaadin/VaadinApplicationShell.java b/src/main/java/org/apolenkov/application/config/vaadin/VaadinApplicationShell.java
--- a/src/main/java/org/apolenkov/application/config/vaadin/VaadinApplicationShell.java	(revision 132c2c29773f5f4949b3855c362e338d983d3cd4)
+++ b/src/main/java/org/apolenkov/application/config/vaadin/VaadinApplicationShell.java	(date 1760184406791)
@@ -65,10 +65,5 @@
         settings.addMetaTag("keywords", "flashcards, learning, education, memorization");
         settings.addMetaTag("author", "Memocards Team");
         settings.addMetaTag("viewport", "width=device-width, initial-scale=1.0");
-
-        // PWA support
-        settings.addMetaTag("theme-color", "#1976d2");
-        settings.addMetaTag("apple-mobile-web-app-capable", "yes");
-        settings.addMetaTag("apple-mobile-web-app-status-bar-style", "default");
     }
 }
Index: src/main/java/org/apolenkov/application/views/stats/pages/StatsView.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/org/apolenkov/application/views/stats/pages/StatsView.java b/src/main/java/org/apolenkov/application/views/stats/pages/StatsView.java
--- a/src/main/java/org/apolenkov/application/views/stats/pages/StatsView.java	(revision 132c2c29773f5f4949b3855c362e338d983d3cd4)
+++ b/src/main/java/org/apolenkov/application/views/stats/pages/StatsView.java	(date 1760129814237)
@@ -37,7 +37,6 @@
 public class StatsView extends BaseView {

     private static final Logger LOGGER = LoggerFactory.getLogger(StatsView.class);
-    private static final Logger AUDIT_LOGGER = LoggerFactory.getLogger("org.apolenkov.application.audit");

     // Services
     private final transient DeckUseCase deckUseCase;
@@ -74,7 +73,6 @@
     @SuppressWarnings("unused")
     private void initializeUI() {
         LOGGER.debug("Initializing stats view UI");
-        AUDIT_LOGGER.info("User accessed statistics page");

         setSpacing(true);
         setAlignItems(FlexComponent.Alignment.CENTER);
Index: src/main/java/org/apolenkov/application/infrastructure/repository/jdbc/sql/StatsSqlQueries.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/org/apolenkov/application/infrastructure/repository/jdbc/sql/StatsSqlQueries.java b/src/main/java/org/apolenkov/application/infrastructure/repository/jdbc/sql/StatsSqlQueries.java
--- a/src/main/java/org/apolenkov/application/infrastructure/repository/jdbc/sql/StatsSqlQueries.java	(revision 132c2c29773f5f4949b3855c362e338d983d3cd4)
+++ b/src/main/java/org/apolenkov/application/infrastructure/repository/jdbc/sql/StatsSqlQueries.java	(date 1760195528832)
@@ -53,6 +53,19 @@
             WHERE f.deck_id = ?
             """;

+    /**
+     * SQL query to select known card IDs for multiple decks in single query.
+     * Returns both deck_id and card_id for grouping by deck.
+     * Note: Requires dynamic SQL for IN clause (deckIds parameter).
+     */
+    public static final String SELECT_KNOWN_CARD_IDS_BATCH_TEMPLATE =
+            """
+            SELECT f.deck_id, kc.card_id
+            FROM known_cards kc
+            JOIN flashcards f ON kc.card_id = f.id
+            WHERE f.deck_id IN (%s)
+            """;
+
     /**
      * SQL query to delete known card.
      */
