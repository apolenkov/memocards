---
alwaysApply: true
efficiency: "maximum"
autoFix: true
proactive: true
---

# PROJECT RULES - Java 21 + Spring Boot 3 + Vaadin 24 + PostgreSQL

## TECHNOLOGY STACK
- Framework: Java 21 + Spring Boot 3.x + Maven
- Dependencies: Spring Web, Spring Data JPA, Vaadin 24, Lombok, PostgreSQL
- UI: Vaadin 24+ DSL preferred over JavaScript
- Database: PostgreSQL with JSONB, arrays, full-text search
- Logging: SLF4J/Logback only

## ARCHITECTURE PRINCIPLES
- SOLID, DRY, KISS, YAGNI principles always
- Clean Architecture: Domain > Application > Infrastructure > UI
- Constructor injection only, no @Autowired fields
- Class limits: <300 lines, <10 methods, <5 params, <3 nesting levels
- Break tasks into smallest units, solve step by step

## LAYER RESPONSIBILITIES
- Controllers: Request/response handling only
- Services: Business logic, use repositories only
- Repositories: Database operations only
- Entities: Data carriers from database only
- DTOs: Data transfer between layers only

## ENTITY RULES
- @Entity annotation required
- @Data from Lombok (unless specified otherwise)
- @Id @GeneratedValue(strategy=GenerationType.IDENTITY)
- FetchType.LAZY for relationships
- Proper validation annotations: @Size, @NotEmpty, @Email

## REPOSITORY RULES
- @Repository annotation required
- Interface type only
- Extend JpaRepository<Entity, ID>
- JPQL for @Query methods
- @EntityGraph for relationships to avoid N+1
- Use DTOs for multi-join queries

## SERVICE RULES
- Interface type for service classes
- @Service annotation on implementations
- Constructor injection only
- Return DTOs, not entities
- Use .orElseThrow() for existence checks
- @Transactional for multiple database operations

## CONTROLLER RULES
- @RestController annotation required
- @RequestMapping for class-level routes
- RESTful paths: GET /users/{id}, POST /users, PUT /users/{id}, DELETE /users/{id}
- Constructor injection only
- Try-catch blocks for all methods
- Handle errors with GlobalExceptionHandler

## PERFORMANCE
- Virtual Threads for I/O operations
- Caching strategy implementation
- Async operations with CompletableFuture
- Connection pooling with HikariCP

## TESTING
- Pyramid: 70% unit, 20% integration, 10% e2e
- Coverage: 80% minimum
- AssertJ best practices: isZero(), getFirst(), List.of()
- TestContainers for integration tests

## UI/UX
- i18n: getTranslation() only, no hardcoded strings
- Lumo theme tokens
- Accessibility: ARIA labels
- Responsive design: mobile-first

## PROHIBITIONS
- NO System.out.println - use SLF4J/Logback
- NO FQN - add imports
- NO hardcoded UI strings - use getTranslation()
- NO @Autowired fields - constructor injection only
- NO primitives nullable - use wrapper types
- NO SQL concatenation - parameterized queries
- NO dead/commented code - remove
- NO code duplication - extract

## COMMUNICATION
- Russian chat, English code
- JavaDoc concise and substantive
- Structured logging with context

## REFACTORING RULES
- KISS > Complex Architecture: Simple solutions over over-engineering
- Class size: <300 lines main, <100 lines services
- Separation: Single responsibility per class
- Vaadin patterns: Use getTranslation() over custom TranslationService
- UI context: Always UI.getCurrent().add(dialog) before dialog.open()
- Checkstyle: Fix all violations - MissingJavadoc, HiddenField, DesignForExtension
- Constants: Extract test-ids, CSS classes, routes - NOT log messages
- Anti-patterns: No circular dependencies, no mixed responsibilities

## OVER-ENGINEERING PREVENTION
- Avoid services for simple tasks (TranslationService for basic i18n)
- Don't create wrappers for single operations
- Use composition over inheritance for data classes
- Pass dependencies as parameters when possible
- Warning signs: >100 line services, 4+ method parameters, circular deps

## üöÄ MAXIMUM EFFICIENCY COMMANDS

### ‚ö° Main Commands (5 seconds)
- **"Apply all rules"** ‚Üí automatic application of all rules
- **"Check quality"** ‚Üí complete code quality check
- **"Optimize performance"** ‚Üí automatic performance optimization
- **"Add tests"** ‚Üí complete test coverage
- **"Fix all issues"** ‚Üí proactive issue resolution

### üéØ Specific Commands
- **"Check SOLID"** ‚Üí SOLID principles validation
- **"Validate architecture"** ‚Üí Clean Architecture validation
- **"Java 21+ features"** ‚Üí modern Java patterns check
- **"Spring Boot 3.x"** ‚Üí Spring Boot 3.x standards validation
- **"Security check"** ‚Üí OWASP compliance check
- **"Virtual threads"** ‚Üí virtual threads implementation check
- **"PostgreSQL optimization"** ‚Üí PostgreSQL performance optimization
- **"Test coverage"** ‚Üí test coverage check
- **"Check i18n"** ‚Üí internationalization check
- **"Vaadin standards"** ‚Üí Vaadin 24+ standards application

### üî• Automatic Actions
For each file mentioned, I automatically:
1. ‚úÖ Apply all relevant rules
2. ‚úÖ Check code quality
3. ‚úÖ Fix found issues
4. ‚úÖ Suggest architectural improvements
5. ‚úÖ Add missing tests
6. ‚úÖ Implement i18n for all strings
7. ‚úÖ Setup proper logging
8. ‚úÖ Check security
9. ‚úÖ Optimize performance
10. ‚úÖ Add documentation

## üìè CLASS SIZE LIMITS & REFACTORING RULES

### Class Size Limits (Google & Industry Standards):
- **Maximum 300 lines** per class (Google Style Guide)
- **Maximum 15 cognitive complexity** per method (SonarLint)
- **Maximum 10 methods** per class (Clean Code principle)
- **Maximum 5 parameters** per method (Clean Code principle)
- **Maximum 3 levels** of nesting (Clean Code principle)

### Automatic Refactoring Triggers:
- ‚úÖ **Class > 300 lines** ‚Üí Extract components/services
- ‚úÖ **Method > 15 cognitive complexity** ‚Üí Split into smaller methods
- ‚úÖ **Class > 10 methods** ‚Üí Apply Single Responsibility Principle
- ‚úÖ **Method > 5 parameters** ‚Üí Use Builder pattern or DTO
- ‚úÖ **Nesting > 3 levels** ‚Üí Extract methods or use early returns

### Refactoring Strategies:
1. **Extract Method** - split large methods
2. **Extract Class** - split large classes
3. **Extract Interface** - separate concerns
4. **Builder Pattern** - reduce parameter count
5. **Strategy Pattern** - reduce conditional complexity
6. **Factory Pattern** - simplify object creation

## üè∑Ô∏è SEARCH BY TAGS

### #java #spring
- SOLID Principles, Clean Architecture, Constructor Injection
- Java 21+ patterns: Virtual Threads, Pattern Matching, Records
- Spring Boot 3.x: Jakarta EE 10, Native compilation, AOT compilation

### #security #owasp
- OWASP Top 10 2024 compliance, Input Validation
- SQL Injection Protection, XSS Prevention
- Modern authentication: OAuth2, JWT, MFA

### #performance #monitoring
- Virtual Threads, Caching Strategy, Async Processing
- Database Optimization, APM, PostgreSQL optimization

### #testing #qa
- Testing Pyramid: 70% Unit, 20% Integration, 10% E2E
- Coverage: minimum 80%, AAA Pattern, Test Containers
- AssertJ Best Practices: isZero(), getFirst(), List.of()

### #ui #ux #vaadin
- Vaadin 24+ DSL, TypeScript support, Lumo Theme
- i18n through getTranslation(), Accessibility, PWA features

### #database #jpa #postgresql
- JPA Entity Design, Repository Layer, DTOs
- PostgreSQL features: JSONB, arrays, full-text search
- Connection pooling, Database migrations

## üéØ MAXIMUM EFFICIENCY RESULT

Now I am **SUPER-OPTIMIZED** and apply **ALL rules automatically**:
- ‚úÖ **Automatically apply** all rules when files are mentioned
- ‚úÖ **Fix issues** proactively without request
- ‚úÖ **Suggest improvements** constantly
- ‚úÖ **Follow enterprise standards** always
- ‚úÖ **Work at SENIOR+ level** constantly
- ‚úÖ **Maximally efficient** in chat

**Try now** - mention any file or task, and I will automatically apply ALL rules at senior+ level! üöÄüî•