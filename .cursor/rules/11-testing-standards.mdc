---
description: Comprehensive testing strategy, quality assurance and test automation standards
globs: ["**/test/**", "**/src/test/**", "**/testdata/**"]
alwaysApply: true
---

# Testing & Quality Assurance Standards

## Testing Pyramid Strategy
- **Unit Tests (70%)**: Fast, isolated tests for individual components
- **Integration Tests (20%)**: Tests for component interactions
- **End-to-End Tests (10%)**: Full system workflow tests
- **Performance Tests**: Load, stress, and endurance testing
- **Security Tests**: Vulnerability scanning and penetration testing

## Unit Testing Standards
- **Test Naming**: Use descriptive test names that explain the scenario
- **AAA Pattern**: Arrange, Act, Assert structure
- **Single Responsibility**: Each test should verify one behavior
- **Test Data Builders**: Use builders for consistent test data
- **Mocking Strategy**: Mock external dependencies, not internal logic

## Integration Testing
- **Database Testing**: Use test containers or in-memory databases
- **API Testing**: Test REST endpoints with realistic data
- **Service Integration**: Test service layer interactions
- **Transaction Testing**: Verify transaction boundaries and rollbacks
- **External Service Mocking**: Mock third-party services

## Test Data Management
- **Test Data Builders**: Create consistent, reusable test data
- **Test Fixtures**: Use fixtures for common test scenarios
- **Data Cleanup**: Ensure tests don't leave data behind
- **Test Isolation**: Each test should be independent
- **Realistic Data**: Use data that represents production scenarios

## Code Examples

### ✅ Unit Test Structure
```java
@ExtendWith(MockitoExtension.class)
class UserServiceTest {
    
    @Mock
    private UserRepository userRepository;
    
    @Mock
    private UserMapper userMapper;
    
    @Mock
    private PasswordEncoder passwordEncoder;
    
    @InjectMocks
    private UserService userService;
    
    @Test
    @DisplayName("Should create user successfully when valid request provided")
    void shouldCreateUserSuccessfully() {
        // Arrange
        CreateUserRequest request = CreateUserRequest.builder()
            .email("test@example.com")
            .password("password123")
            .firstName("John")
            .lastName("Doe")
            .build();
        
        User user = User.builder()
            .id(1L)
            .email("test@example.com")
            .firstName("John")
            .lastName("Doe")
            .build();
        
        UserDto expectedDto = UserDto.builder()
            .id(1L)
            .email("test@example.com")
            .firstName("John")
            .lastName("Doe")
            .build();
        
        when(userRepository.existsByEmail("test@example.com")).thenReturn(false);
        when(userMapper.toEntity(request)).thenReturn(user);
        when(passwordEncoder.encode("password123")).thenReturn("encodedPassword");
        when(userRepository.save(user)).thenReturn(user);
        when(userMapper.toDto(user)).thenReturn(expectedDto);
        
        // Act
        UserDto result = userService.createUser(request);
        
        // Assert
        assertThat(result).isNotNull();
        assertThat(result.getId()).isEqualTo(1L);
        assertThat(result.getEmail()).isEqualTo("test@example.com");
        assertThat(result.getFirstName()).isEqualTo("John");
        assertThat(result.getLastName()).isEqualTo("Doe");
        
        verify(userRepository).existsByEmail("test@example.com");
        verify(userMapper).toEntity(request);
        verify(passwordEncoder).encode("password123");
        verify(userRepository).save(user);
        verify(userMapper).toDto(user);
        verifyNoMoreInteractions(userRepository, userMapper, passwordEncoder);
    }
    
    @Test
    @DisplayName("Should throw exception when user with email already exists")
    void shouldThrowExceptionWhenUserWithEmailAlreadyExists() {
        // Arrange
        CreateUserRequest request = CreateUserRequest.builder()
            .email("existing@example.com")
            .password("password123")
            .firstName("John")
            .lastName("Doe")
            .build();
        
        when(userRepository.existsByEmail("existing@example.com")).thenReturn(true);
        
        // Act & Assert
        BusinessException exception = assertThrows(BusinessException.class, 
            () -> userService.createUser(request));
        
        assertThat(exception.getErrorCode()).isEqualTo("USER_EMAIL_EXISTS");
        assertThat(exception.getUserMessage()).isEqualTo("User with this email already exists");
        
        verify(userRepository).existsByEmail("existing@example.com");
        verifyNoMoreInteractions(userRepository, userMapper, passwordEncoder);
    }
}
```

### ✅ Integration Test Example
```java
@SpringBootTest
@AutoConfigureTestDatabase(replace = AutoConfigureTestDatabase.Replace.NONE)
@Testcontainers
class UserServiceIntegrationTest {
    
    @Container
    static PostgreSQLContainer<?> postgres = new PostgreSQLContainer<>("postgres:15")
        .withDatabaseName("testdb")
        .withUsername("testuser")
        .withPassword("testpass");
    
    @Autowired
    private UserService userService;
    
    @Autowired
    private UserRepository userRepository;
    
    @Autowired
    private TestEntityManager entityManager;
    
    @Test
    @Transactional
    @DisplayName("Should create and retrieve user from database")
    void shouldCreateAndRetrieveUserFromDatabase() {
        // Arrange
        CreateUserRequest request = CreateUserRequest.builder()
            .email("integration@example.com")
            .password("password123")
            .firstName("Integration")
            .lastName("Test")
            .build();
        
        // Act
        UserDto createdUser = userService.createUser(request);
        
        // Assert
        assertThat(createdUser).isNotNull();
        assertThat(createdUser.getId()).isNotNull();
        assertThat(createdUser.getEmail()).isEqualTo("integration@example.com");
        
        // Verify persistence
        User savedUser = userRepository.findById(createdUser.getId()).orElse(null);
        assertThat(savedUser).isNotNull();
        assertThat(savedUser.getEmail()).isEqualTo("integration@example.com");
        assertThat(savedUser.getFirstName()).isEqualTo("Integration");
        assertThat(savedUser.getLastName()).isEqualTo("Test");
    }
    
    @Test
    @Transactional
    @DisplayName("Should handle concurrent user creation with unique constraint")
    void shouldHandleConcurrentUserCreationWithUniqueConstraint() {
        // Arrange
        CreateUserRequest request = CreateUserRequest.builder()
            .email("concurrent@example.com")
            .password("password123")
            .firstName("Concurrent")
            .lastName("Test")
            .build();
        
        // Act & Assert
        UserDto firstUser = userService.createUser(request);
        assertThat(firstUser).isNotNull();
        
        // Try to create another user with same email
        BusinessException exception = assertThrows(BusinessException.class, 
            () -> userService.createUser(request));
        
        assertThat(exception.getErrorCode()).isEqualTo("USER_EMAIL_EXISTS");
    }
}
```

### ✅ Test Data Builder
```java
public class UserTestDataBuilder {
    
    private Long id = 1L;
    private String email = "test@example.com";
    private String passwordHash = "encodedPassword";
    private String firstName = "John";
    private String lastName = "Doe";
    private UserStatus status = UserStatus.ACTIVE;
    private Long version = 0L;
    private LocalDateTime createdAt = LocalDateTime.now();
    private LocalDateTime updatedAt = LocalDateTime.now();
    private String createdBy = "test-user";
    private String updatedBy = "test-user";
    
    public UserTestDataBuilder withId(Long id) {
        this.id = id;
        return this;
    }
    
    public UserTestDataBuilder withEmail(String email) {
        this.email = email;
        return this;
    }
    
    public UserTestDataBuilder withFirstName(String firstName) {
        this.firstName = firstName;
        return this;
    }
    
    public UserTestDataBuilder withLastName(String lastName) {
        this.lastName = lastName;
        return this;
    }
    
    public UserTestDataBuilder withStatus(UserStatus status) {
        this.status = status;
        return this;
    }
    
    public User build() {
        return User.builder()
            .id(id)
            .email(email)
            .passwordHash(passwordHash)
            .firstName(firstName)
            .lastName(lastName)
            .status(status)
            .version(version)
            .createdAt(createdAt)
            .updatedAt(updatedAt)
            .createdBy(createdBy)
            .updatedBy(updatedBy)
            .build();
    }
    
    public static UserTestDataBuilder aUser() {
        return new UserTestDataBuilder();
    }
    
    public static User aDefaultUser() {
        return aUser().build();
    }
    
    public static User anAdminUser() {
        return aUser()
            .withEmail("admin@example.com")
            .withFirstName("Admin")
            .withLastName("User")
            .build();
    }
}
```

## Test Coverage Requirements
- **Line Coverage**: Minimum 80% for business logic
- **Branch Coverage**: Minimum 70% for critical paths
- **Mutation Testing**: Use PIT for mutation testing
- **Code Quality**: Maintain high code quality in tests
- **Documentation**: Document complex test scenarios

## Performance Testing
- **Load Testing**: Test with expected user volumes
- **Stress Testing**: Find system breaking points
- **Endurance Testing**: Test for memory leaks
- **Spike Testing**: Test sudden traffic increases
- **Performance Budgets**: Set and maintain performance budgets

## Security Testing
- **Vulnerability Scanning**: Regular dependency and code scanning
- **Penetration Testing**: Regular security assessments
- **Authentication Testing**: Test all authentication flows
- **Authorization Testing**: Verify access control
- **Input Validation Testing**: Test all input validation

## Test Automation
- **CI/CD Integration**: Automated testing in build pipeline
- **Test Reporting**: Comprehensive test result reporting
- **Test Maintenance**: Regular test maintenance and updates
- **Test Parallelization**: Parallel test execution for speed
- **Test Environment Management**: Automated test environment setup
