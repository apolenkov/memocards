---
alwaysApply: true
autoFix: true
version: "4.0.0"
---

# VAADIN 24+ BEST PRACTICES

## PATTERNS
Composite<T> + initContent() | Builder | Factory

## LIFECYCLE (CRITICAL!)

### For @Route Views (Navigation Targets):
1. **Constructor** → DI + setup UI structure (getTranslation() safe)
2. **beforeEnter(BeforeEnterEvent)** → validation, access control, redirects ⭐ (called ONCE per navigation)
3. **afterNavigation(AfterNavigationEvent)** → load data, update UI ⭐ (called ONCE per navigation, NO flag needed!)
4. **onDetach()** → Registration.remove() MANDATORY

```java
@Route("users")
public class UsersView extends VerticalLayout implements AfterNavigationObserver {
    
    public UsersView(UserService service) {
        // Constructor: DI + UI structure
        setupUI();
    }
    
    @Override
    public void afterNavigation(AfterNavigationEvent event) {
        // ✅ Called ONCE after navigation - NO hasBeenInitialized flag needed!
        loadData();
    }
}
```

### For @UIScope Components (NON-@Route):
1. **Constructor** → data ONLY (NO UI, NO getTranslation())
2. **onAttach()** → init UI + use `hasBeenInitialized` flag ⭐ (onAttach called MULTIPLE times)
3. **onDetach()** → Registration.remove() MANDATORY

```java
@Component
@UIScope
public class ChatWidget extends Div {
    
    private boolean hasBeenInitialized = false; // ⭐ FLAG REQUIRED!
    private Registration broadcasterReg;
    
    @Override
    protected void onAttach(AttachEvent attachEvent) {
        super.onAttach(attachEvent);
        
        if (!hasBeenInitialized) {
            hasBeenInitialized = true;
            initUI();
            setupListeners();
        }
    }
    
    @Override
    protected void onDetach(DetachEvent detachEvent) {
        super.onDetach(detachEvent);
        if (broadcasterReg != null) {
            broadcasterReg.remove();
        }
    }
}
```

**Why `hasBeenInitialized` for @UIScope?**
- onAttach() called EVERY time component attached/reattached
- Vaadin provides NO built-in mechanism to check if already initialized
- Standard community practice (confirmed by research & documentation)
- Alternative `getComponentCount()` is UNRELIABLE (doesn't track listeners, breaks on removeAll())

**@Route Views:** ✅ Use `afterNavigation()` - built-in, called ONCE  
**@UIScope:** ✅ Use `onAttach()` + `hasBeenInitialized` flag - no built-in solution

## MEMORY (CRITICAL!)
- **onDetach**: `if(reg!=null) reg.remove()` + `super.onDetach(e)`
- **Fields**: IDs only (NO collections/objects)
- **Cleanup**: Always remove listeners

## PERFORMANCE
- **Lazy Loading**: `grid.setItems(query→service.find(PageRequest))`
- **Virtual Scroll**: `grid.setPageSize(50)`
- **Flat Hierarchy**: max 3 nesting levels
- **Batch Updates**: Group UI updates
- **Smart Refresh**: Use `refreshMenuIfNeeded()` for navigation components to prevent unnecessary re-rendering

### Navigation Component Optimization
For navigation components (DesktopNavigationBar, MobileNavigationMenu) that are part of AppLayout:

```java
// Track state to prevent unnecessary refreshes
private boolean wasAuthenticated = false;

public void refreshMenuIfNeeded() {
    Authentication auth = authService.getCurrentAuthentication();
    boolean isAuthenticated = authService.isAuthenticated(auth);
    
    // Only refresh if authentication state changed
    if (isAuthenticated != wasAuthenticated) {
        refreshMenu();
        wasAuthenticated = isAuthenticated;
    }
}
```

**Why**: Prevents UI flickering and improves performance by avoiding unnecessary DOM updates.

## UI/UX
- **Lumo Tokens**: `var(--lumo-*)` for all styling
- **Factory Pattern**: `ButtonHelper.create*()`
- **Responsive**: Mobile-first design
- **Accessibility**: ARIA labels, proper contrast

## i18n
- **UI**: getTranslation("key") directly
- **NEVER**: Hardcoded strings → NPE in constructor

## SECURITY (CRITICAL!)
- @AnonymousAllowed, @PermitAll, @RolesAllowed on @Route classes
- Check permissions in beforeEnter() for dynamic authorization
- NEVER rely on UI visibility (hidden != secure)
- Always validate on server side

### CSRF
- Enabled by default (Vaadin handles it)
- Don't disable unless you know what you're doing

### XSS Prevention
- getTranslation() auto-escapes HTML
- Html() component: ONLY for trusted content
- Sanitize user input: OWASP Java HTML Sanitizer
- NEVER use setInnerHtml() with user data

### Session Security
- Invalidate on logout: `VaadinSession.getCurrent().close()`
- Set timeout: `server.servlet.session.timeout=30m`
- Use HTTPS in production (redirect HTTP → HTTPS)

### Input Validation
- Server validation + Binder (client validation = UX, not security)
- Validate all inputs (text fields, file uploads, URL parameters)
- Use Bean Validation (@NotNull, @Size, @Email)

## @UIScope (Spring)
**Use:** @Component + reused across @Route + needs UI.getCurrent()  
**Don't use:** @Route views, Dialogs, Stateless Services  
**Multi-tab:** @UIScope = per tab, @SessionScope = shared tabs

**Pattern:** Factory или non-UI logic only (NO extends HorizontalLayout)

## @Lazy
Use: @UIScope deps, circular deps, heavy resources

## PUSH
```java
UI ui = UI.getCurrent(); executor.submit(() -> ui.access(() -> update()));
```
**Performance:** ~1-2MB per connection, max 10K-50K users. Use @Push(PushMode.MANUAL) for control.

## DIALOG PATTERN
- ✅ Factory: `new Dialog()` each time
- ✅ In View: `new MyDialog(...)` directly
- ❌ `@Component extends Dialog` = singleton, state corruption

## COMPONENT REUSE
- ❌ `removeAll() + add(sameComponent)` = memory leak
- ✅ `setVisible(false/true)` OR recreate with `new`

## MULTIPLE INSTANCES (@UIScope)
**❌ Spring НЕ создаёт 2+ @UIScope экземпляра одного класса!**

**Решения:**
1. Один компонент + CSS visibility
2. Два РАЗНЫХ класса (Desktop*/Mobile*)
3. Factory pattern: `factory.create()`

## CRITICAL ANTIPATTERNS
1. getTranslation() in @UIScope constructor → NPE (OK in @Route constructor)
2. Listeners without cleanup → memory leak
3. UI.getCurrent() in thread → NPE
4. grid.setItems(all) for >100 → OOM (use lazy)
5. Forget super.onDetach(e) → memory leak
6. @Component + extends Dialog → singleton, state corruption
7. removeAll() + add(sameComponent) → memory leak
8. Component field in singleton → reuse across sessions
9. Html() with user data → XSS
10. Hidden fields for security → UI hiding != secure
11. **@PostConstruct в @UIScope** → UI not ready (use onAttach)
12. **onAttach без hasBeenInitialized для @UIScope** → double init, duplicate listeners
13. **Один @UIScope в двух parent** → component moves (create 2 instances)
14. **getComponentCount() для проверки инициализации** → unreliable (listeners not counted, breaks on removeAll())

## CHECKLIST

### For @Route Views:
- [ ] Implement AfterNavigationObserver for data loading (NO flag needed)
- [ ] Implement BeforeEnterObserver for validation/access control
- [ ] onDetach + Registration.remove() if using listeners
- [ ] Server validation + @RolesAllowed
- [ ] getTranslation() for all strings (safe in constructor)

### For @UIScope Components:
- [ ] onAttach (NOT @PostConstruct) + hasBeenInitialized flag
- [ ] onDetach + Registration.remove() MANDATORY
- [ ] NO getTranslation() in constructor (use onAttach)
- [ ] NO UI initialization in constructor

### General:
- [ ] Lazy loading if >100 items
- [ ] Lumo tokens (no hardcode)
- [ ] @Lazy for @UIScope deps only
- [ ] Dialog via new (NOT @Component)
- [ ] Sanitize HTML if using Html()
- [ ] HTTPS + session timeout in production
