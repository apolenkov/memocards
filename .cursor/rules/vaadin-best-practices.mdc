---
alwaysApply: true
autoFix: true
version: "2.1.0"
---

# VAADIN 24+ BEST PRACTICES

## PATTERNS
Composite<T> + initContent() | Builder | Factory

## LIFECYCLE (CRITICAL!)
1. Constructor → data ONLY (NO UI)
2. @PostConstruct (Spring) or initContent() → getTranslation() safe
3. onAttach → register listeners
4. onDetach → Registration.remove() MANDATORY

## MEMORY [CRITICAL]
- onDetach: `if(reg!=null) reg.remove()` + `super.onDetach(e)`
- Fields: IDs only (NO collections/objects)

## PERFORMANCE
- Lazy: `grid.setItems(query→service.find(PageRequest))`
- Virtual scroll: `grid.setPageSize(50)`
- Flat hierarchy: max 3 nesting

## UI/UX
- Lumo tokens: `var(--lumo-*)`
- Factory: `ButtonHelper.create*()`
- Responsive: mobile-first

## i18n
- UI: `getTranslation("key")` directly
- [BAD] Hardcoded strings → NPE in constructor

## SECURITY [CRITICAL]

**Authorization:**
- @AnonymousAllowed, @PermitAll, @RolesAllowed on @Route classes
- Check permissions in beforeEnter() for dynamic authorization
- NEVER rely on UI visibility for security (hidden != secure)
- Always validate on server side

**CSRF:**
- Enabled by default (Vaadin handles it)
- Don't disable unless you know what you're doing

**XSS Prevention:**
- getTranslation() auto-escapes HTML
- Html() component: ONLY for trusted content
- Sanitize user input: OWASP Java HTML Sanitizer
- Never use setInnerHtml() with user data

**Session Security:**
- Invalidate session on logout: VaadinSession.getCurrent().close()
- Set session timeout: server.servlet.session.timeout=30m
- Use HTTPS in production (redirect HTTP → HTTPS)

**Input Validation:**
- Server validation + Binder (client validation is UX, not security)
- Validate all user inputs (text fields, file uploads, URL parameters)
- Use Bean Validation annotations (@NotNull, @Size, @Email)


## @UIScope (Spring)

**Use when [OK]:**
- @Component + Reused across @Route views + Needs UI.getCurrent()
- @Lazy for @UIScope injection into @Component
- LocaleChangeObserver: only with @UIScope WITHOUT page.reload()
- Single-user cache (one browser window)

**Don't use [BAD]:**
- @Route views (created by Vaadin)
- Dialogs (short lifecycle)
- Reusable Components (created in View)
- Stateless Services (singleton sufficient)
- Multi-tab shared cache → use @SessionScope instead

**Multi-tab considerations:**
- @UIScope creates separate instance per browser tab/window
- For shared data across tabs → use @SessionScope
- For global data → use @ApplicationScope with user-specific keys

```java
// ❌ BAD: Component extends UI component
@Component @UIScope class Menu extends HorizontalLayout { }

// ✅ GOOD: Factory pattern
@Component @UIScope class MenuFactory {
    Menu create() { return new Menu(...); }
}

// ✅ GOOD: Non-UI logic only (no Component fields)
@Component @UIScope class LocaleManager implements LocaleChangeObserver {
    // Only business logic, no UI components stored
}
```

## @Lazy (Spring DI)

**Use:** @Component → @UIScope, circular deps, heavy resources
**Don't use:** Regular @Component deps, always-needed beans

## CRITICAL ANTIPATTERNS [BAD]
1. getTranslation() in constructor → NPE
2. Listeners without cleanup → memory leak
3. UI.getCurrent() in thread → NPE (save UI ref first)
4. Component in final field → memory leak
5. grid.setItems(all) for >100 → OOM (use lazy)
6. Forget super.onDetach(e)
7. @UIScope without @Lazy injection → scope conflict
8. @Lazy for regular @Component dependencies → unnecessary overhead
9. **@Component + extends Dialog** → singleton Dialog, state tree corruption
10. **@Component + extends any UI component (Layout, Button, etc.)** → memory leak risk
11. **removeAll() + add(sameComponent)** → component reuse, memory leak
12. **UI.getCurrent().add(this) in @Component** → state tree corruption
13. **Component field in singleton** → component reuse across UI sessions
14. **Html() with user data** → XSS vulnerability (sanitize first!)
15. **Hidden fields for security** → UI hiding is NOT security

## PUSH

**Pattern:** `UI ui = UI.getCurrent(); executor.submit(() -> ui.access(() -> update()));`

**Performance Considerations:**
- @Push creates WebSocket/Long-polling connection per user
- Memory overhead: ~1-2MB per connection
- Max connections: 10K-50K (depending on RAM)
- Consider @Push(PushMode.MANUAL) for controlled updates
- Disable push for anonymous/public users if possible
- Monitor WebSocket connections in production

**Best Practices:**
- Use @Push only when needed (real-time updates)
- Batch UI updates (don't call ui.access() in loop)
- Clean up background tasks in onDetach()
- Test with realistic user count (load testing)

## DIALOG PATTERN

- ✅ Factory: `new Dialog()` each time
- ✅ In View: `new MyDialog(...)` directly
- ❌ `@Component extends Dialog` = singleton, state corruption

## COMPONENT REUSE [BAD]

- ❌ `removeAll() + add(sameComponent)` = memory leak
- ✅ `setVisible(false/true)` OR recreate with `new`

## CHECKLIST
- [ ] Composite<T> (reusable) or extends for @Route views
- [ ] @PostConstruct or initContent()
- [ ] onDetach + Registration.remove()
- [ ] getTranslation() for all strings
- [ ] Server validation (Binder + Service layer)
- [ ] @RolesAllowed or @PermitAll on @Route
- [ ] Lazy loading if >100 items
- [ ] Lumo tokens (no hardcode)
- [ ] @Lazy for @UIScope dependencies
- [ ] No @Lazy for regular @Component dependencies
- [ ] No @Component + extends UI component (use Factory)
- [ ] No removeAll() + add(sameComponent)
- [ ] Dialog created via new each time
- [ ] Sanitize HTML if using Html() component
- [ ] HTTPS in production
- [ ] Session timeout configured
