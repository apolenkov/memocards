# Primitive Types Preference Rule

## General Principle
Always prefer primitive types (`long`, `int`, `boolean`, `double`, `float`, `short`, `byte`) over their wrapper types (`Long`, `Integer`, `Boolean`, `Double`, `Float`, `Short`, `Byte`) when the value cannot be `null`.

## When to Use Primitives
- **Method parameters** where the value is guaranteed to be non-null
- **Local variables** that store extracted primitive values
- **Map keys** where the key type cannot be null
- **Return values** from methods that never return null
- **Field types** in DTOs and records where null is not allowed

## When to Keep Wrapper Types
- **JPA entities** - `@Id private Long id;` (can be null before persistence)
- **Spring Data JPA repositories** - `JpaRepository<Entity, Long>`
- **Collections** - `List<Long>`, `Set<Long>`, `Map<Long, ?>`
- **Nullable fields** - where the value can legitimately be null
- **Optional return types** - `Optional<Long>`

## FQN (Fully Qualified Names) Prohibition
**NEVER use fully qualified names in code.** Always use proper imports instead.

### ❌ Bad - Using FQN
```java
// Never do this
java.util.Map<Long, DeckAggregate> result = new java.util.HashMap<>();
java.util.List<Object[]> rows = statsRepo.findAllByDeckIds(ids);
java.time.LocalDate today = java.time.LocalDate.now();
```

### ✅ Good - Using Imports
```java
// Always do this
import java.util.Map;
import java.util.HashMap;
import java.util.List;
import java.time.LocalDate;

Map<Long, DeckAggregate> result = new HashMap<>();
List<Object[]> rows = statsRepo.findAllByDeckIds(ids);
LocalDate today = LocalDate.now();
```

## Examples

### ✅ Good - Use Primitives
```java
// Method parameters
public void processDeck(long deckId) { ... }

// Local variables
long deckId = (Long) row[0];
Map<long, DeckAggregate> result = new HashMap<>();

// DTO fields
public record DeckDto(long id, String title) { ... }
```

### ❌ Bad - Unnecessary Wrapper Types
```java
// Method parameters (when not nullable)
public void processDeck(Long deckId) { ... }

// Local variables
Long deckId = (Long) row[0];
Map<Long, DeckAggregate> result = new HashMap<>();

// DTO fields (when not nullable)
public record DeckDto(Long id, String title) { ... }
```

### ✅ Correct - Keep Wrapper Types
```java
// JPA entities
@Id private Long id;

// Spring Data repositories
JpaRepository<DeckEntity, Long>

// Collections
List<Long> deckIds;
Map<Long, Deck> deckMap;

// Nullable fields
private Long parentDeckId; // can be null
```

## Performance Benefits
- **Memory**: Primitives use less memory (8 bytes vs 16+ bytes for Long)
- **Performance**: No boxing/unboxing overhead
- **Cache efficiency**: Better CPU cache utilization

## Implementation Guidelines
1. Review all method parameters and replace `Long` with `long` where appropriate
2. Replace local variables that store primitive values
3. Update DTOs and records to use primitives for non-nullable fields
4. Keep wrapper types only where absolutely necessary (JPA, collections, nullable fields)
5. Update method signatures in interfaces and implementations consistently
6. **NEVER use FQN - always add proper imports**
7. Use IDE auto-import functionality to manage imports automatically
description:
globs:
alwaysApply: true
---
