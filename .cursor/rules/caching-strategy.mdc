---
alwaysApply: true
autoFix: true
version: "3.0.0"
---

# CACHING STRATEGY

## STACK
@UIScope/@SessionScope | Spring Events | TTL | ConcurrentHashMap | AtomicLong

## CORE PATTERN
```java
@Component @UIScope
public class EntityCache<T> {
    @Value("${app.cache.entity.ttl-ms:60000}") long ttlMs;
    @Value("${app.cache.entity.max-size:1000}") int maxSize;
    Map<Long, Cached<T>> cache = new ConcurrentHashMap<>();
    AtomicLong hitCount, missCount;
    
    public T get(Long key, Supplier<T> loader) {
        Cached<T> cached = cache.get(key);
        if (cached != null && cached.isValid(ttlMs)) {
            hitCount.incrementAndGet(); return cached.data;
        }
        missCount.incrementAndGet();
        T data = loader.get();
        if (cache.size() >= maxSize) evictOldest();
        cache.put(key, new Cached<>(data, Instant.now()));
        return data;
    }
    
    @EventListener void onModified(EntityEvent e) { invalidate(e.getId()); }
    record Cached<T>(T data, Instant at) { 
        boolean isValid(long ttl) { return Instant.now().isBefore(at.plusMillis(ttl)); }
    }
}
```

## RULES
- **Scope**: @UIScope (single tab) | @SessionScope (multi-tab shared)
- **Config**: @Value with defaults (NO hardcoded values)
- **Invalidation**: @EventListener (primary) + TTL 1-5min (backup)
- **Metrics**: CacheStats record for testing | logStats() for debugging
- **Logging**: DEBUG level with `if (LOGGER.isDebugEnabled())` wrap
- **Bounded**: LRU eviction when cache.size() >= maxSize

## CRITICAL ANTIPATTERNS
1. Static cache → memory leak
2. TTL only (no events) → stale after edits
3. Unbounded cache → memory leak
4. Logging in get() → performance overhead
5. List.copyOf() in generic cache → compilation error
